<!DOCTYPE html>
<html>
<head>
<title>sdl2_tutorials</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h2 id="beginning-game-programming-v2-0">Beginning Game Programming v2.0</h2>
<p><strong>Last Updated 6/24/19</strong></p>
<p>Greetings everyone, welcome to the ground up recoding of Beginning Game Programming with SDL. This time we will be coding with SDL 2 which has been released on the SDL website.</p>
<p>These tutorials were designed for C++ programmers who want to move from text based games to real time games with graphics. By the end of these tutorials, you&#39;ll know the basics to make your first real video game!</p>
<p><strong>Table of Contents</strong></p>
<table>
<thead>
<tr>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#hello-sdl">01 Hello SDL</a></td>
<td>In this tutorial we will be setting up the SDL library and creating our first window.</td>
</tr>
<tr>
<td><a href="#getting-an-image-on-the-screen">02 Getting an Image on the Screen</a></td>
<td>Now that we can get a window to appear, lets blit an image onto it.</td>
</tr>
<tr>
<td><a href="#event-driven-programming">03 Event Driven Programming</a></td>
<td>Here we&#39;ll start handling user input by allowing the user to X out the window.</td>
</tr>
<tr>
<td><a href="#key-presses">04 Key Presses</a></td>
<td>Here we&#39;ll learn to handle keyboard input.</td>
</tr>
<tr>
<td><a href="#optimized-surface-loading-and-soft-stretching">05 Optimized Surface Loading and Soft Stretching</a></td>
<td>Now that we know how to load and blit surfaces, it&#39;s time to make our blits faster. We&#39;ll also take a smaller image and stretch it to fit the screen.</td>
</tr>
<tr>
<td><a href="#extension-libraries-and-loading-other-image-formats">06 Extension Libraries and Loading Other Image Formats</a></td>
<td>Here we&#39;ll be using the SDL_image extension library to load png images.</td>
</tr>
<tr>
<td><a href="#texture-loading-and-rendering">07 Texture Loading and Rendering</a></td>
<td>A big new feature in SDL 2.0 is hardware accelerated texture based 2D rendering. Here we&#39;ll be loading an image to render it using textures.</td>
</tr>
<tr>
<td><a href="#geometry-rendering">08 Geometry Rendering</a></td>
<td>Another new feature in SDL 2.0 is hardware accelerated primitive rendering. Here we&#39;ll be using it to render some common shapes.</td>
</tr>
<tr>
<td><a href="#the-viewport">09 The Viewport</a></td>
<td>SDL 2.0 also lets you control where you render on the screen using the viewport. We&#39;ll be using the viewport to create subscreens.</td>
</tr>
<tr>
<td><a href="#color-keying">10 Color Keying</a></td>
<td>Here we&#39;ll use color keying to give textures transparent backgrounds.</td>
</tr>
<tr>
<td><a href="#clip-rendering-and-sprite-sheets">11 Clip Rendering and Sprite Sheets</a></td>
<td>Using clip rendering, you can keep multiple images on one texture and render the part you need. We&#39;ll be using this to render individual sprites from a sprite sheet.</td>
</tr>
<tr>
<td><a href="#color-modulation">12 Color Modulation</a></td>
<td>We&#39;ll be altering the color of rendered textures using color modulation.</td>
</tr>
<tr>
<td><a href="#alpha-blending">13 Alpha Blending</a></td>
<td>Here we&#39;ll be using SDL 2.0 new hardware accelerated alpha blending.</td>
</tr>
<tr>
<td><a href="#animated-sprites-and-vsync">14 Animated Sprites and Vsync</a></td>
<td>Here we&#39;ll be using a sequence of sprites to animate them.</td>
</tr>
<tr>
<td><a href="#rotation-and-flipping">15 Rotation and Flipping</a></td>
<td>Here we&#39;ll be using SDL 2.0&#39;s new texture rotation and flipping.</td>
</tr>
<tr>
<td><a href="#true-type-fonts">16 True Type Fonts</a></td>
<td>Here we&#39;ll be rendering text from true type fonts using SDL_ttf.</td>
</tr>
<tr>
<td><a href="#mouse-events">17 Mouse Events</a></td>
<td>Here we&#39;ll learn to read mouse input using mouse events.</td>
</tr>
<tr>
<td><a href="#key-states">18 Key States</a></td>
<td>There are other ways to read the keys besides event polling. Here we will get the current state of the keyboard using key states.</td>
</tr>
<tr>
<td><a href="#gamepads-and-joysticks">19 Gamepads and Joysticks</a></td>
<td>Here we&#39;ll learn to read input from a game controller.</td>
</tr>
<tr>
<td><a href="#force-feedback">20 Force Feedback</a></td>
<td>Another new feature for SDL 2.0 is rumble support using the SDL haptics. We&#39;ll make our controller rumble when a button is pressed.</td>
</tr>
<tr>
<td><a href="#sound-effects-and-music">21 Sound Effects and Music</a></td>
<td>Here we&#39;ll be using SDL_mixer to add music and sound to our SDL App.</td>
</tr>
<tr>
<td><a href="#timing">22 Timing</a></td>
<td>Here we&#39;ll be using SDL&#39;s time capabilites.</td>
</tr>
<tr>
<td><a href="#advanced-timers">23 Advanced Timers</a></td>
<td>Here we&#39;ll extend SDL time capabilities to make our own custom timer.</td>
</tr>
<tr>
<td><a href="#calculating-frame-rate">24 Calculating Frame Rate</a></td>
<td>Here we&#39;ll use the timers we built to measure frame rate.</td>
</tr>
<tr>
<td><a href="#capping-frame-rate">25 Capping Frame Rate</a></td>
<td>If you need a constant frame rate when vsync isn&#39;t available, frame rate capping can be used as a fall back.</td>
</tr>
<tr>
<td><a href="#motion">26 Motion</a></td>
<td>Here we&#39;ll be taking what we learned about rendering and handling input to make a dot move around the screen.</td>
</tr>
<tr>
<td><a href="#collision-detection">27 Collision Detection</a></td>
<td>Here we&#39;ll have two objects interact with each other using bounding box collision detection.</td>
</tr>
<tr>
<td><a href="#per-pixel-collision-detection">28 Per-pixel Collision Detection</a></td>
<td>Here we&#39;ll have two objects collide using per-pixel collision detection.</td>
</tr>
<tr>
<td><a href="#circular-collision-detection">29 Circular Collision Detection</a></td>
<td>Here we&#39;ll learn to detect collisions with circles and boxes.</td>
</tr>
<tr>
<td><a href="#scrolling">30 Scrolling</a></td>
<td>Here we&#39;ll be implementing a camera to scroll levels larger than the screen.</td>
</tr>
<tr>
<td><a href="#scrolling-backgrounds">31 Scrolling Backgrounds</a></td>
<td>Here we&#39;ll be using a scrolling background to give the illusion of an infinite level.</td>
</tr>
<tr>
<td><a href="#text-input-and-clipboard-handling">32 Text Input and Clipboard Handling</a></td>
<td>Here we&#39;ll be using SDL 2.0&#39;s new way of handling text input and its new clipboard handling feature.</td>
</tr>
<tr>
<td><a href="#file-reading-and-writing">33 File Reading and Writing</a></td>
<td>Here we&#39;ll be using SDL&#39;s RWOps API to do binary file IO.</td>
</tr>
<tr>
<td><a href="#audio-recording">34 Audio Recording</a></td>
<td>SDL 2.0.8 supports audio recording. Here we&#39;ll be copying from the audio device to record and copying to the audio device to play back.</td>
</tr>
<tr>
<td><a href="#window-events">35 Window Events</a></td>
<td>Here we&#39;ll be handling events from a resizable window.</td>
</tr>
<tr>
<td><a href="#multiple-windows">36 Multiple Windows</a></td>
<td>A new feature in SDL is the ability to support more than one window. Here we&#39;ll make an application that has 3 windows.</td>
</tr>
<tr>
<td><a href="#multiple-displays">37 Multiple Displays</a></td>
<td>Another new feature of SDL 2.0 is the ability to handle more than one physical display. Here we&#39;ll make our window jump from display to display.</td>
</tr>
<tr>
<td><a href="#particle-engines">38 Particle Engines</a></td>
<td>Here we&#39;ll use a simple particle effect to create a simple trail effect.</td>
</tr>
<tr>
<td><a href="#tiling">39 Tiling</a></td>
<td>Here we&#39;ll make a simple level using a tiling engine.</td>
</tr>
<tr>
<td><a href="#texture-manipulation">40 Texture Manipulation</a></td>
<td>Here we&#39;ll be directly accessing and manipulating a texture&#39;s pixels.</td>
</tr>
<tr>
<td><a href="#bitmap-fonts">41 Bitmap Fonts</a></td>
<td>Here we&#39;ll be using a texture as a font using bitmap font techniques.</td>
</tr>
<tr>
<td><a href="#texture-streaming">42 Texture Streaming</a></td>
<td>Here we&#39;ll be rendering from a streaming data source using texture streaming.</td>
</tr>
<tr>
<td><a href="#render-to-texture">43 Render to Texture</a></td>
<td>Here we&#39;ll be taking a scene and rendering it to a texture.</td>
</tr>
<tr>
<td><a href="#frame-independent-movement">44 Frame Independent Movement</a></td>
<td>Here we&#39;ll be making the dot move independent of the current frame rate.</td>
</tr>
<tr>
<td><a href="#timer-callbacks">45 Timer Callbacks</a></td>
<td>SDL has another timing mechanism called timer callbacks. Here we&#39;ll be setting a function to be called back after a certain amount of time.</td>
</tr>
<tr>
<td><a href="#multithreading">46 Multithreading</a></td>
<td>Multithreading allows your program to do things simultaneously. Here we&#39;ll make things print to the console from outside our main thread.</td>
</tr>
<tr>
<td><a href="#semaphores">47 Semaphores</a></td>
<td>A major issue in multithreaded applications is that you need to make sure that they don&#39;t try to access the same data at the same time. Semaphores are a way to make sure only a certain amount of threads are performing an action at the same time.</td>
</tr>
<tr>
<td><a href="#atomic-operations">48 Atomic Operations</a></td>
<td>Atomic operations are another way to synchronize threads. Here we&#39;ll be redoing the previous tutorial with atomic counters.</td>
</tr>
<tr>
<td><a href="#mutexes-and-conditions">49 Mutexes and Conditions</a></td>
<td>Mutexes and conditions are yet another way to synchronize threads. Here we&#39;ll be using the added benefit that they allow threads to communicate with each other.</td>
</tr>
<tr>
<td><a href="#sdl-and-opengl-2">50 SDL and OpenGL 2</a></td>
<td>SDL is a powerful tool when combined with OpenGL. If you&#39;re just starting out with OpenGL or want to maximize compatibility, you can use SDL with OpenGL 2.1. In this tutorial we will make a minimalist OpenGL 2.1 program.</td>
</tr>
<tr>
<td><a href="#sdl-and-modern-opengl">51 SDL and Modern OpenGL</a></td>
<td>SDL 2.0 now has support for OpenGL 3.0+ with context controls. Here we&#39;ll be making a minimalist OpenGL 3+ core program.</td>
</tr>
<tr>
<td><a href="#hello-mobile">52 Hello Mobile</a></td>
<td>Here we&#39;ll be loading and displaying an image in our first mobile app!</td>
</tr>
<tr>
<td><a href="#extensions-and-changing-orientation">53 Extensions and Changing Orientation</a></td>
<td>Here we&#39;ll be using SDL extension libraries and handling changing orientation.</td>
</tr>
<tr>
<td><a href="#touches">54 Touches</a></td>
<td>Here we&#39;ll be handling single touch input.</td>
</tr>
<tr>
<td><a href="#multi-touch">55 Multitouch</a></td>
<td>Here we&#39;ll be handling multitouch events like pinches and rotation.</td>
</tr>
</tbody>
</table>
<h2 id="hello-sdl">Hello SDL</h2>
<p><img src="./res/sdl.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>So you learned the basics of C++, but you&#39;re sick of making little text based programs. In order to use things like graphics, sound, keyboards, joysticks, etc you need an API (Application Programmer&#39;s Interface) that takes all those hardware features and turns it into something C++ can interact with.</p>
<p>That&#39;s what SDL does. It takes the Windows/Linux/Mac/Android/iOS/etc tools and wraps them in a way that you can code something in SDL and compile it to what ever platform it supports. In order to use it, you need to install it.</p>
<p>SDL as a dynamically linked library. A dynamically linked library has 3 parts:</p>
<ul>
<li>The header files (Library.h)</li><li>The library files (Library.lib for windows or libLibrary.a for *nix)</li><li>The binary files (Library.dll for windows or Library.so for *nix)</li></ul>
<p>Your compiler needs to be able to find the header files when compiling so it knows what SDL_Init() and the other SDL functions and structures are. You can either configure your compiler to search in an additional directory where the SDL header files are located, or put the header files in with the rest of header files that your compiler comes with. If the compiler complains that it can&#39;t find SDL.h, it means the header files aren&#39;t in a place that the compiler looks for header files.</p>
<p>After your compiler compiles all your source files it has to link them together. In order for the program to link properly, it needs to know the addresses of all your functions including the ones for SDL. For a dynamically linked library, these addresses are in the library file. The library file has the Import Address Table so your program can import the functions at runtime. Like with header files, You can either configure your compiler to search in an additional directory where the SDL library files are located, or put the library files in with the rest of library files that your compiler comes with. You also have to tell the linker to link against the library file in the linker. If the linker complains that it can&#39;t find -lSDL or SDL2.lib, it means the library files aren&#39;t in a place that the linker looks for library files. If the linker complains about an undefined reference, it probably means it was never told to link the library.</p>
<p>After your program is compiled and linked, you need to be able to link against the library when you run it. In order to run a dynamically linked application, you need to be able to import the library binaries at runtime. Your operating system needs to be able to find the library binary when you run your program. You can either put the library binaries in the same directory as your executable, or a directory that your operating system keeps library binary files.</p>
<p>After you set up SDL, we&#39;ll cover <a href="#hello-sdl-your-first-graphics-window">how to create an SDL 2 window</a>.</p>
<table>
<thead>
<tr>
<th>Select Your Operating System</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/01_windows_logo.jpg" alt=""></td>
<td><a href="#setting-up-sdl-on-windows">Windows</a></td>
</tr>
<tr>
<td><img src="./res/01_linux_logo.jpg" alt=""></td>
<td><a href="#setting-up-sdl-2-on-linux">Linux</a></td>
</tr>
<tr>
<td><img src="./res/01_osx_logo.jpg.jpg" alt=""></td>
<td><a href="#setting-up-sdl-2-on-mac-os-x-yosemite">Mac OS X</a></td>
</tr>
</tbody>
</table>
<h2 id="hello-sdl-your-first-graphics-window">Hello SDL: Your First Graphics Window</h2>
<p><img src="./res/sdl.png" alt=""></p>
<p><strong>Last Updated 2/8/15</strong></p>
<p>This tutorial covers the first major stepping stone: getting a window to pop up.</p>
<p>Now that you have SDL set up, it&#39;s time to make a bare bones SDL graphics application that renders a quad on the screen.</p>
<pre><code>//Using SDL and standard IO
#include &lt;SDL.h&gt;
#include &lt;stdio.h&gt;

//Screen dimension constants
const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;
</code></pre><p>At the top of our source file we include SDL since we&#39;re going to need the SDL functions and datatypes to make any SDL code. We&#39;re also going to include C standard IO to print errors to the console. You&#39;re probably more used to using iostream, but I use printf in my applications because it&#39;s more thread safe. For these early applications, use what ever you are most comfortable with.</p>
<p>After including our headers, we declare the width and height of the window we&#39;re going to render to.</p>
<pre><code>int main( int argc, char* args[] )
{
    //The window we&#39;ll be rendering to
    SDL_Window* window = NULL;

    //The surface contained by the window
    SDL_Surface* screenSurface = NULL;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL_Error: %s\n&quot;, SDL_GetError() );
    }
</code></pre><p>Here&#39;s the top of our main function. It&#39;s important that we have the arguments of the function be an integer followed by a char* array and the return type be an integer. Any other type of main function will cause an undefined reference to main. SDL requires this type of main so it is compatible with multiple platforms.</p>
<p>We then declare our SDL window which we will be creating in a little bit. Following that we have a screen SDL surface. A SDL surface is just a 2D image. A 2D image can be loaded from a file or it can be the image inside of a window. In this case it will be the image we see inside of the window on the screen.</p>
<p>After declaring our window and screen surface, we initialize SDL. You can&#39;t call any SDL functions without initializing SDL first. Since all we care about is using SDL&#39;s video subsystem, we will only be passing it the SDL_INIT_VIDEO flag.</p>
<p>When there&#39;s an error, SDL_Init returns -1. When there&#39;s an error we want to print to the console what happened, other wise the application will just flash for a second and then go away.</p>
<p>If you have never used printf before, it stands for print format. It prints the string in the first argument with the variables in the following arguments. When there&#39;s an error here, &quot;SDL could not initialize! SDL_Error: &quot; will be written to the console followed by the string returned by SDL_GetError. That %s is special formatting. %s means output a string from our variable list. Since SDL_GetError is the only argument, the string it returns will be added. SDL_GetError returns the latest error produced by an SDL function.</p>
<p>SDL_GetError is a very useful function. Whenever something goes wrong you need to know why. SDL_GetError will let you know if any errors happened inside of any SDL function.</p>
<pre><code>    else
    {
        //Create window
        window = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );
        if( window == NULL )
        {
            printf( &quot;Window could not be created! SDL_Error: %s\n&quot;, SDL_GetError() );
        }
</code></pre><p>If SDL initialized successfully, we&#39;ll want to create a window using SDL_CreateWindow. The first argument sets the window&#39;s caption or this part of the window:</p>
<p><img src="./res/01_caption.png" alt=""></p>
<p>The next two arguments define the x and y position the window is created in. Since we don&#39;t care where it is created, we just put SDL_WINDOWPOS_UNDEFINED for the x and y position.</p>
<p>The next two arguments define the window&#39;s width and height. The last argument are the creation flags. SDL_WINDOW_SHOWN makes sure the window is shown when it is created.</p>
<p>If there is an error, SDL_CreateWindow returns NULL. If there&#39;s no window, we want to print out the error to the console.</p>
<pre><code>        else
        {
            //Get window surface
            screenSurface = SDL_GetWindowSurface( window );

            //Fill the surface white
            SDL_FillRect( screenSurface, NULL, SDL_MapRGB( screenSurface-&gt;format, 0xFF, 0xFF, 0xFF ) );

            //Update the surface
            SDL_UpdateWindowSurface( window );

            //Wait two seconds
            SDL_Delay( 2000 );
        }
    }
</code></pre><p>If the window was created successfully, we want to get the window&#39;s surface so we can draw to it. SDL_GetWindowSurface does just this.</p>
<p>To keep this tutorial simple, all we&#39;re going to do here is fill the window&#39;s surface white using SDL_FillRect. Don&#39;t worry too much about this function here. This tutorial is only concerned about getting a window to pop up.</p>
<p>An important thing to know about rendering is that just because you&#39;ve drawn something to the screen surface doesn&#39;t mean you&#39;ll see it. After you&#39;ve done all your drawing you need to update the window so it shows everything you drew. A call to SDL_UpdateWindowSurface will do this.</p>
<p>If all we do is create the window, fill it, and update it, all we&#39;re going to see is a window flash for a second and then close. To keep it from disappearing, we&#39;ll call SDL_Delay. SDL_Delay will wait for a given amount of milliseconds. A millisecond is 1/1000 of a second. This means the code above will make the window wait for 2000 1/1000 of a second or 2 seconds.</p>
<p>An important thing to note is that when SDL is delaying, it cannot accept input from the keyboard or mouse. Don&#39;t panic when you run this program and it doesn&#39;t respond. We haven&#39;t given it the code to handle the mouse and keyboard.</p>
<pre><code>    //Destroy window
    SDL_DestroyWindow( window );

    //Quit SDL subsystems
    SDL_Quit();

    return 0;
}
</code></pre><p>After the window has delayed there for 2 seconds, we&#39;ll destroy the window to free its memory. This will also take care of the SDL_Surface we got from it. After everything is deallocated, we quit SDL and return 0 to terminate the program.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/01_hello_SDL.zip">here</a>.</p>
<h2 id="setting-up-sdl-on-windows">Setting up SDL on Windows</h2>
<p><strong>Last Updated 6/21/14</strong></p>
<p><strong>An important note for Microsoft Windows developers</strong>:</p>
<p>As part of your set up process, you are going to have to place the dll file some place where your program can link with it during runtime. You can either put the dll file in the same directory as your executable, or put it in the system directory. C:\WINDOWS\SYSTEM32 is the 32bit windows system directory and C:\Windows\SysWOW64 is the 64bit system directory of 32bit applications.</p>
<p>The advantages of placing the dll file in the system directory are:</p>
<ol>
<li><p>Your operating system will always be able to find the library on your system, so you can compile and run dynamically linked applications anywhere on your system</p>
</li><li><p>You won&#39;t have to place a copy of the dll file with every single application you develop</p>
</li></ol>
<p>With that in mind, when distributing your application you should never mess with the user&#39;s system directory. The user could have applications that require SDL version ABC in the system directory and you could be overwriting it with SDL version XYZ. Your distribution version should have the dll files in the same directory as the executable.</p>
<table>
<thead>
<tr>
<th>Select Your IDE/Compiler</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/01_codeblock_log.png" alt=""></td>
<td><a href="#setting-up-sdl-2-on-code-blocks-12-11">Code::Blocks 12.11</a></td>
</tr>
<tr>
<td><img src="./res/01_vs_log.png" alt=""></td>
<td><a href="#setting-up-sdl-2-on-visual-studio-2010-ultimate">Visual Studio.NET 2010 Ultimate</a></td>
</tr>
<tr>
<td><img src="./res/01_mingw_log.png" alt=""></td>
<td><a href="#setting-up-sdl-2-on-mingw">Command Line (MinGW)</a></td>
</tr>
</tbody>
</table>
<h2 id="setting-up-sdl-2-on-code-blocks-12-11">Setting up SDL 2 on Code::Blocks 12.11</h2>
<p><strong>Last Updated 9/17/13</strong></p>
<ol>
<li><p>First thing you need to do is download SDL headers, libary and binaries. You will find them on the SDL website, specifically on <a href="http://libsdl.org/download-2.0.php">this page</a>.</p>
<p> Since Code::Blocks comes with the MinGW compiler by default, odds are you&#39;ll want to download the MinGW development libraries.</p>
<p> <img src="./res/01_mingw_package.png" alt=""></p>
<p> Open the gzip archive and there should be a tar archive. Open up the tar archive and the should be a folder called SDL2-2.something.something. In side of that folder there should be a bunch of folders and files, most importantly i686-w64-mingw32 which contains the 32bit library and x86_64-w64-mingw32 which contains the 64bit library.</p>
<p> This is important: most compilers still compile 32bit binaries by default to maximize compatibility. We will be using the 32bit binaries for this tutorial set. It doesn&#39;t matter if you have a 64bit operating system, since we are compiling 32bit binaries we will be using the 32bit library.</p>
<p> Inside of i686-w64-mingw32 are the include, lib, and bin folders which contain everything we need compile and run SDL applications. Copy the contents of i686-w64-mingw32 to any directory you want. I recommend putting it in a folder that you dedicate to holding all your development libraries for MinGW. For these tutorials I&#39;m putting it in a directory I created C:\mingw_dev_lib</p>
</li><li><p>Start up Code::Blocks and create a new empty project.</p>
<p> <img src="./res/01_new_project.png" alt=""></p>
</li><li><p>Go to project properties.</p>
<p> <img src="./res/01_project_properties.png" alt=""></p>
</li><li><p>Now we have to tell Code::Blocks to search for header files in the library folder we just extracted. Go to build options.</p>
<p> <img src="./res/01_build_options.png" alt=""></p>
<p> In the Search Directories, we need to add a new compiler directory. Click add, Select the SDL2 folder inside of the include directory from the folder we extracted. Say no when it asks you whether you want it to be a relative path. Now Code::Blocks knows where to find the SDL 2 header files.</p>
<p> If you get an error where the compiler says it can&#39;t find SDL.h, it means you messed up this step.</p>
</li><li><p>Next we are going to tell Code::Blocks to search for library files in the SDL folder we just extracted. All you have to is go to the linker tab and add the lib directory from the folder we extacted to the linker search directories.</p>
<p> <img src="./res/01_linker_directory.png" alt=""></p>
<p> If you get an error where the linker complains it can&#39;t find -lSDL2 or -lSDL2main, it means you messed up this step.</p>
</li><li><p>In order to compile SDL 2 code, we have to tell the compiler to link against the libraries. Go under Linker Settings and paste</p>
<p> <strong>-lmingw32 -lSDL2main -lSDL2</strong></p>
<p> into the other linker options field and click OK.<br> <img src="./res/01_linker.png" alt=""></p>
<p> If you get an error where the linker complains about a bunch of undefined references, it means you messed up this step.</p>
</li><li><p>Go back to the project properites and under Build Targets select the build type.</p>
<p> <img src="./res/01_build_type.png" alt=""></p>
<p> You can set it to GUI Application if you don&#39;t want console output, and Console Application if you do want console output. For this tutorial set, errors will be printed on the console, so I recommend leaving it as a console application as you are still learning and prototyping.</p>
</li><li><p>When our SDL 2 application runs, the operating system needs to be able to find the dll file.</p>
<p> Go find the SDL 2 folder you extracted and from the bin folder inside copy SDL2.dll and put it either where your executable will run, or inside of the system directory. C:\WINDOWS\SYSTEM32 is the 32bit windows system directory and C:\Windows\SysWOW64 is the 64bit system directory of 32bit applications. For these tutorials, I&#39;m assuming we&#39;re making 32bit applications. If you get an error when you run the program where it complains that it can&#39;t find SDL2.dll, it means you messed up this step.</p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/01_hello_SDL.zip">source for lesson 01</a>. Add the source files inside to your project.</p>
<p> Now build. If there are any errors, make sure you didn&#39;t skip a step.</p>
<p> Now that you have SDL 2 compiling, it time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-2-on-visual-studio-2010-ultimate">Setting up SDL 2 on Visual Studio 2010 Ultimate</h2>
<p><strong>Last Updated 2/8/15</strong></p>
<ol>
<li><p>First thing you need to do is download SDL 2 headers and binaries. You will find them on the SDL website, specifically on this page.</p>
<p> You&#39;ll want to download the visual c++ development libraries.</p>
<p> <img src="./res/01_msvc_package.png" alt=""></p>
<p> Open the zip archive and there should be a folder called SDL2-2.something.something. Copy the contents of the folder and put it anywhere you&#39;d like. I recommend putting it in a folder that you dedicate to holding all your development libraries for Visual Studio. For these tutorials I&#39;m putting them in a directory I created called C:\vs_dev_lib</p>
</li><li><p>Start up Visual Studio and create a new empty project.</p>
<p> <img src="./res/01_vs_new_project.png" alt=""></p>
</li><li><p>Go to project properties.</p>
<p> <img src="./res/01_vs_project_properties.png" alt=""></p>
</li><li><p>Now we have to tell Visual C++ to search for header files in the SDL 2 include folder we just extracted. Under Configuration Properties in the VC++ Directories menu, select the Include Directories field, click the tiny down arrow button, and click edit.</p>
<p> <img src="./res/01_vs_include_directories.png" alt=""></p>
</li><li><p>Click the folder icon, and then click the button that pops up.</p>
<p> <img src="./res/01_vs_add_include.png" alt=""></p>
</li><li><p>Now go find the SDL2 folders you extracted, and select the include folder and click OK.</p>
<p> <img src="./res/01_vs_new_include.png" alt=""></p>
<p> Now Visual Studio knows where to find the header files. If you get an error that the compiler can&#39;t find SDL.h, it means you messed up this step.</p>
</li><li><p>Next we going to tell Visual C++ to search for library files in the SDL 2 library folder we just extracted. Select the Library Directories field, click the tiny down arrow button, and click edit.</p>
<p> <img src="./res/01_vs_library_directories.png" alt=""></p>
</li><li><p>Click the folder icon, and then click the button that pops up.</p>
<p> <img src="./res/01_vs_add_library.png" alt=""></p>
</li><li><p>Now go find the lib folder you extracted, and select the lib folder where you find two folders. There&#39;s one for 32bit x86 architecture and for 64bit x64 architecture.</p>
<p> <img src="./res/01_vs_select_library.png" alt=""></p>
<p> <strong>This is important</strong>: most compilers still compile 32bit binaries by default to maximize compatibility. We will be using the 32bit binaries for this tutorial set. It doesn&#39;t matter if you have a 64bit operating system, since we are compiling 32bit binaries we will be using the 32bit library. This means you need to select the x86 folder and click ok. Now Visual Studio knows where to find the library files. If you get an error how the linker can&#39;t find SDL2.lib, it means you missed this step.</p>
</li><li><p>In order to compile SDL code, we have to tell the Visual C++ to link against the libraries. Go under Linker in the Input menu, edit the additional dependencies.</p>
<p><img src="./res/01_additional_depend_vs_encies.png" alt=""></p>
<p>Now Visual Studio knows to link against SDL 2. If you get a bunch of undefined reference error after compiling, it means you messed up this step.</p>
</li><li><p>Now paste</p>
<p><strong>SDL2.lib;</strong><br><strong>SDL2main.lib;</strong><br>into the Additional dependencies field and click OK.</p>
<p><img src="./res/01_vs_linker.png" alt="">    </p>
</li><li><p>Under Linker in the System menu, set the subsystem.</p>
<p><img src="./res/01_vs_subsystem.png" alt=""></p>
<p>You can set it to Windows if you don&#39;t want console output, and Console if you do want console output. For this tutorial set, errors will be printed on the console, so I recommend leaving it as a console application as you are still learning and prototyping. If you get an error about an entry point not being defined or unresolved external symbol _main it means you skipped this step.</p>
</li><li><p>When our SDL 2 application runs, the operating system needs to be able to find the dll file.</p>
<p>Go find the SDL 2 lib folder you extracted and copy SDL2.dll and put it either your project&#39;s working directory (where the vcxproj file is at), or inside of the system directory. C:\WINDOWS\SYSTEM32 is the 32bit windows system directory and C:\Windows\SysWOW64 is the 64bit system directory of 32bit applications. For these tutorials, I&#39;m assuming we&#39;re making 32bit applications.</p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/01_hello_SDL.zip">source for lesson 01</a>. Add the source file inside to your project.</p>
<p>Now build. If there are any errors, make sure you didn&#39;t skip a step.</p>
<p>Now that you have SDL 2 compiling, it&#39;s time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-2-on-mingw">Setting up SDL 2 on MinGW</h2>
<p><strong>Last Updated 6/21/14</strong></p>
<ol>
<li><p>First thing you need to do is download SDL headers, libary and binaries. You will find them on the SDL website, specifically on this page.</p>
<p> You&#39;ll want to download the MinGW development libraries.</p>
<p> <img src="./res/01_mingw_package.png" alt=""></p>
<p> Open the gzip archive and there should be a tar archive. Open up the tar archive and the should be a folder called SDL2-2.something.something. Inside of that folder there should be a bunch of folders and files, most importantly <strong>i686-w64-mingw32</strong> which contains the 32bit library and <strong>x86_64-w64-mingw32</strong> which contains the 64bit library.</p>
<p> <strong>This is important</strong>: most compilers still compile 32bit binaries by default to maximize compatibility. We will be using the 32bit binaries for this tutorial set. It doesn&#39;t matter if you have a 64bit operating system, since we are compiling 32bit binaries we will be using the 32bit library.</p>
<p> Inside of i686-w64-mingw32 are the include, lib, and bin folders which contain everything we need compile and run SDL applications. Copy the contents of i686-w64-mingw32 to any directory you want. I recommend putting it in a folder that you dedicate to holding all your development libraries for MinGW. For these tutorials I&#39;m putting it in a directory I created C:\mingw_dev_lib</p>
</li><li><p>Next you&#39;re going to want to get up the path for mingw so you can run mingw commands in any directory. Open up the system menu either by A) right clicking My Computer and selecting Properties or B) going to the Control Panel and selecting the system menu. Once your in the system menu, click advanced system settings.</p>
<p> <img src="./res/01_system.png" alt=""></p>
<p> and then click environment variables</p>
<p> <img src="./res/01_environment_variables.png" alt=""></p>
<p> Under system variables, select the &quot;Path&quot; variable and click edit.</p>
<p> <img src="./res/01_edit_path.png" alt=""></p>
<p> What the path variable does is tell the OS where to look when running an executable. What we want to do is whenever we run the g++ command, the OS should look in the MinGW bin directory where g++.exe is located. If you installed MinGW by itself, the MinGW bin directory should be<br> <strong>C:\MinGW\bin</strong><br> Append it to the long list of paths with a semi-colon after it and click ok.</p>
<p> If you&#39;re using an IDE like Code::Blocks which uses MinGW, you can also set its MinGW bin directory which should be at<br> <strong>C:\Program Files (x86)\CodeBlocks\MinGW\bin</strong><br> Now when ever you run a command that uses a MinGW executable, the OS will know to look in the MinGW bin directory.</p>
<p> If you run your program and it complains that it can&#39;t find SDL2.dll, it means you did not set the path correctly.</p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/01_hello_SDL.zip">source for lesson 01</a>. Extract the source somewhere. Open up a command window in the directory by holding shift and right clicking.</p>
<p> Now compile by entering this big old command (This command assumed you have SDL 2 extracted at C:\mingw_dev_lib):<br> <strong>g++ 01_hello_SDL.cpp -IC:\mingw_dev_lib\include\SDL2 -LC:\mingw_dev_lib\lib -w -Wl,-subsystem,windows -lmingw32 -lSDL2main -lSDL2 -o 01_hello_SDL</strong><br> Having to manually punch in this compilation command gets very tedious very quickly. This is why I recommend using Make.</p>
</li><li><p>MingGW Make allows you to make build scripts that&#39;ll automate the compilation process.</p>
<p> From Basic Makefile</p>
<pre><code> #OBJS specifies which files to compile as part of the project
 OBJS = 01_hello_SDL.cpp

 #OBJ_NAME specifies the name of our exectuable
 OBJ_NAME = 01_hello_SDL

 #This is the target that compiles our executable
 all : $(OBJS)
     g++ $(OBJS) -IC:\mingw_dev_lib\include\SDL2 -LC:\mingw_dev_lib\lib -w -Wl,-subsystem,windows -lmingw32 -lSDL2main -lSDL2 -o $(OBJ_NAME)
</code></pre><p> Here we have a basic Makefile. At the top we declare and set the &quot;OBJS&quot; macro which specifies which files we&#39;re compiling. Then we set the &quot;OBJ_NAME&quot; macro that specifies the name of our executable.</p>
<p> After setting these two macros, we have the &quot;all&quot; target which compiles the program. It&#39;s followed by the dependencies which as you can see is the OBJS macro, because obviously you need the source files to compile the program.</p>
<p> After specifying the name of the target and its dependencies, the command to create the target is on the next line. <strong>The command to create the target must begin with a tab or Make will reject it.</strong></p>
<p> As you would expect, the command to compile the program is largely the same as the command we would compile it off the command line. A key difference is that we have macros that we insert into the command which makes things like adding new files to the project must easier since you only have to change the macro as opposed to changing the whole command.</p>
<p> In future tutorials, we will be using more libraries. We should probably use more macros to make the process of adding them easier.</p>
<p> From Makefile</p>
<pre><code> #OBJS specifies which files to compile as part of the project
 OBJS = 01_hello_SDL.cpp

 #CC specifies which compiler we&#39;re using
 CC = g++

 #INCLUDE_PATHS specifies the additional include paths we&#39;ll need
 INCLUDE_PATHS = -IC:\mingw_dev_lib\include\SDL2

 #LIBRARY_PATHS specifies the additional library paths we&#39;ll need
 LIBRARY_PATHS = -LC:\mingw_dev_lib\lib

 #COMPILER_FLAGS specifies the additional compilation options we&#39;re using
 # -w suppresses all warnings
 # -Wl,-subsystem,windows gets rid of the console window
 COMPILER_FLAGS = -w -Wl,-subsystem,windows

 #LINKER_FLAGS specifies the libraries we&#39;re linking against
 LINKER_FLAGS = -lmingw32 -lSDL2main -lSDL2

 #OBJ_NAME specifies the name of our exectuable
 OBJ_NAME = 01_hello_SDL

 #This is the target that compiles our executable
 all : $(OBJS)
     $(CC) $(OBJS) $(INCLUDE_PATHS) $(LIBRARY_PATHS) $(COMPILER_FLAGS) $(LINKER_FLAGS) -o $(OBJ_NAME)
</code></pre><p> Now our compilation command is much more flexible.</p>
<p> Near the top we have the macros that define the files we&#39;re compiling and the compiler we&#39;re using.</p>
<p> Next we have the &quot;INCLUDE_PATHS&quot; macro which specifies the additional directories we&#39;re getting header files from. As you can see, we&#39;re using the include directory from the SDL2 folder we extacted earlier. The &quot;LIBRARY_PATHS&quot; sets the additional library file paths. Notice how there&#39;s a -I before every include directory and a -L before every library directory.</p>
<p> The &quot;COMPILER_FLAGS&quot; macro are the additional options we use when compiling. In this case we&#39;re disabling all warnings and disabling the console window. The &quot;LINKER_FLAGS&quot; macro specifies which libraries we&#39;re linking against. Here we&#39;re compiling against 32bit mingw, SDL2, and SDL2main. Notice how there&#39;s a -l flag before every library.</p>
<p> Finally at the bottom we have our target compiling using all of our macros. Thanks to macros we can very easily change the macros to add more files and libraries as we need them.</p>
<p> Save this Makefile code to a file named &quot;Makefile&quot; (case sensitive with no file extension) or you can use the one I premade <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/windows/mingw/Makefile">here</a>. Open a command line in the directory with the source files and run the command mingw32-make.exe. Make will search for a file named &quot;Makefile&quot; in the directory Make was called in and run the Makefile that will compile your code.</p>
<p> Now that you have SDL 2 compiling, it time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-2-on-linux">Setting up SDL 2 on Linux</h2>
<p><strong>Last Updated 2/2/15</strong></p>
<p>Since there are so many flavors of Linux these tutorials might not work on your Linux set up. If you&#39;ve tried everything and are still having problems, <a href="http://lazyfoo.net/contact.php">contact me</a> and I&#39;ll try to add on a distro specific fix.</p>
<p>In the age of packaging managers, a lot of the work is done for you when installing libraries. You&#39;ll need root privileges to install packages so make sure to use &quot;su&quot; or &quot;sudo&quot; if you&#39;re not logged in as root.</p>
<p>Make sure you have updated to the latest version of your distro because your older package manager may not support the latest version of SDL 2.</p>
<ol>
<li><p>For those of you who have Advanced Packaging Tool available (ie Ubuntu and Debian) you&#39;ll want to search the apt-get cache to find the current SDL 2 version to install. You can search the apt-get available packages using the command:</p>
<pre><code> apt-cache search libsdl2
</code></pre><p> You&#39;ll want to download the development version of SDL 2. As of the last update of this tutorial, the development package of SDL 2 is <strong>libsdl2-dev</strong>. You can install this package using the command</p>
<pre><code> apt-get install libsdl2-dev
</code></pre></li><li><p>If you use the Yellow dog Updater, Modified (used in Fedora and CentOS) you can enter the command:</p>
<pre><code> yum search SDL2-devel
</code></pre><p> To search for the SDL 2 developers package. As of the last update of this tutorial, the developer package for SDL 2 is SDL2-devel. You can install this package using the command:</p>
<pre><code> yum install SDL2-devel
</code></pre></li><li><p>If somehow you don&#39;t have a package manager, you can install from the source the classic Unix way. Download the latest source from the <a href="http://www.libsdl.org/download-2.0.php#source">SDL website</a>.</p>
<p> <img src="./res/01_nix_download.png" alt=""></p>
<p> Extract the archive and cd to the folder that got extracted. Configure the installation using</p>
<pre><code> ./configure
</code></pre><p> Compile the source using the make command</p>
<pre><code> make all
</code></pre><p> Finally, install the package using the make command</p>
<pre><code> make install
</code></pre><p> Note: If you do a manual install you may have to specify where the headers and library files are for your compiler/IDE.</p>
</li><li><p>Now that you&#39;ve installed the development libraries, it&#39;s time to start up your IDE/compiler.</p>
</li></ol>
<table>
<thead>
<tr>
<th>Select Your IDE/Compiler</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/01_nix_cosole_logo.jpg" alt=""></td>
<td><a href="#setting-up-sdl-2-on-g++">Command Line</a></td>
</tr>
<tr>
<td><img src="./res/01_nix_codeblock.png" alt=""></td>
<td><a href="01_nix_codeblock.html">Code::Blocks</a></td>
</tr>
</tbody>
</table>
<h2 id="setting-up-sdl-2-on-g-">Setting up SDL 2 on g++</h2>
<p><strong>Last Updated 6/21/14</strong></p>
<ol>
<li><p>Go download the <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/01_hello_SDL.zip">source for lesson 01</a>. Extract the source somewhere. Now compile by entering this command:</p>
<pre><code> g++ 01_hello_SDL.cpp -w -lSDL2 -o 01_hello_SDL
</code></pre><p> Now you may get an error saying it can&#39;t find SDL.h. For linux, we&#39;ll have to include the SDL headers like this:</p>
<pre><code> #include&lt;SDL2/SDL.h&gt;
</code></pre><p> As the programs get bigger and bigger, having to manually punch in this compilation command gets very tedious very quickly. This is why I recommend using Make.</p>
</li><li><p>GNU Make allows you to make build scripts that&#39;ll automate the compilation process.<br> From Basic Makefile</p>
<pre><code> #OBJS specifies which files to compile as part of the project
 OBJS = 01_hello_SDL.cpp

 #OBJ_NAME specifies the name of our exectuable
 OBJ_NAME = 01_hello_SDL

 #This is the target that compiles our executable
 all : $(OBJS)
     g++ $(OBJS) -w -lSDL2 -o $(OBJ_NAME)
</code></pre><p> Here we have a basic Makefile. At the top we declare and set the &quot;OBJS&quot; macro which specifies which files we&#39;re compiling. Then we set the &quot;OBJ_NAME&quot; macro that specifies the name of our executable.</p>
<p> After setting these two macros, we have the &quot;all&quot; target which compiles the program. It&#39;s followed by the dependencies which as you can see is the OBJS macro, because obviously you need the source files to compile the program.</p>
<p> After specifying the name of the target and its dependencies, the command to create the target is on the next line. <strong>The command to create the target must begin with a tab or Make will reject it</strong>.</p>
<p> As you would expect, the command to compile the program is largely the same as the command we would compile it off the command line. A key difference is that we have macros that we insert into the command which makes things like adding new files to the project must easier since you only have to change the macro as opposed to changing the whole command.</p>
<p> In future tutorials, we will be using more libraries. We should probably use more macros to make the process of adding them easier.</p>
<p> From Makefile</p>
<pre><code> #OBJS specifies which files to compile as part of the project
 OBJS = 01_hello_SDL.cpp

 #CC specifies which compiler we&#39;re using
 CC = g++

 #COMPILER_FLAGS specifies the additional compilation options we&#39;re using
 # -w suppresses all warnings
 COMPILER_FLAGS = -w

 #LINKER_FLAGS specifies the libraries we&#39;re linking against
 LINKER_FLAGS = -lSDL2

 #OBJ_NAME specifies the name of our exectuable
 OBJ_NAME = 01_hello_SDL

 #This is the target that compiles our executable
 all : $(OBJS)
     $(CC) $(OBJS) $(COMPILER_FLAGS) $(LINKER_FLAGS) -o $(OBJ_NAME)
</code></pre><p> Now our compilation command is much more flexible.</p>
<p> Near the top we have the macros that define the files we&#39;re compiling and the compiler we&#39;re using.</p>
<p> The &quot;COMPILER_FLAGS&quot; macro are the additional options we use when compiling. In this case we&#39;re disabling all warnings. The &quot;LINKER_FLAGS&quot; macro specifies which libraries we&#39;re linking against. Here we&#39;re compiling against SDL2. Notice how there&#39;s a -l flag before the library.</p>
<p> Finally at the bottom we have our target compiling using all of our macros. Thanks to macros we can very easily change the macros to add more files and libraries as we need them.</p>
<p> Save this Makefile code to a file named &quot;Makefile&quot; (case sensitive with no file extension) or you can use the one I premade <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/linux/cli/Makefile">here</a>. Open a command line in the directory with the source files and run the command <code>make all</code>. Make will search for a file named &quot;Makefile&quot; in the directory Make was called in and run the Makefile that will compile your code.</p>
<p> Now that you have SDL2 compiling, it time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-2-on-code-blocks-13-12">Setting up SDL 2 on Code::Blocks 13.12</h2>
<p><strong>Last Updated 2/2/15</strong></p>
<ol>
<li><p>Start up Code::Blocks and create a new empty project.<br> <img src="./res/01_nix_new_project.png" alt=""></p>
</li><li><p>Go to project properties.<br> <img src="./res/01_nix_project_properties.png" alt=""><br> In the project properties go to build options.<br> <img src="./res/01_nix_build_options.png" alt=""></p>
</li><li><p>In order to compile SDL 2 code, we have to tell the compiler to link against the libraries. Go under Linker Settings and paste</p>
<pre><code> -lSDL2
</code></pre><p> into the other linker options field and click OK.<br> <img src="./res/01_nix_linker.png" alt=""><br> If you get an error where the linker complains about a bunch of undefined references, it means you messed up this step.</p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/01_hello_SDL.zip">source for lesson 01</a>. Add the source files inside to your project.</p>
<p> Now build. Now you may get an error saying it can&#39;t find SDL.h. For linux, we&#39;ll have to include the SDL headers like this:</p>
<pre><code> #include&lt;SDL2/SDL.h&gt;
</code></pre><p> Now that you have SDL 2 compiling, it time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-2-on-mac-os-x-yosemite">Setting up SDL 2 on Mac OS X Yosemite</h2>
<p><strong>Last Updated 1/12/15</strong></p>
<ol>
<li><p>First thing you need to do is download the OS X development libraries from the <a href="http://www.libsdl.org/download-2.0.php#source">SDL website</a>.<br> <img src="./res/01_osx_download.png" alt=""></p>
</li><li><p>Next open the dmg and copy the SDL2.framework to /Library/Frameworks. To go directly to a path in finder, press command+shift+g.<br> <img src="./res/01_osx_copy_framework.png" alt=""></p>
</li><li><p>The framework may need to be resigned. To sign the framework, open up a terminal to:</p>
<pre><code> /Library/Frameworks/SDL2.framework/
</code></pre><p> and sign the framework using the command:</p>
<pre><code> codesign -f -s - SDL2
</code></pre></li><li><p>Now that you&#39;ve installed the development libraries, it&#39;s time to start up your IDE/compiler.</p>
</li></ol>
<table>
<thead>
<tr>
<th>Select Your IDE/Compiler</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/01_osx_logo.jpg" alt=""></td>
<td><a href="#setting-up-sdl-2-on-xcode-6.1">XCode 6.1</a></td>
</tr>
</tbody>
</table>
<h2 id="setting-up-sdl-2-on-xcode-6-1">Setting up SDL 2 on XCode 6.1</h2>
<p><strong>Last Updated 1/12/15</strong></p>
<p>With the SDL 2 framework installed, it&#39;s time to create an SDL project in XCode.</p>
<ol>
<li><p>Create a new command line project:<br> <img src="./res/01_xcode_new_cli.png" alt=""><br> You can set up this part of the project however you want, but do make sure to set it up as C++ project:<br> <img src="./res/01_xcode_project_config.png" alt=""></p>
</li><li><p>Select your SDL project and go to the Build Phases tab. In the Link Binary with Libraries section, click the plus:<br> <img src="./res/01_xcode_build_phases.png" alt=""></p>
<p> To add the SDL 2 framework, click Add Other and go to /Library/Frameworks/ using command+shift+g to select the SDL 2 framework and hit open.<br> <img src="./res/01_xcode_add_other.png" alt=""></p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/01_hello_SDL.zip">source for lesson 01</a>. Add the source files inside to your project.</p>
<p> By default in the tutorials, the SDL headers are included like this:</p>
<pre><code> #include &lt;SDL/SDL.h&gt;
</code></pre><p> SDL on Mac OS X does things differently, so we have to include the headers like this:</p>
<pre><code> #include &lt;SDL2/SDL.h&gt;
</code></pre><p> Now build. If there are any errors, make sure you didn&#39;t skip a step.</p>
</li><li><p>In order for your application to be able to find the files you use for the application, you need to set the working directory. Go to product, scheme, and edit scheme:</p>
<p> <img src="./res/01_xcode_edit_scheme.png" alt=""></p>
<p> Here you check Use Custom Working Directory and set the working directory. The working directory is where the application will think it is operating in. I recommend setting it to your project directory and putting the tutorial folders we&#39;ll be using in that directory.</p>
<p> <img src="./res/01_xcode_working_directory.png" alt=""></p>
<p> If your project can&#39;t load files for images, fonts, or sound it&#39;s because you did not set up your working directory properly.</p>
</li></ol>
<h2 id="getting-an-image-on-the-screen">Getting an Image on the Screen</h2>
<p><img src="./res/02_preview.png" alt=""></p>
<p><strong>Last Updated 1/06/19</strong></p>
<p>Now that you&#39;ve already got a window open, let&#39;s put an image on it.</p>
<p>Note: From now on the tutorials will only cover key parts of source code. For the full program, you will have to download the full source code.</p>
<pre><code>//Starts up SDL and creates window
bool init();

//Loads media
bool loadMedia();

//Frees media and shuts down SDL
void close();
</code></pre><p>In the first tutorial, we put everything in the main function. Since it was a small program we can get away with that, but in real programs (like video games) you want to have your code as modular as possible. This means you want your code to be in neat chunks that are each easy to debug and reuse.</p>
<p>Here it means we have functions to handle initialization, loading media, and closing down the SDL application. We declare these near the top of our source file.</p>
<p>I get a lot of e-mails about how calling this function &quot;close&quot; causes conflicts in C because does not support function overloading. This is one of the reasons I am using C++ for this tutorial. So it is not bug that this is function is called &quot;close&quot;.</p>
<pre><code>//The window we&#39;ll be rendering to
SDL_Window* gWindow = NULL;

//The surface contained by the window
SDL_Surface* gScreenSurface = NULL;

//The image we will load and show on the screen
SDL_Surface* gHelloWorld = NULL;
</code></pre><p>Here we declare some global variables. Typically you want to avoid using global variables in large programs. The reason we&#39;re doing it here is because we want the source code to be as simple as possible, but in large projects global variables make things more complicated. Since this is a single source file program we don&#39;t have to worry about it too much.</p>
<p>Here&#39;s a new data type called an SDL Surface. An SDL surface is just an image data type that contains the pixels of an image along with all data needed to render it. SDL surfaces use software rendering which means it uses the CPU to render. It is possible to render hardware images but it&#39;s a bit more difficult so we&#39;re going to learn it the easy way first. In future tutorials we&#39;ll cover how to render GPU accelerated images.</p>
<p>The images we&#39;re going to be dealing with here are the screen image (what you see inside of the window) and the image we&#39;ll be loading from a file.</p>
<p>Notice that these are pointers to SDL surfaces. The reason is that </p>
<ol>
<li>we&#39;ll be dynamically allocating memory to load images and</li><li>it&#39;s better to reference an image by memory location. Imagine you had a game with a brick wall that consisted of the same brick image being rendered multiple times (like Super Mario Bros). It&#39;s wasteful to have dozens of copies of the image in memory when you can have one copy of the image and render it over and over again.</li></ol>
<p>Also, always remember to initialize your pointers. We set them to NULL immediately when declaring them.</p>
<pre><code>bool init()
{
    //Initialization flag
    bool success = true;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL_Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
    else
    {
        //Create window
        gWindow = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );
        if( gWindow == NULL )
        {
            printf( &quot;Window could not be created! SDL_Error: %s\n&quot;, SDL_GetError() );
            success = false;
        }
        else
        {
            //Get window surface
            gScreenSurface = SDL_GetWindowSurface( gWindow );
        }
    }

    return success;
}
</code></pre><p>As you can see here, we&#39;ve taken the SDL initialization and the window creation code and put it in its own function. What&#39;s new is that there&#39;s a call to SDL_GetWindowSurface.</p>
<p>We want to show images inside of the window and in order to do that we need to get the image inside of the window. So we call SDL_GetWindowSurface to grab the surface contained by the window.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load splash image
    gHelloWorld = SDL_LoadBMP( &quot;02_getting_an_image_on_the_screen/hello_world.bmp&quot; );
    if( gHelloWorld == NULL )
    {
        printf( &quot;Unable to load image %s! SDL Error: %s\n&quot;, &quot;02_getting_an_image_on_the_screen/hello_world.bmp&quot;, SDL_GetError() );
        success = false;
    }

    return success;
}
</code></pre><p>In the load media function we load our image using SDL_LoadBMP. SDL_LoadBMP takes in the path of a bmp file and returns the loaded surface. If the function returns NULL, that means it failed so we print to the console an error using SDL_GetError.</p>
<p>An important thing to note is that this piece of code assumes you have a directory called &quot;02_getting_an_image_on_the_screen&quot; that contains an image named &quot;hello_world.bmp&quot; in your working directory. The working directory is where your application thinks it is operating. Typically, your working directory is the directory where your executable is at but some programs like Visual Studio change the working directory to where the vcxproj file is located. So if your application can&#39;t find the image, make sure it is in the right place.</p>
<p>Again, if the program is running but it can&#39;t load the image, you probably have a working directory problem. Working directories function differently from OS to OS and IDE to IDE. If googling how find or fix the working directory can&#39;t turn up a solution, I recommend moving around the &quot;02_getting_an_image_on_the_screen&quot; folder with the &quot;hello_world.bmp&quot; around until the program can finally load it.</p>
<pre><code>void close()
{
    //Deallocate surface
    SDL_FreeSurface( gHelloWorld );
    gHelloWorld = NULL;

    //Destroy window
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;

    //Quit SDL subsystems
    SDL_Quit();
}
</code></pre><p>In our clean up code, we destroy the window and quit SDL like before but we also have to take care of the surface we loaded. We do this by freeing it with SDL_FreeSurface. Don&#39;t worry about the screen surface, SDL_DestroyWindow will take care of it.</p>
<p>Make sure to get into the habit of having your pointers point to NULL when they&#39;re not pointing to anything.</p>
<pre><code>int main( int argc, char* args[] )
{
    //Start up SDL and create window
    if( !init() )
    {
        printf( &quot;Failed to initialize!\n&quot; );
    }
    else
    {
        //Load media
        if( !loadMedia() )
        {
            printf( &quot;Failed to load media!\n&quot; );
        }
        else
        {
            //Apply the image
            SDL_BlitSurface( gHelloWorld, NULL, gScreenSurface, NULL );
</code></pre><p>In our main function we initialize SDL and load the image. If that succeeded we blit the loaded surface onto the screen surface using SDL_BlitSurface.</p>
<p>What blitting does is take a source surface and stamps a copy of it onto the destination surface. The first argument of SDL_BlitSurface is the source image. The third argument is the destination. We&#39;ll worry about the 2nd and 4th arguments in future tutorials.</p>
<p>Now if this was the only code for drawing we had, we still wouldn&#39;t see the image we loaded on the screen. There&#39;s one more step.</p>
<pre><code>            //Update the surface
            SDL_UpdateWindowSurface( gWindow );
</code></pre><p>After drawing everything on the screen that we want to show for this frame we have to update the screen using SDL_UpdateWindowSurface. See when you draw to the screen, you are not typically drawing to the image on the screen you see. By default, most rendering systems out there are double buffered. These two buffers are the front and back buffer.</p>
<p>When you make draw calls like SDL_BlitSurface, you render to the back buffer. What you see on the screen is the front buffer. The reason we do this is because most frames require drawing multiple objects to the screen. If we only had a front buffer, we would be able to see the frame as things are being drawn to it which means we would see unfinished frames. So what we do is draw everything to the back buffer first and once we&#39;re done we swap the back and front buffer so now the user can see the finished frame.</p>
<p>This also means that you don&#39;t call SDL_UpdateWindowSurface after every blit, only after all the blits for the current frame are done.</p>
<pre><code>            //Wait two seconds
            SDL_Delay( 2000 );
        }
    }

    //Free resources and close SDL
    close();

    return 0;
}
</code></pre><p>Now that we&#39;ve rendered everything to the window, we delay for two seconds so the window doesn&#39;t just disappear. After the wait is done, we close out our program.</p>
<p>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/02_getting_an_image_on_the_screen/02_getting_an_image_on_the_screen.zip">here</a>.</p>
<h2 id="event-driven-programming">Event Driven Programming</h2>
<p><img src="./res/03_preview.png" alt=""></p>
<p><strong>Last Updated 1/04/14</strong></p>
<p>Besides just putting images on the screen, games require that you handle input from the user. You can do that with SDL using the event handling system.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;
</code></pre><p>In our code after SDL is initialized and the media is loaded (as mentioned in the <a href="#getting-an-image-on-the-screen">previous tutorial</a>), we declare a quit flag that keeps track of whether the user has quit or not. Since we just started the application at this point, it is obviously initialized to false.</p>
<p>We also declare an <a href="http://wiki.libsdl.org/SDL_Event?highlight=%28%5CbCategoryStruct%5Cb%29%7C%28CategoryEvents%29">SDL_Event</a> union. A SDL event is some thing like a <a href="http://wiki.libsdl.org/SDL_KeyboardEvent?highlight=%28\bCategoryStruct\b%29|%28CategoryEvents%29">key press</a>, <a href="http://wiki.libsdl.org/SDL_MouseMotionEvent?highlight=%28\bCategoryStruct\b%29|%28CategoryEvents%29">mouse motion</a>, <a href="http://wiki.libsdl.org/SDL_JoyButtonEvent?highlight=%28\bCategoryStruct\b%29|%28CategoryEvents%29">joy button press</a>, etc. In this application we&#39;re going to look for quit events to end the application.</p>
<pre><code>            //While application is running
            while( !quit )
            {
</code></pre><p>In the previous tutorials, we had the program wait for a few seconds before closing. In this application we&#39;re having the application wait until the user quits before closing.</p>
<p>So we&#39;ll have the application loop while the user has not quit. This loop that keeps running while the application is active is called the main loop, which is sometimes called the game loop. It is the core of any game application.</p>
<pre><code>                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }
</code></pre><p>At the top of our main loop we have our event loop. What this does is keep processing the event queue until it is empty.</p>
<p>When you press a key, move the mouse, or touch a touch screen you put events onto the event queue.<br><img src="./res/03_enqueue.png" alt=""></p>
<p>The event queue will then store them in the order the events occured waiting for you to process them. When you want to find out what events occured so you can process them, you poll the event queue to get the most recent event by calling <a href="http://wiki.libsdl.org/SDL_PollEvent?highlight=%28\bCategoryEvents\b%29|%28CategoryEnum%29|%28CategoryStruct%29">SDL_PollEvent</a>. What SDL_PollEvent does is take the most recent event from the event queue and puts the data from the event into the SDL_Event we passed into the function.<br><img src="./res/03_dequeue.png" alt=""></p>
<p>SDL_PollEvent will keep taking events off the queue until it is empty. When the queue is empty, SDL_PollEvent will return 0. So what this piece of code does is keep polling events off the event queue until it&#39;s empty. If an event from the event queue is an SDL_QUIT event (which is the event when the user Xs out the window), we set the quit flag to true so we can exit the application.</p>
<pre><code>                //Apply the image
                SDL_BlitSurface( gXOut, NULL, gScreenSurface, NULL );

                //Update the surface
                SDL_UpdateWindowSurface( gWindow );
            }
</code></pre><p>After we&#39;re done processing the events for our frame, we draw to the screen and update it (as discussed in the <a href="#getting-an-image-on-the-screen">previous tutorial</a>). If the quit flag was set to true, the application will exit at the end of the loop. If it is still false it will keep going until the user Xs out the window.</p>
<p>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/03_event_driven_programming/03_event_driven_programming.zip">here</a>.</p>
<h2 id="key-presses">Key Presses</h2>
<p><img src="./res/04_preview.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>Xing out the window is just one of the events SDL is capable of handling. Another type of input used heavily in games is the keyboard. In this tutorial we&#39;re going to make different images appear depending on which key you press.</p>
<pre><code>//Key press surfaces constants
enum KeyPressSurfaces
{
    KEY_PRESS_SURFACE_DEFAULT,
    KEY_PRESS_SURFACE_UP,
    KEY_PRESS_SURFACE_DOWN,
    KEY_PRESS_SURFACE_LEFT,
    KEY_PRESS_SURFACE_RIGHT,
    KEY_PRESS_SURFACE_TOTAL
};
</code></pre><p>Near the top of the source code we declare an enumeration of the different surfaces we have. Enumerations are a shorthand way to do symbolic constants instead of having to do const int KEY_PRESS_SURFACE_DEFAULT = 0; const int KEY_PRESS_SURFACE_UP = 1; const int KEY_PRESS_SURFACE_DOWN = 2; and such. They default to start counting at 0 and go up by one for each enumeration you declare. This means KEY_PRESS_SURFACE_DEFAULT is 0, KEY_PRESS_SURFACE_UP is 1, KEY_PRESS_SURFACE_DOWN is 2, KEY_PRESS_SURFACE_LEFT is 3, KEY_PRESS_SURFACE_RIGHT is 4, and KEY_PRESS_SURFACE_TOTAL is 5, It&#39;s possible to give them explicit integer values, but we won&#39;t be covering that here. A quick Google search on enumerations should cover that.</p>
<p>One bad habit beginning programmers have is using abritary numbers instead of symbolic constants. For example they&#39;ll have 1 mean main menu, 2 mean options, etc which is fine for small programs. When you&#39;re dealing with thousands of lines of code (which video games usually do), having a line that says &quot;if( option == 1 )&quot; will produce much more headaches than using &quot;if( option == MAIN_MENU )&quot;.</p>
<pre><code>//Starts up SDL and creates window
bool init();

//Loads media
bool loadMedia();

//Frees media and shuts down SDL
void close();

//Loads individual image
SDL_Surface* loadSurface( std::string path );

//The window we&#39;ll be rendering to
SDL_Window* gWindow = NULL;

//The surface contained by the window
SDL_Surface* gScreenSurface = NULL;

//The images that correspond to a keypress
SDL_Surface* gKeyPressSurfaces[ KEY_PRESS_SURFACE_TOTAL ];

//Current displayed image
SDL_Surface* gCurrentSurface = NULL;
</code></pre><p>Along with our usual function prototypes, we have a new function called loadSurface. There&#39;s a general rule that if you&#39;re copy/pasting code, you&#39;re doing something wrong. Rather than copy/paste loading code every time, we&#39;re going to use a function to handle that.</p>
<p>What&#39;s important to this specific program is that we have an array of pointers to SDL surfaces called gKeyPressSurfaces to contain all the images we&#39;ll be using. Depending on which key the user presses, we&#39;ll set gCurrentSurface (which is the image that will be blitted to the screen) to one of these surfaces.</p>
<pre><code>SDL_Surface* loadSurface( std::string path )
{
    //Load image at specified path
    SDL_Surface* loadedSurface = SDL_LoadBMP( path.c_str() );
    if( loadedSurface == NULL )
    {
        printf( &quot;Unable to load image %s! SDL Error: %s\n&quot;, path.c_str(), SDL_GetError() );
    }

    return loadedSurface;
}
</code></pre><p>Here&#39;s the loadSurface function which loads an images and reports an error if something goes wrong. It&#39;s pretty much that same as before, but having the image loading and error reporting contained in one function makes it easy to add to and debug image loading.</p>
<p>And since I get this question a lot by new C++ programmers, no this function does not leak memory. It does allocate memory to load a new SDL surface and return it without freeing the allocated memory, but what would be the point of allocating the surface and immediately deallocating it? What this function does is load the surface and return the newly loaded surface so what ever called this function can deallocate it after it&#39;s done using it. In this program, the loaded surface is deallocated in the close function.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load default surface
    gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ] = loadSurface( &quot;04_key_presses/press.bmp&quot; );
    if( gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ] == NULL )
    {
        printf( &quot;Failed to load default image!\n&quot; );
        success = false;
    }

    //Load up surface
    gKeyPressSurfaces[ KEY_PRESS_SURFACE_UP ] = loadSurface( &quot;04_key_presses/up.bmp&quot; );
    if( gKeyPressSurfaces[ KEY_PRESS_SURFACE_UP ] == NULL )
    {
        printf( &quot;Failed to load up image!\n&quot; );
        success = false;
    }

    //Load down surface
    gKeyPressSurfaces[ KEY_PRESS_SURFACE_DOWN ] = loadSurface( &quot;04_key_presses/down.bmp&quot; );
    if( gKeyPressSurfaces[ KEY_PRESS_SURFACE_DOWN ] == NULL )
    {
        printf( &quot;Failed to load down image!\n&quot; );
        success = false;
    }

    //Load left surface
    gKeyPressSurfaces[ KEY_PRESS_SURFACE_LEFT ] = loadSurface( &quot;04_key_presses/left.bmp&quot; );
    if( gKeyPressSurfaces[ KEY_PRESS_SURFACE_LEFT ] == NULL )
    {
        printf( &quot;Failed to load left image!\n&quot; );
        success = false;
    }

    //Load right surface
    gKeyPressSurfaces[ KEY_PRESS_SURFACE_RIGHT ] = loadSurface( &quot;04_key_presses/right.bmp&quot; );
    if( gKeyPressSurfaces[ KEY_PRESS_SURFACE_RIGHT ] == NULL )
    {
        printf( &quot;Failed to load right image!\n&quot; );
        success = false;
    }

    return success;
}
</code></pre><p>Here in the loadMedia function we load all of the images we&#39;re going to render to the screen.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Set default current surface
            gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ];

            //While application is running
            while( !quit )
            {
</code></pre><p>In the main function before entering the main loop, we set the default surface to display.</p>
<pre><code>                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                    //User presses a key
                    else if( e.type == SDL_KEYDOWN )
                    {
                        //Select surfaces based on key press
                        switch( e.key.keysym.sym )
                        {
                            case SDLK_UP:
                            gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_UP ];
                            break;

                            case SDLK_DOWN:
                            gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_DOWN ];
                            break;

                            case SDLK_LEFT:
                            gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_LEFT ];
                            break;

                            case SDLK_RIGHT:
                            gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_RIGHT ];
                            break;

                            default:
                            gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ];
                            break;
                        }
                    }
                }
</code></pre><p>Here is our event loop. As you can see we handle <a href="#event-driven-programming">closing the window</a> as we did in the previous tutorial, then we handle an SDL_KEYDOWN event. This event happens when ever you press a key on the keyboard.</p>
<p>Inside of the <a href="http://wiki.libsdl.org/SDL_Event?highlight=%28\bCategoryStruct\b%29|%28CategoryEvents%29">SDL Event</a> is an <a href="http://wiki.libsdl.org/SDL_KeyboardEvent">SDL Keyboard event</a> which contains the information for the key event. Inside of that is a <a href="http://wiki.libsdl.org/SDL_Keysym">SDL Keysym</a> which contains the information about the key that was pressed. That Keysym contains the <a href="http://wiki.libsdl.org/SDL_Keycode">SDL Keycode</a> which identifies the key that was pressed.</p>
<p>As you can see, what this code does is set the surfaces based on which key was pressed. Look in the SDL documentation if you want to see what the other keycodes are for other keys.</p>
<pre><code>                //Apply the current image
                SDL_BlitSurface( gCurrentSurface, NULL, gScreenSurface, NULL );

                //Update the surface
                SDL_UpdateWindowSurface( gWindow );
</code></pre><p>After the keys have been handled and the surface has been set we blit the selected surface to the screen.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/04_key_presses/04_key_presses.zip">here</a>.</p>
<h2 id="optimized-surface-loading-and-soft-stretching">Optimized Surface Loading and Soft Stretching</h2>
<p><img src="./res/05_preview.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>Up until now we&#39;ve been blitting our images raw. Since we were only showing one image, it didn&#39;t matter. When you&#39;re making a game, blitting images raw causes needless slow down. We&#39;ll be converting them to an optimized format to speed them up.</p>
<p>SDL 2 also has a new feature for SDL surfaces called soft stretching, which allows you to blit an image scaled to a different size. In this tutorial we&#39;ll take an image half the size of the screen and stretch it to the full size.</p>
<pre><code>SDL_Surface* loadSurface( std::string path )
{
    //The final optimized image
    SDL_Surface* optimizedSurface = NULL;

    //Load image at specified path
    SDL_Surface* loadedSurface = SDL_LoadBMP( path.c_str() );
    if( loadedSurface == NULL )
    {
        printf( &quot;Unable to load image %s! SDL Error: %s\n&quot;, path.c_str(), SDL_GetError() );
    }
</code></pre><p>Back in our image loading function, we&#39;re going to make some modifications so the surface is converted on load. At the top of the function we pretty much <a href="#key-presses">load images like we did in previous tutorials</a>, but we also declare a pointer to the final optimized image.</p>
<pre><code>    else
    {
        //Convert surface to screen format
        optimizedSurface = SDL_ConvertSurface( loadedSurface, gScreenSurface-&gt;format, 0 );
        if( optimizedSurface == NULL )
        {
            printf( &quot;Unable to optimize image %s! SDL Error: %s\n&quot;, path.c_str(), SDL_GetError() );
        }

        //Get rid of old loaded surface
        SDL_FreeSurface( loadedSurface );
    }

    return optimizedSurface;
}
</code></pre><p>If the image loaded successfully in the previous lines of code, we optimize the surface we loaded.</p>
<p>See when you load a bitmap, it&#39;s typically loaded in a 24bit format since most bitmaps are 24bit. Most, if not all, modern displays are not 24bit by default. If we blit an image that&#39;s 24bit onto a 32bit image, SDL will convert it every single time the image is blitted.</p>
<p>So what we&#39;re going to do when an image is loaded is convert it to the same format as the screen so no conversion needs to be done on blit. This can be done easily with <a href="http://wiki.libsdl.org/SDL_ConvertSurface">SDL_ConvertSurface</a>. All we have to do is pass in the surface we want to convert with the format of the screen.</p>
<p>It&#39;s important to note that SDL_ConvertSurface returns a copy of the original in a new format. The original loaded image is still in memory after this call. This means we have to free the original loaded surface or we&#39;ll have two copies of the same image in memory.</p>
<p>After the image is loaded and converted, we return the final optimized image.</p>
<pre><code>                //Apply the image stretched
                SDL_Rect stretchRect;
                stretchRect.x = 0;
                stretchRect.y = 0;
                stretchRect.w = SCREEN_WIDTH;
                stretchRect.h = SCREEN_HEIGHT;
                SDL_BlitScaled( gStretchedSurface, NULL, gScreenSurface, &amp;stretchRect );
</code></pre><p>SDL 2 has a new dedicated function to blit images to a different size: <a href="http://wiki.libsdl.org/SDL_BlitScaled">SDL_BlitScaled</a>. Like <a href="./02_getting_an_image_on_the_screen.md">blitting images</a> before, SDL_BlitScaled takes in a source surface to blit onto the destination surface. It also takes in a destination <a href="http://wiki.libsdl.org/SDL_Rect">SDL_Rect</a> which defines the position and size of the image you are blitting.</p>
<p>So if we want to take an image that&#39;s smaller than the screen and make it the size of the screen, you make the destination width/height to be the width/height of the screen.<br>Download the media and source code for tutorial <a href="http://lazyfoo.net/tutorials/SDL/05_optimized_surface_loading_and_soft_stretching/05_optimized_surface_loading_and_soft_stretching.zip">here</a>.</p>
<h2 id="extension-libraries-and-loading-other-image-formats">Extension Libraries and Loading Other Image Formats</h2>
<p><img src="./res/06_preview.png" alt=""></p>
<p><strong>Last Updated 1/6/19</strong></p>
<p>SDL extension libraries allow you do things like load image files besides BMP, render TTF fonts, and play music. You can set up SDL_image to load PNG files, which can save you a lot of disk space. In this tutorial we&#39;ll be covering how to install SDL_image.<br>SDL itself is an extension library since it adds game and media functionality that doesn&#39;t come standard with your C++ compiler. As you&#39;re setting up your extension library, you&#39;ll realize it&#39;s nearly identical to installing SDL by itself. We&#39;ll be specifically installing SDL_image, but if you can install that extension library you should be able to install any of them.</p>
<p>After you set up SDL_image, we&#39;ll cover <a href="#loading-pngs-with-sdl_image">how to create load a PNG with SDL</a>.</p>
<table>
<thead>
<tr>
<th>Select Your Operating System</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/06_win_logo.jpg" alt=""></td>
<td><a href="#setting-up-sdl-extension-libraries-on-windows">Windows</a></td>
</tr>
<tr>
<td><img src="./res/06_nix_logo.jpg" alt=""></td>
<td><a href="#setting-up-sdl-extension-libraries-on-linux">Linux</a></td>
</tr>
<tr>
<td><img src="./res/06_osx_logo.jpg" alt=""></td>
<td><a href="#setting-up-sdl-extension-libraries-on-mac-os-x-yosemite">Mac OS X</a></td>
</tr>
</tbody>
</table>
<h2 id="loading-pngs-with-sdl_image">Loading PNGs with SDL_image</h2>
<p><img src="./res/06_preview.png" alt=""></p>
<p><strong>Last Updated 6/10/19</strong></p>
<p>Now that the library is all set up, let&#39;s load some PNGs.</p>
<pre><code>//Using SDL, SDL_image, standard IO, and strings
#include &lt;SDL.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
</code></pre><p>To use any SDL_image function or data types, we need to include the SDL_image header. We&#39;d have to do the same for SDL_ttf, or SDL_mixer.</p>
<pre><code>bool init()
{
    //Initialization flag
    bool success = true;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
    else
    {
        //Create window
        gWindow = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );
        if( gWindow == NULL )
        {
            printf( &quot;Window could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
            success = false;
        }
        else
        {
            //Initialize PNG loading
            int imgFlags = IMG_INIT_PNG;
            if( !( IMG_Init( imgFlags ) &amp; imgFlags ) )
            {
                printf( &quot;SDL_image could not initialize! SDL_image Error: %s\n&quot;, IMG_GetError() );
                success = false;
            }
            else
            {
                //Get window surface
                gScreenSurface = SDL_GetWindowSurface( gWindow );
            }
        }
    }

    return success;
}
</code></pre><p>Now that we&#39;re using SDL_image, we need to initialize it. Here we want to initialize SDL_image with PNG loading, so we pass in the PNG loading flags into IMG_Init. IMG_Init returns the flags that loaded successfully. If the flags that are returned do not contain the flags we requested, that means there&#39;s an error.</p>
<p>When there&#39;s an error with SDL_image, you get error string with IMG_GetError as opposed to SDL_GetError.</p>
<p>Also:</p>
<pre><code>STOP E-MAILING ME TELLING ME THAT THAT CALL TO IMG_Init IS A BUG!
STOP E-MAILING ME TELLING ME THAT THAT CALL TO IMG_Init IS A BUG!
STOP E-MAILING ME TELLING ME THAT THAT CALL TO IMG_Init IS A BUG!
STOP E-MAILING ME TELLING ME THAT THAT CALL TO IMG_Init IS A BUG!
STOP E-MAILING ME TELLING ME THAT THAT CALL TO IMG_Init IS A BUG!
</code></pre><p>It&#39;s not. IMG_INIT_PNG is 2. If you init with IMG_INIT_PNG and get back IMG_INIT_PNG you get 2 &amp; 2 which is 2. 2 will evaluate to true, the ! will negate it which means it will evaluate to false which will cause the SDL_GetWindowSurface line to execute.</p>
<p>If you were to get back 4 back from IMG_Init when you wanted 2, 4 &amp; 2 is 0, which evaluates to false, which is negated by the ! to evaluate to true which will cause the error printing code to execute.</p>
<p>If you were to get back 6 back from IMG_Init (both the 4 and 2 bit) when you wanted 2, 6 &amp; 2 is 2, which evaluates to true, which is negated by the ! to evaluate to false which will cause SDL_GetWindowSurface line to execute.</p>
<p>The reason the code is like that is because we only care about the PNG loading bit. If we get that, that means we can continue. In other cases this code would be different, but we&#39;re not dealing with that here.</p>
<p>So make sure to brush up on your binary math and <strong>STOP E-MAILING ME TELLING ME THAT THAT CALL TO IMG_Init IS A BUG!</strong>. Seriously it&#39;s like 25% of the bug reports I get.</p>
<pre><code>SDL_Surface* loadSurface( std::string path )
{
    //The final optimized image
    SDL_Surface* optimizedSurface = NULL;

    //Load image at specified path
    SDL_Surface* loadedSurface = IMG_Load( path.c_str() );
    if( loadedSurface == NULL )
    {
        printf( &quot;Unable to load image %s! SDL_image Error: %s\n&quot;, path.c_str(), IMG_GetError() );
    }
    else
    {
        //Convert surface to screen format
        optimizedSurface = SDL_ConvertSurface( loadedSurface, gScreenSurface-&gt;format, 0 );
        if( optimizedSurface == NULL )
        {
            printf( &quot;Unable to optimize image %s! SDL Error: %s\n&quot;, path.c_str(), SDL_GetError() );
        }

        //Get rid of old loaded surface
        SDL_FreeSurface( loadedSurface );
    }

    return optimizedSurface;
}
</code></pre><p>Our image loading function is pretty much the same as before, only now it uses IMG_Load as opposed to SDL_LoadBMP. IMG_Load can load many different types of format which you can find out about in the <a href="http://www.libsdl.org/projects/SDL_image/">SDL_image documentation</a>. Like with IMG_Init, when there&#39;s an error with IMG_Load, we call IMG_GetError to get the error string.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/06_extension_libraries_and_loading_other_image_formats/06_extension_libraries_and_loading_other_image_formats.zip">here</a>.</p>
<h2 id="setting-up-sdl-extension-libraries-on-windows">Setting up SDL Extension Libraries on Windows</h2>
<p><strong>Last Updated 1/06/19</strong></p>
<p><strong>An important note for Microsoft Windows developers:</strong></p>
<p>As part of your set up process, you are going to have to place the dll files some place where your program can link with it during runtime. You can either put the dll file in the same directory as your executable, or put it in the system directory. C:\WINDOWS\SYSTEM32 is the 32bit windows system directory and C:\Windows\SysWOW64 is the 64bit system directory of 32bit applications.</p>
<p>The advantages of placing the dll file in the system directory are:</p>
<ol>
<li>Your operating system will always be able to find the library on your system, so you can compile and run dynamically linked applications anywhere on your system</li><li>You won&#39;t have to place a copy of the dll file with every single application you develop<br>With that in mind, when distributing your application you should never mess with the user&#39;s system directory. The user could have applications that require SDL version ABC in the system directory and you could be overwriting it with SDL version XYZ. Your distribution version should have the dll files in the same directory as the executable.</li></ol>
<p>Also, if you are getting <strong>Procedure Entry Point could not be located in the dynamic link library</strong> errors, it could mean that that you have conflicting versions of the dll. Go into the windows command line, and use the &quot;where&quot; command by typing <strong>where *name of dll file*</strong>. The first file is the first dll windows finds and the one it uses when a program that needs that dll. You can then replace the old version with the new one SDL_image uses.</p>
<table>
<thead>
<tr>
<th>Select Your IDE/Compiler</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/06_win_codeblock.png" alt=""></td>
<td><a href="#setting-up-sdl-extension-libraries-on-code::blocks-12.11">Code::Blocks 12.11</a></td>
</tr>
<tr>
<td><img src="./res/06_win_vs_logo.png" alt=""></td>
<td><a href="#setting-up-sdl-extension-libraries-on-visual-studio-2010-ultimate">Visual Studio.NET 2010 Ultimate</a></td>
</tr>
<tr>
<td><img src="./res/06_win_mingw_logo.png" alt=""></td>
<td><a href="#setting-up-sdl-extension-libraries-on-mingw">Command Line (MinGW)</a></td>
</tr>
</tbody>
</table>
<h2 id="setting-up-sdl-extension-libraries-on-code-blocks-12-11">Setting up SDL Extension Libraries on Code::Blocks 12.11</h2>
<p><strong>Last Updated 11/18/13</strong></p>
<ol>
<li><p>First thing you need to do is download SDL_image headers and binaries. You will find them on the SDL_image website, specifically on <a href="http://www.libsdl.org/projects/SDL_image/">this page</a>.</p>
<p> Since Code::Blocks comes with the MinGW compiler by default, odds are you&#39;ll want to download the MinGW development libraries.<br> <img src="./res/06_win_mingw_package.png" alt=""><br> Open the gzip archive and there should be a tar archive. Open up the tar archive and the should be a folder called SDL2_image-2.something.something. In side of that folder there should be a bunch of folders and files, most importantly <strong>i686-w64-mingw32</strong> which contains the 32bit library and <strong>x86_64-w64-mingw32</strong> which contains the 64bit library.</p>
</li><li><p><strong>This is important</strong>: most compilers still compile 32bit binaries by default to maximize compatibility. We will be using the 32bit binaries for this tutorial set. It doesn&#39;t matter if you have a 64bit operating system, since we are compiling 32bit binaries we will be using the 32bit library.</p>
<p> Inside of i686-w64-mingw32 are the include, lib, and bin folders which contain everything we need compile and run SDL applications. Copy the contents of i686-w64-mingw32 to any directory you want. I recommend putting it in a folder that you dedicate to holding all your development libraries for MinGW. For these tutorials I&#39;m putting it in a directory I created C:\mingw_dev_lib</p>
</li><li><p>Open up your SDL 2 project and go to project properties.<br> <img src="./res/06_win_project_properties.png" alt=""></p>
</li><li><p>Now we have to tell Code::Blocks to search for header files in the library folder we just extracted. Go to build options.<br> <img src="./res/06_win_build_options.png" alt=""></p>
<p> In the Search Directories, we need to add a new compiler directory. Click add, Select the SDL_image folder inside of the include directory from the folder we extracted. Say no when it asks you whether you want it to be a relative path. Now Code::Blocks knows where to find the SDL_image header files.<br> <img src="./res/06_win_search_directories.png" alt=""></p>
<p> If you get an error where the compiler says it can&#39;t find SDL.h, it means you messed up this step.</p>
<p> You may have noticed that the folder added here is the same as the one for the SDL 2 main set up. Personally, I like keeping the SDL_image, SDL_ttf, and SDL_mixer headers and libraries in the same directories. Other people like to keep them separate. If you put the extension libary headers in the same directories as SDL 2, you can skip this step since you already told the compiler to look in that directory. If you put them somewhere else, you have to do this step so your compiler will look for the extension library headers in the right directory.</p>
</li><li><p>Next we are going to tell Code::Blocks to search for library files in the SDL folder we just extracted. All you have to is go to the linker tab and add the lib directory from the folder we extacted to the linker search directories.<br> <img src="./res/06_win_linker_directory.png" alt=""></p>
<p> If you get an error where the linker complains it can&#39;t find -lSDL2_image (or -lSDL2_ttf/-lSDL2_mixer), it means you messed up this step.</p>
<p> As with before, if you put the library files for the extension library in the same directory as SDL 2, you can skip this step since the compiler is already looking in that directory.</p>
</li><li><p>In order to compile SDL 2 code, we have to tell the compiler to link against the libraries. Go under Linker Settings and paste</p>
<pre><code>-lSDL2_image
</code></pre><p>into the other linker options field after -lmingw32 -lSDL2main -lSDL2 and click OK. If you were setting up SDL_ttf, you&#39;d put <code>-lSDL2_ttf</code> and you&#39;d put <code>-lSDL2_mixer</code> for SDL_mixer.<br> <img src="./res/06_win_linker.png" alt=""></p>
<p> If you get an error where the linker complains about a bunch of undefined references, it means you messed up this step.</p>
</li><li><p>Like with plain SDL, the operating system needs to be able to find the dll files for the extension library while running.</p>
<p> Go find the SDL 2 folder you extracted and from the bin folder inside copy the dll files (all of them if there&#39;s more than one) and put it either where your executable will run, or inside of the system directory. C:\WINDOWS\SYSTEM32 is the 32bit windows system directory and C:\Windows\SysWOW64 is the 64bit system directory of 32bit applications. For these tutorials, I&#39;m assuming we&#39;re making 32bit applications. If you get an error when you run the program where it complains that it can&#39;t find dll files, it means you messed up this step.</p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/06_extension_libraries_and_loading_other_image_formats/06_extension_libraries_and_loading_other_image_formats.zip">source for lesson 06</a>. Add the source file inside to your project.</p>
<p> Now build. If there are any errors, make sure you didn&#39;t skip a step.</p>
<p> Now that you have the extension library compiling, it&#39;s time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-extension-libraries-on-visual-studio-2010-ultimate">Setting up SDL Extension Libraries on Visual Studio 2010 Ultimate</h2>
<p><strong>Last Updated 7/13/14</strong></p>
<ol>
<li><p>First thing you need to do is download SDL_image headers and binaries. You will find them on the SDL_image website, specifically on <a href="http://www.libsdl.org/projects/SDL_image/">this page</a>.</p>
<p> You&#39;ll want to download the visual c++ development libraries.<br> <img src="./res/06_msvc_package.png" alt=""></p>
</li><li><p>Open the zip archive and there should be a folder that contains folders called include and another one called lib. Copy the contents of the folder and put them where you want. I recommend putting them in the same directory where you put your SDL install. For these tutorials I&#39;m putting them in a directory I created called C:\vs_dev_lib<br> <img src="./res/06_project_properties.png" alt=""></p>
</li><li><p>Open your SDL project and go to project properties.</p>
</li><li><p>Now we have to tell Visual C++ to search for header files in the SDL extension include folder we just extracted. Under Configuration Properties in the VC++ Directories menu, select the Include Directories field, click the tiny down arrow button, and click edit.<br> <img src="./res/06_include_directories.png" alt=""></p>
</li><li><p>Click the folder icon, and then click the button that pops up.<br> <img src="./res/06_add_include.png" alt=""></p>
</li><li><p>Now go find the SDL_image (or SDL_ttf/SDL_mixer) folders you extracted, and select the include folder and click OK.<br> <img src="./res/06_new_include.png" alt=""></p>
<p> Now Visual Studio knows where to find the header files. If you get an error that the compiler can&#39;t find SDL_image.h (or SDL_ttf.h/SDL_mixer.h), it means you messed up this step.</p>
<p> You may have noticed that the directory added here is the same from the setting up SDL tutorial. This is because I over wrote the include directory so it has both the headers from SDL 2 and SDL_image/SDL_ttf/SDL_mixer headers are in the same directory. If you did this you can skip this step because our project already knew where to find the header files. Some prefer keep their SDL and SDL extension libaries in different directories, some prefer them in the same directory. Your choice.</p>
</li><li><p>Next we&#39;re going to tell Visual C++ to search for library files in the SDL_image/SDL_ttf/SDL_mixer library folder we just extracted. Select the Library Directories field, click the tiny down arrow button, and click edit.<br> <img src="./res/06_library_directories.png" alt=""></p>
</li><li><p>Click the folder icon, and then click the button that pops up.<br> <img src="./res/06_add_library.png" alt=""></p>
</li><li><p>)Now go find the lib folder you extracted, and select the lib folder where you find two folders. There&#39;s one for 32bit x86 architecture and for 64bit x64 architecture.<br> <img src="./res/06_select_library.png" alt=""></p>
<p> This is important: most compilers still compile 32bit binaries by default to maximize compatibility. We will be using the 32bit binaries for this tutorial set. It doesn&#39;t matter if you have a 64bit operating system, since we are compiling 32bit binaries we will be using the 32bit library. This means you need to select the x86 folder and click ok. Now Visual Studio knows where to find the library files. If you get an error how the linker can&#39;t find SDL2_image.lib/SDL2_ttf.lib/SDL2_mixer.lib, it means you missed this step.</p>
<p> Like before, you might notice that the lib directory is the same from tutorial 01. Again, this is because I personally like to put the library files for SDL, SDL_image, SDL_ttf, and SDL_mixer in the same directory. If you do this you can skip this step since visual studio is already looking for library files there. For you people you put them in a separate directory, you need to tell visual studio where to find the lib files.</p>
</li><li><p>In order to compile SDL code, we have to tell the Visual C++ to link against the libraries. Go under Linker in the Input menu, edit the additional dependencies.<br><img src="./res/06_additional_dependencies.png" alt=""></p>
</li><li><p>Now paste</p>
<pre><code>SDL2_image.lib;
</code></pre><p>into the Additional dependencies field and click OK.<br><img src="./res/06_vs_linker.png" alt=""></p>
<p>If you were linking SDL_ttf, you&#39;d put SDL2_ttf.lib. If you were linking SDL2_mixer, you&#39;d put SDL2_mixer.lib.</p>
<p>Now Visual Studio knows to link against the extension library. If you get a bunch of undefined reference error after compiling, it means you messed up this step.</p>
</li><li><p>Like with plain SDL, the operating system needs to be able to find the dll files for the extension library while running.</p>
<p>Go find the lib folder you extracted from the extension library and copy <strong>all</strong> of the dll files and put them either your project&#39;s working directory (where the vcxproj file is at), or inside of the system directory. C:\WINDOWS\SYSTEM32 is the 32bit windows system directory and C:\Windows\SysWOW64 is the 64bit system directory of 32bit applications. For these tutorials, I&#39;m assuming we&#39;re making 32bit applications.</p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/06_extension_libraries_and_loading_other_image_formats/06_extension_libraries_and_loading_other_image_formats.zip">source for lesson 06</a>. Add the source file inside to your project.</p>
</li></ol>
<p>Now build. If there are any errors, make sure you didn&#39;t skip a step.</p>
<p>Now that you have the extension library compiling, it&#39;s time to go onto part 2 of the tutorial.</p>
<h2 id="setting-up-sdl-extension-libraries-on-mingw">Setting up SDL Extension Libraries on MinGW</h2>
<p><strong>Last Updated 6/21/14</strong></p>
<ol>
<li><p>First thing you need to do is download SDL_image headers and binaries. You will find them on the SDL_image website, specifically on <a href="http://www.libsdl.org/projects/SDL_image/">this page</a>.</p>
<p> You&#39;ll want to download the MinGW development libraries.<br> <img src="./res/06_win_mingw_package2.png" alt=""></p>
<p> Open the gzip archive and there should be a tar archive. Open up the tar archive and the should be a folder called SDL2_image-2.something.something. In side of that folder there should be a bunch of folders and files, most importantly <strong>i686-w64-mingw32</strong> which contains the 32bit library and <strong>x86_64-w64-mingw32</strong> which contains the 64bit library.</p>
</li><li><p><strong>This is important</strong>: most compilers still compile 32bit binaries by default to maximize compatibility. We will be using the 32bit binaries for this tutorial set. It doesn&#39;t matter if you have a 64bit operating system, since we are compiling 32bit binaries we will be using the 32bit library.</p>
<p> Inside of i686-w64-mingw32 are the include, lib, and bin folders which contain everything we need compile and run SDL applications. Copy the contents of i686-w64-mingw32 to any directory you want. I recommend putting it in a folder that you dedicate to holding all your development libraries for MinGW. For these tutorials I&#39;m putting it in a directory I created C:\mingw_dev_lib</p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/06_extension_libraries_and_loading_other_image_formats/06_extension_libraries_and_loading_other_image_formats.zip">source for lesson 06</a>. Extract the source somewhere and compile by entering this big old command (This command assumed you have SDL_image extracted at C:\mingw_dev_lib):</p>
<pre><code> g++ 06_extension_libraries_and_loading_other_image_formats.cpp -IC:\mingw_dev_lib\include\SDL2 -LC:\mingw_dev_lib\lib -w -Wl,-subsystem,windows -lmingw32 -lSDL2main -lSDL2 -lSDL2_image -o 06_extension_libraries_and_loading_other_image_formats
</code></pre><p> If you&#39;re using a makefile, you can just change the values of some of the macros:</p>
<p> From Makefile</p>
<pre><code> #OBJS specifies which files to compile as part of the project
 OBJS = 06_extension_libraries_and_loading_other_image_formats.cpp

 #CC specifies which compiler we&#39;re using
 CC = g++

 #INCLUDE_PATHS specifies the additional include paths we&#39;ll need
 INCLUDE_PATHS = -IC:\mingw_dev_lib\include\SDL2

 #LIBRARY_PATHS specifies the additional library paths we&#39;ll need
 LIBRARY_PATHS = -LC:\mingw_dev_lib\lib

 #COMPILER_FLAGS specifies the additional compilation options we&#39;re using
 # -w suppresses all warnings
 # -Wl,-subsystem,windows gets rid of the console window
 COMPILER_FLAGS = -w -Wl,-subsystem,windows

 #LINKER_FLAGS specifies the libraries we&#39;re linking against
 LINKER_FLAGS = -lmingw32 -lSDL2main -lSDL2 -lSDL2_image

 #OBJ_NAME specifies the name of our exectuable
 OBJ_NAME = 06_extension_libraries_and_loading_other_image_formats

 #This is the target that compiles our executable
 all : $(OBJS)
     $(CC) $(OBJS) $(INCLUDE_PATHS) $(LIBRARY_PATHS) $(COMPILER_FLAGS) $(LINKER_FLAGS) -o $(OBJ_NAME)
</code></pre><p> As you can see it was as easy as changing the file name of the source and executable and adding</p>
<pre><code> -lSDL2_image
</code></pre><p> to the linker. If we were linking SDL_ttf, we&#39;d add</p>
<pre><code> -lSDL2_ttf
</code></pre><p> and for SDL_mixer we&#39;d put:</p>
<pre><code> -lSDL2_mixer
</code></pre><p> Now that you have the extension library compiling, it&#39;s time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-extension-libraries-on-linux">Setting up SDL Extension Libraries on Linux</h2>
<p><strong>Last Updated 2/2/15</strong></p>
<p>Since there are so many flavors of Linux these tutorials might not work on your Linux set up. If you&#39;ve tried everything and are still having problems, <a href="http://lazyfoo.net/contact.php">contact me</a> and I&#39;ll try to add on a distro specific fix.<br>In the age of packaging managers, a lot of the work is done for you when installing libraries. You&#39;ll need root privileges to install packages so make sure to use &quot;su&quot; or &quot;sudo&quot; if you&#39;re not logged in as root.</p>
<p>Make sure you have updated to the latest version of your distro because your older package manager may not support the latest version of SDL_image/SDL_ttf/SDL_mixer.</p>
<ol>
<li><p>For those of you who have Advanced Packaging Tool available (ie Ubuntu and Debian) you&#39;ll want to search the apt-get cache to find the current SDL_image version to install. You can search the apt-get available packages using the command:</p>
<pre><code> apt-cache search libsdl2-image
</code></pre><p> You&#39;ll want to download the development version of SDL_image. As of the last update of this tutorial, the development package of SDL_image is <code>libsdl2-image-dev</code>. You can install this package using the command</p>
<pre><code> apt-get install libsdl2-image-dev
</code></pre><p> For SDL_ttf, the development package name is libsdl2-ttf-dev. For SDL_mixer it&#39;s libsdl2-mixer-dev.</p>
</li><li><p>If you use the Yellow dog Updater, Modified (used in Fedora and CentOS) you can enter the command:</p>
<pre><code> yum search SDL2_image-devel
</code></pre><p> To search for the SDL_image developers package. As of the last update of this tutorial, the developer package for SDL 2 is SDL2_image-devel. You can install this package using the command:</p>
<pre><code> yum install SDL2_image-devel
</code></pre><p> For SDL_ttf, the development package name is <code>SDL2_ttf-devel</code>. For SDL_mixer it&#39;s <code>SDL2_mixer-devel</code>.</p>
</li><li><p>If somehow you don&#39;t have a package manager, you can install from the source the classic Unix way. Download the latest source from the <a href="http://www.libsdl.org/projects/SDL_image/#source">SDL_image website</a>.</p>
<p> Extract the archive and cd to the folder that got extracted. Configure the installation using</p>
<pre><code> ./configure
</code></pre><p> Compile the source using the make command</p>
<pre><code> make all
</code></pre><p> Finally, install the package using the make command</p>
<pre><code> make install
</code></pre></li></ol>
<p>4) Now that you&#39;ve installed the development libraries, it&#39;s time to start up your IDE/compiler.<em>**</em></p>
<table>
<thead>
<tr>
<th>Select Your IDE/Compiler</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/06_nix_commandline_logo.jpg" alt=""></td>
<td><a href="#setting-up-sdl-extension-libraries-on-g++">Command Line</a></td>
</tr>
<tr>
<td><img src="./res/06_nix_codeblock.png" alt=""></td>
<td><a href="#setting-up-sdl-extension-libraries-on-code::blocks-13.12">Code::Blocks</a></td>
</tr>
</tbody>
</table>
<h2 id="setting-up-sdl-extension-libraries-on-g-">Setting up SDL Extension Libraries on g++</h2>
<p><strong>Last Updated 6/21/14</strong></p>
<ol>
<li><p>Go download the <a href="http://lazyfoo.net/tutorials/SDL/06_extension_libraries_and_loading_other_image_formats/06_extension_libraries_and_loading_other_image_formats.zip">source for lesson 06</a>. Extract the source somewhere. Now compile by entering this command:</p>
<pre><code> g++ 06_extension_libraries_and_loading_other_image_formats.cpp -w -lSDL2 -lSDL2_image -o 06_extension_libraries_and_loading_other_image_formats
</code></pre><p> Now you may get an error saying it can&#39;t find SDL_image.h. For linux, we&#39;ll have to include the SDL headers like this:</p>
<pre><code> #include&lt;SDL2/SDL_image.h&gt;
</code></pre><p> For SDL_ttf and SDL_mixer, we have to include them like this:</p>
<pre><code> #include&lt;SDL2/SDL_ttf.h&gt;
 #include&lt;SDL2/SDL_mixer.h&gt;
</code></pre><p> If you&#39;re using a makefile, you can just change the values of some of the macros:</p>
<p> From Makefile</p>
<pre><code> #OBJS specifies which files to compile as part of the project
 OBJS = 06_extension_libraries_and_loading_other_image_formats.cpp

 #CC specifies which compiler we&#39;re using
 CC = g++

 #COMPILER_FLAGS specifies the additional compilation options we&#39;re using
 # -w suppresses all warnings
 COMPILER_FLAGS = -w

 #LINKER_FLAGS specifies the libraries we&#39;re linking against
 LINKER_FLAGS = -lSDL2 -lSDL2_image

 #OBJ_NAME specifies the name of our exectuable
 OBJ_NAME = 06_extension_libraries_and_loading_other_image_formats

 #This is the target that compiles our executable
 all : $(OBJS)
     $(CC) $(OBJS) $(COMPILER_FLAGS) $(LINKER_FLAGS) -o $(OBJ_NAME)
</code></pre><p> As you can see it was as easy as changing the file name of the source and executable and adding</p>
<pre><code> -lSDL2_image
</code></pre><p> to the linker. If we were linking SDL_ttf, we&#39;d add</p>
<pre><code> -lSDL2_ttf
</code></pre><p> and for SDL_mixer we&#39;d put:</p>
<pre><code> -lSDL2_mixer
</code></pre><p>Now that you have the extension library compiling, it&#39;s time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-extension-libraries-on-code-blocks-13-12">Setting up SDL Extension Libraries on Code::Blocks 13.12</h2>
<p><strong>Last Updated 2/2/15</strong></p>
<ol>
<li><p>Open up your SDL 2 project and go to project properties.<br> <img src="./res/06_nix_project_properties.png" alt=""></p>
</li><li><p>In order to compile SDL 2 code, we have to tell the compiler to link against the libraries. Go under Linker Settings and paste</p>
<pre><code> -lSDL2_image
</code></pre><p> into the other linker options field after -lSDL2 and click OK. If you were setting up SDL_ttf, you&#39;d put <code>-lSDL2_ttf</code> and you&#39;d put <code>-lSDL2_mixer</code> for SDL_mixer.<br> <img src="./res/06_nix_linker.png" alt=""></p>
<p> If you get an error where the linker complains about a bunch of undefined references, it means you messed up this step.</p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/06_extension_libraries_and_loading_other_image_formats/06_extension_libraries_and_loading_other_image_formats.zip">source for lesson 06</a>. Add the source file inside to your project.</p>
<p> Now build. Now you may get an error saying it can&#39;t find SDL_image.h. For linux, we&#39;ll have to include the SDL headers like this:</p>
<pre><code> #include&lt;SDL2/SDL_image.h&gt;
</code></pre><p> For SDL_ttf and SDL_mixer, we have to include them like this:</p>
<pre><code> #include&lt;SDL2/SDL_ttf.h&gt;
 #include&lt;SDL2/SDL_mixer.h&gt;
</code></pre><p> Now that you have the extension library compiling, it&#39;s time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-extension-libraries-on-mac-os-x-yosemite">Setting up SDL Extension Libraries on Mac OS X Yosemite</h2>
<p><strong>Last Updated 1/12/15</strong></p>
<p>Whether you&#39;re setting up SDL_image, SDL_ttf, or SDL_mixer, setting up an SDL extension library isn&#39;t all that different from setting up SDL itself. If you can set one of them up, you can set any of them up.</p>
<ol>
<li><p>First thing you need to do is download SDL_image headers and binaries. You will find them on the SDL_image website, specifically on <a href="http://www.libsdl.org/projects/SDL_image/">this page</a>.<br> <img src="./res/06_osx_download.png" alt=""></p>
</li><li><p>Next open the dmg and copy the SDL2_image.framework to /Library/Frameworks. To go directly to a path in finder, press command+shift+g.<br> <img src="./res/06_osx_copy_framework.png" alt=""></p>
</li><li><p>The framework may need to be resigned. To sign the framework, open up a terminal to:</p>
<pre><code> /Library/Frameworks/SDL2_image.framework/
</code></pre><p> and sign the framework using the command:</p>
<pre><code> codesign -f -s - SDL2_image
</code></pre><p> If you were resigning SDL_ttf, you&#39;d open up a terminal to:</p>
<pre><code> /Library/Frameworks/SDL2_ttf.framework/
</code></pre><p> and sign SDL_ttf using the command:</p>
<pre><code> codesign -f -s - SDL2_ttf
</code></pre><p> If you were resigning SDL_mixer, you&#39;d open up a terminal to:</p>
<pre><code> /Library/Frameworks/SDL2_mixer.framework/
</code></pre><p> and sign SDL_mixer using the command:</p>
<pre><code> codesign -f -s - SDL2_mixer
</code></pre></li><li><p>Now that you&#39;ve installed the development libraries, it&#39;s time to start up your IDE/compiler.</p>
</li></ol>
<table>
<thead>
<tr>
<th>Select Your IDE/Compiler</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/06_osx_xcode.jpg" alt=""></td>
<td><a href="#setting-up-sdl-extension-libraries-on-xcode-6.1">XCode 6.1</a></td>
</tr>
</tbody>
</table>
<h2 id="setting-up-sdl-extension-libraries-on-xcode-6-1">Setting up SDL Extension Libraries on XCode 6.1</h2>
<p><strong>Last Updated 1/12/15</strong></p>
<ol>
<li><p>Open up your SDL project and go to the Link Binary with Libraries section and click the plus:<br> <img src="./res/06_build_phases.png" alt=""></p>
<p> To add the SDL_image framework, click Add Other and go to /Library/Frameworks/ using command+shift+g to select the SDL_image framework and hit open.<br> <img src="./res/06_add_other.png" alt=""></p>
</li><li><p>Now go download the <a href="http://lazyfoo.net/tutorials/SDL/06_extension_libraries_and_loading_other_image_formats/06_extension_libraries_and_loading_other_image_formats.zip">source for lesson 06</a>. Add the source files inside to your project.</p>
<p> By default in the tutorials, the SDL headers are included like this:</p>
<pre><code> #include &lt;SDL/SDL_image.h&gt;
</code></pre><p> SDL on Mac OS X does things differently, so we have to include the SDL_image header like this:</p>
<pre><code> #include &lt;SDL2_image/SDL_image.h&gt;
</code></pre><p> For SDL_tff, we include the header like this:</p>
<pre><code> #include &lt;SDL2_ttf/SDL_ttf.h&gt;
</code></pre><p> For SDL_mixer, we include the header like this:</p>
<pre><code> #include &lt;SDL2_mixer/SDL_mixer.h&gt;
</code></pre><p> Now build. If there are any errors, make sure you didn&#39;t skip a step.</p>
</li></ol>
<h2 id="texture-loading-and-rendering">Texture Loading and Rendering</h2>
<p><img src="./res/07_preview.png" alt=""></p>
<p><strong>Last Updated 7/13/14</strong></p>
<p>A major new addition to SDL 2 is the texture rendering API. This gives you fast, flexible hardware based rendering. In this tutorial we&#39;ll be using this new rendering technique.</p>
<pre><code>//Loads individual image as texture
SDL_Texture* loadTexture( std::string path );

//The window we&#39;ll be rendering to
SDL_Window* gWindow = NULL;

//The window renderer
SDL_Renderer* gRenderer = NULL;

//Current displayed texture
SDL_Texture* gTexture = NULL;
</code></pre><p>Textures in SDL have their own data type intuitively called a <a href="http://wiki.libsdl.org/SDL_Texture">SDL_Texture</a>. When we deal with SDL textures you need an SDL_Renderer to render it to the screen which is why we declare a global renderer named &quot;gRenderer&quot;.</p>
<p>As you can also see we have a new image loading routine with loadTexture and a globally declared texture we&#39;re going to load.</p>
<pre><code>        //Create window
        gWindow = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );
        if( gWindow == NULL )
        {
            printf( &quot;Window could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
            success = false;
        }
        else
        {
            //Create renderer for window
            gRenderer = SDL_CreateRenderer( gWindow, -1, SDL_RENDERER_ACCELERATED );
            if( gRenderer == NULL )
            {
                printf( &quot;Renderer could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
                success = false;
            }
            else
            {
                //Initialize renderer color
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );

                //Initialize PNG loading
                int imgFlags = IMG_INIT_PNG;
                if( !( IMG_Init( imgFlags ) &amp; imgFlags ) )
                {
                    printf( &quot;SDL_image could not initialize! SDL_image Error: %s\n&quot;, IMG_GetError() );
                    success = false;
                }
            }
        }
</code></pre><p>After we create our window, we have to create a renderer for our window so we can render textures on it. Fortunately this is easily done with a call to <a href="http://wiki.libsdl.org/SDL_CreateRenderer">SDL_CreateRenderer</a>.</p>
<p>After creating the renderer, we want to initialize the rendering color using <a href="http://wiki.libsdl.org/SDL_SetRenderDrawColor">SDL_SetRenderDrawColor</a>. This controls what color is used for various rendering operations.</p>
<pre><code>SDL_Texture* loadTexture( std::string path )
{
    //The final texture
    SDL_Texture* newTexture = NULL;

    //Load image at specified path
    SDL_Surface* loadedSurface = IMG_Load( path.c_str() );
    if( loadedSurface == NULL )
    {
        printf( &quot;Unable to load image %s! SDL_image Error: %s\n&quot;, path.c_str(), IMG_GetError() );
    }
    else
    {
        //Create texture from surface pixels
        newTexture = SDL_CreateTextureFromSurface( gRenderer, loadedSurface );
        if( newTexture == NULL )
        {
            printf( &quot;Unable to create texture from %s! SDL Error: %s\n&quot;, path.c_str(), SDL_GetError() );
        }

        //Get rid of old loaded surface
        SDL_FreeSurface( loadedSurface );
    }

    return newTexture;
}
</code></pre><p>Our texture loading function looks largely the same as before only now instead of converting the loaded surface to the display format, we create a texture from the loaded surface using <a href="http://wiki.libsdl.org/SDL_CreateTextureFromSurface">SDL_CreateTextureFromSurface</a>. Like before, this function creates a new texture from an existing surface which means like before we have to free the loaded surface and then return the loaded texture.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load PNG texture
    gTexture = loadTexture( &quot;07_texture_loading_and_rendering/texture.png&quot; );
    if( gTexture == NULL )
    {
        printf( &quot;Failed to load texture image!\n&quot; );
        success = false;
    }

    return success;
}

void close()
{
    //Free loaded image
    SDL_DestroyTexture( gTexture );
    gTexture = NULL;

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>Since texture loading is abstracted with our image loading function, the loadMedia() function works pretty much the same as before.</p>
<p>In our clean up function, we have to remember to deallocate our textures using <a href="http://wiki.libsdl.org/SDL_DestroyTexture">SDL_DestroyTexture</a>.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_RenderClear( gRenderer );

                //Render texture to screen
                SDL_RenderCopy( gRenderer, gTexture, NULL, NULL );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>In the <a href="http://lazyfoo.net/tutorials/SDL/03_event_driven_programming/index.php">main loop</a> after the event loop, we call <a href="http://wiki.libsdl.org/SDL_RenderClear">SDL_RenderClear</a>. This function fills the screen with the color that was last set with SDL_SetRenderDrawColor.</p>
<p>With the screen cleared, we render the texture with <a href="http://wiki.libsdl.org/SDL_RenderCopy">SDL_RenderCopy</a>. With the texture rendered, we still have to update the screen, but since we&#39;re not using SDL_Surfaces to render we can&#39;t use SDL_UpdateWindowSurface. Instead we have to use <a href="http://wiki.libsdl.org/SDL_RenderPresent">SDL_RenderPresent</a>.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/07_texture_loading_and_rendering/07_texture_loading_and_rendering.zip">here</a>.</p>
<h2 id="geometry-rendering">Geometry Rendering</h2>
<p><img src="./res/08_preview.png" alt=""></p>
<p><strong>Last Updated 1/07/18</strong></p>
<p>Along with the new texturing API, SDL has new primitive rendering calls as part of its <a href="http://wiki.libsdl.org/CategoryRender">rendering API</a>. So if you need some basic shapes rendered and you don&#39;t want to create additional graphics for them, SDL can save you the effort.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Nothing to load
    return success;
}
</code></pre><p>So as you can see in our media loading function, we load no media. SDL&#39;s primitive rendering allows you to render shapes without loading special graphics.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );
</code></pre><p>At the top of the main loop we handle the quit event like before and clear the screen. Also notice that we&#39;re setting the clearing color to white with SDL_SetRenderDrawColor every frame as opposed to setting it once in the initialization function. We&#39;ll cover why this happens when we get to the end of the main loop.</p>
<pre><code>                //Render red filled quad
                SDL_Rect fillRect = { SCREEN_WIDTH / 4, SCREEN_HEIGHT / 4, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 };
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0x00, 0x00, 0xFF );        
                SDL_RenderFillRect( gRenderer, &amp;fillRect );
</code></pre><p>The first primitive we&#39;re going to draw is a fill rectangle, which is a solid rectangle.</p>
<p>First we define a rectangle to define the area we want to fill with color. If you never seen a struct initialized like this, know that the member variables that make up an SDL rect are x, y, w, and h for the x position, y position, width, and height respectively. You can initialize a struct by giving it an array of variables in the order they are in the struct. Here we&#39;re setting the rectangle one quarter of the screen width in the x direction, one quarter of the screen height in the y direction, and with half the screen&#39;s width/height.</p>
<p>After defining the rectangle area, we set the rendering color with SDL_SetRenderDrawColor. This function takes in the renderer for the window we&#39;re using and the RGBA values for the color we want to render with. R is the red component, G is green, B is blue, and A is alpha. Alpha controls how opaque something is and we&#39;ll cover that in the transparency tutorial. These values go from 0 to 255 (or FF hex as you see above) and are mixed together to create all the colors you see on your screen. This call to SDL_SetRenderDrawColor sets the drawing color to opaque red.</p>
<p>After the rectangle and color have been set, <a href="http://wiki.libsdl.org/SDL_RenderFillRect">SDL_RenderFillRect</a> is called to draw the rectangle.</p>
<pre><code>                //Render green outlined quad
                SDL_Rect outlineRect = { SCREEN_WIDTH / 6, SCREEN_HEIGHT / 6, SCREEN_WIDTH * 2 / 3, SCREEN_HEIGHT * 2 / 3 };
                SDL_SetRenderDrawColor( gRenderer, 0x00, 0xFF, 0x00, 0xFF );        
                SDL_RenderDrawRect( gRenderer, &amp;outlineRect );
</code></pre><p>You can also draw a rectangle outline with an empty center using <a href="http://wiki.libsdl.org/SDL_RenderDrawRect">SDL_RenderDrawRect</a>. As you can see it pretty much works the same as a solid filled rectangle as this piece of code is almost the same as the one above it. The major difference is that this rectangle is 2 thirds of the screen in size and that the color we&#39;re using here is green.</p>
<p>Also if you mess with the position of the rectangle, you may notice something strange about the y coordinate. Making the y coordinate larger makes it go down and making the y coordinate smaller makes it go up. This is because SDL and many 2D rendering APIs use a different coordinate system.</p>
<p>Back in your algebra class, you probably learned about the Cartesian coordinate system:<br><img src="./res/08_cart_coords.png" alt=""></p>
<p>Where the x axis points to the right, the y axis points up, and the origin is in the bottom left corner.</p>
<p>SDL uses a different coordinate system:<br><img src="./res/08_sdl_coords.png" alt=""></p>
<p>The x axis still points to the right, but the y axis points down and the origin is in the top left.</p>
<p>So when we rendered the solid rectangle, the coordinate system functioned like this:<br><img src="./res/08_rect_coords.png" alt=""></p>
<p>Also one thing to know is that SDL renders rectangles, surfaces, and textures from the top left corner.</p>
<pre><code>                //Draw blue horizontal line
                SDL_SetRenderDrawColor( gRenderer, 0x00, 0x00, 0xFF, 0xFF );        
                SDL_RenderDrawLine( gRenderer, 0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2 );
</code></pre><p>Here is the code to draw a pixel thin line using <a href="http://wiki.libsdl.org/SDL_RenderDrawLine">SDL_RenderDrawLine</a>. First we set the color to blue, and then give the rendering calls the starting x/y position and ending x/y position. These positions cause it to go horizontally straight across the screen.</p>
<pre><code>                //Draw vertical line of yellow dots
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0x00, 0xFF );
                for( int i = 0; i &lt; SCREEN_HEIGHT; i += 4 )
                {
                    SDL_RenderDrawPoint( gRenderer, SCREEN_WIDTH / 2, i );
                }

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>The last bit of geometry we render is a sequence of dots using <a href="http://wiki.libsdl.org/SDL_RenderDrawPoint">SDL_RenderDrawPoint</a>. We&#39;re just taking a set of points and drawing them from top to bottom. Again notice the y coordinate and the inverted y axis. After we&#39;re finished drawing all our geometry, we update the screen.</p>
<p>Notice the call to SDL_SetRenderDrawColor. We&#39;re using 255 red and 255 green which combine together to make yellow. Remember that call to SDL_SetRenderDrawColor at the top of the loop? If that wasn&#39;t there, the screen would be cleared with whatever color was last set with SDL_SetRenderDrawColor, resulting in a yellow background in this case.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/08_geometry_rendering/08_geometry_rendering.zip">here</a>.</p>
<h2 id="the-viewport">The Viewport</h2>
<p><img src="./res/09_preview.png" alt=""></p>
<p><strong>Last Updated 1/07/18</strong></p>
<p>Some times you only want to render part of the screen for things like minimaps. Using the viewport you can control where you render on the screen.</p>
<pre><code>                //Top left corner viewport
                SDL_Rect topLeftViewport;
                topLeftViewport.x = 0;
                topLeftViewport.y = 0;
                topLeftViewport.w = SCREEN_WIDTH / 2;
                topLeftViewport.h = SCREEN_HEIGHT / 2;
                SDL_RenderSetViewport( gRenderer, &amp;topLeftViewport );

                //Render texture to screen
                SDL_RenderCopy( gRenderer, gTexture, NULL, NULL );
</code></pre><p>After we clear the screen, it&#39;s time to get drawing. There&#39;s 3 regions we&#39;re going to draw a full screen image to:<br><img src="./res/09_subviews.png" alt=""></p>
<p>First we&#39;re going to render the top left. This is as easy as creating a rectangle with half the width/height as the screen, and passing this region to <a href="http://wiki.libsdl.org/SDL_RenderSetViewport">SDL_RenderSetViewport</a>. Any rendering done after that call will render inside the region defined by the given viewport. It will also use the coordinate system of the window it was created in, so the bottom of the view we created will still be y = 480 even though it&#39;s only 240 pixels down from the top.</p>
<pre><code>                //Top right viewport
                SDL_Rect topRightViewport;
                topRightViewport.x = SCREEN_WIDTH / 2;
                topRightViewport.y = 0;
                topRightViewport.w = SCREEN_WIDTH / 2;
                topRightViewport.h = SCREEN_HEIGHT / 2;
                SDL_RenderSetViewport( gRenderer, &amp;topRightViewport );

                //Render texture to screen
                SDL_RenderCopy( gRenderer, gTexture, NULL, NULL );
</code></pre><p>Here we define the top right area and draw to it. It&#39;s pretty much the same as before, only now the x coordinate is half the screen over.</p>
<pre><code>                //Bottom viewport
                SDL_Rect bottomViewport;
                bottomViewport.x = 0;
                bottomViewport.y = SCREEN_HEIGHT / 2;
                bottomViewport.w = SCREEN_WIDTH;
                bottomViewport.h = SCREEN_HEIGHT / 2;
                SDL_RenderSetViewport( gRenderer, &amp;bottomViewport );

                //Render texture to screen
                SDL_RenderCopy( gRenderer, gTexture, NULL, NULL );


                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>Finally we render one more time in the bottom half of the screen. Again, the viewport will use the same coordinate system as the window it is used in, so the image will appear squished since the viewport is half the height.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/09_the_viewport/09_the_viewport.zip">here</a>.</p>
<h2 id="color-keying">Color Keying</h2>
<p><img src="./res/10_preview.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>When rendering multiple images on the screen, having images with transparent backgrounds is usually necessary. Fortunately SDL provides an easy way to do this using color keying.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        //Deallocates texture
        void free();

        //Renders texture at given point
        void render( int x, int y );

        //Gets image dimensions
        int getWidth();
        int getHeight();

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>For this tutorial we&#39;re going to wrap the SDL_Texture in a class to make some things easier. For example, if you want to get certain information about the texture such as its width or height you would have to use some SDL functions to query the information for the texture. Instead what we&#39;re going to do is use a class to wrap and store the information about the texture.</p>
<p>It&#39;s a fairly straight forward class in terms of design. It has a constructor/destructor pair, a file loader, a deallocator, a renderer that takes in a position, and functions to get the texture&#39;s dimensions. For member variables, it has the texture we&#39;re going to wrap, and variables to store the width/height.</p>
<pre><code>//The window we&#39;ll be rendering to
SDL_Window* gWindow = NULL;

//The window renderer
SDL_Renderer* gRenderer = NULL;

//Scene textures
LTexture gFooTexture;
LTexture gBackgroundTexture;
</code></pre><p>For this scene there&#39;s two textures we&#39;re going to load here declared as &quot;gFooTexture&quot; and &quot;gBackgroundTexture&quot;. We&#39;re going to take this foo&#39; texture:<br><img src="./res/10_foo.png" alt=""></p>
<p>Color key the cyan (light blue) colored background and render it on top of this background:<br><img src="./res/10_background.png" alt=""></p>
<pre><code>LTexture::LTexture()
{
    //Initialize
    mTexture = NULL;
    mWidth = 0;
    mHeight = 0;
}

LTexture::~LTexture()
{
    //Deallocate
    free();
}
</code></pre><p>The constructor initializes variables and the destructor calls the deallocator which we&#39;ll cover later.<br>bool LTexture::loadFromFile( std::string path )</p>
<pre><code>{
    //Get rid of preexisting texture
    free();
</code></pre><p>The texture loading function pretty much works like it did in the <a href="#texture-loading-and-rendering">texture loading tutorial</a> but with some small but important tweaks. First off we deallocate the texture in case there&#39;s one that&#39;s already loaded.</p>
<pre><code>    //The final texture
    SDL_Texture* newTexture = NULL;

    //Load image at specified path
    SDL_Surface* loadedSurface = IMG_Load( path.c_str() );
    if( loadedSurface == NULL )
    {
        printf( &quot;Unable to load image %s! SDL_image Error: %s\n&quot;, path.c_str(), IMG_GetError() );
    }
    else
    {
        //Color key image
        SDL_SetColorKey( loadedSurface, SDL_TRUE, SDL_MapRGB( loadedSurface-&gt;format, 0, 0xFF, 0xFF ) );
</code></pre><p>Next, we color key the image with <a href="http://wiki.libsdl.org/SDL_SetColorKey">SDL_SetColorKey</a> before creating a texture from it. The first argument is the surface we want to color key, the second argument covers whether we want to enable color keying, and the last argument is the pixel we want to color key with.</p>
<p>The most cross platform way to create a pixel from RGB color is with <a href="http://wiki.libsdl.org/SDL_MapRGB">SDL_MapRGB</a>. The first argument is the format we want the pixel in. Fortunately the loaded surface has a format member variable. The last three variables are the red, green, and blue components for color you want to map. Here we&#39;re mapping cyan which is red 0, green 255, blue 255.</p>
<pre><code>        //Create texture from surface pixels
        newTexture = SDL_CreateTextureFromSurface( gRenderer, loadedSurface );
        if( newTexture == NULL )
        {
            printf( &quot;Unable to create texture from %s! SDL Error: %s\n&quot;, path.c_str(), SDL_GetError() );
        }
        else
        {
            //Get image dimensions
            mWidth = loadedSurface-&gt;w;
            mHeight = loadedSurface-&gt;h;
        }

        //Get rid of old loaded surface
        SDL_FreeSurface( loadedSurface );
    }

    //Return success
    mTexture = newTexture;
    return mTexture != NULL;
}
</code></pre><p>After color keying the loaded surface, we create a texture from the loaded and color keyed surface. If the texture was created successfully, we store the width/height of the texture and return whether the texture loaded successfully.</p>
<pre><code>void LTexture::free()
{
    //Free texture if it exists
    if( mTexture != NULL )
    {
        SDL_DestroyTexture( mTexture );
        mTexture = NULL;
        mWidth = 0;
        mHeight = 0;
    }
}
</code></pre><p>The deallocator simply checks if a texture exists, destroys it, and reinitializes the member variables.</p>
<pre><code>void LTexture::render( int x, int y )
{
    //Set rendering space and render to screen
    SDL_Rect renderQuad = { x, y, mWidth, mHeight };
    SDL_RenderCopy( gRenderer, mTexture, NULL, &amp;renderQuad );
}
</code></pre><p>Here you see why we needed a wrapper class. Up until now, we have been pretty much been rendering full screen images so we didn&#39;t need to specify position. Because we didn&#39;t need to specify position, we just called SDL_RenderCopy with the last two arguments as NULL.</p>
<p>When rendering a texture in a certain place, you need to specify a destination rectangle that sets the x/y position and width/height. We can&#39;t specify the width/height without knowing the original image&#39;s dimensions. So here when we render our texture we create a rectangle with the position arguments and the member width/height, and pass in this rectangle to SDL_RenderCopy.</p>
<pre><code>int LTexture::getWidth()
{
    return mWidth;
}

int LTexture::getHeight()
{
    return mHeight;
}
</code></pre><p>These last member functions allow us to get the width/height when we need them.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load Foo&#39; texture
    if( !gFooTexture.loadFromFile( &quot;10_color_keying/foo.png&quot; ) )
    {
        printf( &quot;Failed to load Foo&#39; texture image!\n&quot; );
        success = false;
    }

    //Load background texture
    if( !gBackgroundTexture.loadFromFile( &quot;10_color_keying/background.png&quot; ) )
    {
        printf( &quot;Failed to load background texture image!\n&quot; );
        success = false;
    }

    return success;
}
</code></pre><p>Here are the image loading functions in action.</p>
<pre><code>void close()
{
    //Free loaded images
    gFooTexture.free();
    gBackgroundTexture.free();

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>And here are the deallocators.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render background texture to screen
                gBackgroundTexture.render( 0, 0 );

                //Render Foo&#39; to the screen
                gFooTexture.render( 240, 190 );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>Here is the main loop with our textures rendering. It&#39;s a basic loop that handles events, clears the screen, renders the background, renders the stick figure on top of it, and updates the screen.</p>
<p>An important thing to note is that order matters when you&#39;re rendering multiple things to the screen every frame. If we to render the stick figure first, the background will render over it and you won&#39;t be able to see the stick figure.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/10_color_keying/10_color_keying.zip">here</a>.</p>
<h2 id="clip-rendering-and-sprite-sheets">Clip Rendering and Sprite Sheets</h2>
<p><img src="./res/11_preview.png" alt=""></p>
<p><strong>Last Updated 1/07/18</strong></p>
<p>Sometimes you only want to render part of a texture. A lot of times games like to keep multiple images on the same sprite sheet as opposed to having a bunch of textures. Using clip rendering, we can define a portion of the texture to render as opposed to rendering the whole thing.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        //Deallocates texture
        void free();

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL );

        //Gets image dimensions
        int getWidth();
        int getHeight();

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>Here we&#39;re making a small tweak to the rendering function in the texture class. The render function now accepts a rectangle defining which portion of the texture we want to render. We give it a default argument of NULL in case we want to render the whole texture.</p>
<pre><code>//Scene sprites
SDL_Rect gSpriteClips[ 4 ];
LTexture gSpriteSheetTexture;
</code></pre><p>For this tutorial, we&#39;re going to take this sprite sheet:<br><img src="./res/11_sprites.png" alt=""></p>
<p>And render each sprite in a different corner:</p>
<table>
<thead>
<tr>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/11_final.png" alt=""></td>
</tr>
</tbody>
</table>
<p>So we&#39;re going to need a texture image and 4 rectangles to define the sprites, which are the variables you see declared here.</p>
<pre><code>void LTexture::render( int x, int y, SDL_Rect* clip )
{
    //Set rendering space and render to screen
    SDL_Rect renderQuad = { x, y, mWidth, mHeight };

    //Set clip rendering dimensions
    if( clip != NULL )
    {
        renderQuad.w = clip-&gt;w;
        renderQuad.h = clip-&gt;h;
    }

    //Render to screen
    SDL_RenderCopy( gRenderer, mTexture, clip, &amp;renderQuad );
}
</code></pre><p>Here&#39;s the new rendering function for the texture class that supports clip rendering. It&#39;s mostly the same as the previous <a href="#color-keying">texture rendering function</a> but with two changes.</p>
<p>First, when you&#39;re clipping and you&#39;re using the dimensions of the clip rectangle instead of the texture, we&#39;re going to set the width/height of the destination rectangle (here called renderQuad) to the size of the clip rectangle.</p>
<p>Secondly, we&#39;re going to pass in the clip rectangle to SDL_RenderCopy as the source rectangle. The source rectangle defines what part of the texture you want to render. When the source rectangle is NULL, the whole texture is rendered.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load sprite sheet texture
    if( !gSpriteSheetTexture.loadFromFile( &quot;11_clip_rendering_and_sprite_sheets/dots.png&quot; ) )
    {
        printf( &quot;Failed to load sprite sheet texture!\n&quot; );
        success = false;
    }
    else
    {
        //Set top left sprite
        gSpriteClips[ 0 ].x =   0;
        gSpriteClips[ 0 ].y =   0;
        gSpriteClips[ 0 ].w = 100;
        gSpriteClips[ 0 ].h = 100;

        //Set top right sprite
        gSpriteClips[ 1 ].x = 100;
        gSpriteClips[ 1 ].y =   0;
        gSpriteClips[ 1 ].w = 100;
        gSpriteClips[ 1 ].h = 100;

        //Set bottom left sprite
        gSpriteClips[ 2 ].x =   0;
        gSpriteClips[ 2 ].y = 100;
        gSpriteClips[ 2 ].w = 100;
        gSpriteClips[ 2 ].h = 100;

        //Set bottom right sprite
        gSpriteClips[ 3 ].x = 100;
        gSpriteClips[ 3 ].y = 100;
        gSpriteClips[ 3 ].w = 100;
        gSpriteClips[ 3 ].h = 100;
    }

    return success;
}
</code></pre><p>The media loading function loads the texture and then defines the clip rectangles for the circle sprites if the texture loaded successfully.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render top left sprite
                gSpriteSheetTexture.render( 0, 0, &amp;gSpriteClips[ 0 ] );

                //Render top right sprite
                gSpriteSheetTexture.render( SCREEN_WIDTH - gSpriteClips[ 1 ].w, 0, &amp;gSpriteClips[ 1 ] );

                //Render bottom left sprite
                gSpriteSheetTexture.render( 0, SCREEN_HEIGHT - gSpriteClips[ 2 ].h, &amp;gSpriteClips[ 2 ] );

                //Render bottom right sprite
                gSpriteSheetTexture.render( SCREEN_WIDTH - gSpriteClips[ 3 ].w, SCREEN_HEIGHT - gSpriteClips[ 3 ].h, &amp;gSpriteClips[ 3 ] );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>Finally here in the main loop we render the same texture 4 times, but we&#39;re rendering a different portion of the sprite sheet in different places each call.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/11_clip_rendering_and_sprite_sheets/11_clip_rendering_and_sprite_sheets.zip">here</a>.</p>
<h2 id="color-modulation">Color Modulation</h2>
<p><img src="./res/12_preview.png" alt=""></p>
<p><strong>Last Updated 1/19/14</strong></p>
<p>Color modulation allows you to alter the color of your rendered textures. Here we&#39;re going to modulate a texture using various colors.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        //Deallocates texture
        void free();

        //Set color modulation
        void setColor( Uint8 red, Uint8 green, Uint8 blue );

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL );

        //Gets image dimensions
        int getWidth();
        int getHeight();

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>We&#39;re adding a function to the texture wrapper class that will allow the texture modulation to be set. All it does is take in a red, green, and blue color components.</p>
<pre><code>void LTexture::setColor( Uint8 red, Uint8 green, Uint8 blue )
{
    //Modulate texture
    SDL_SetTextureColorMod( mTexture, red, green, blue );
}
</code></pre><p>And setting texture modulation is as easy as making a call to <a href="http://wiki.libsdl.org/SDL_SetTextureColorMod">SDL_SetTextureColorMod</a>. You just pass in the texture you want to modulate and the color you want to modulate with.</p>
<p>Now how does color modulation work? Let&#39;s say you have this texture:<br><img src="./res/12_full.png" alt=""></p>
<p>And you modulate it with red 255, green 128, and blue 255. You&#39;ll end up with this:<br><img src="./res/12_half_green.png" alt=""></p>
<p>You may have noticed that SDL_SetTextureColorMod accepts Uint8 as arguments for the color components. An Uint8 is just an integer that is Unsigned and 8bit. This means it goes from 0 to 255. 128 is about halfway between 0 and 255, so when you modulate green to 128 it halves the green component for any pixel on the texture.</p>
<p>The red and blue squares don&#39;t get affected because they have no green in them, but the green becomes half as bright and the white turns a light magenta (magenta is red 255, green 0, blue 255). Color modulation is just a way to multiply a color throughout the whole texture.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Modulation components
            Uint8 r = 255;
            Uint8 g = 255;
            Uint8 b = 255;
</code></pre><p>Here we are right before the main loop. For this demo we&#39;re going to modulate the individual color components using key presses. To do that we&#39;ll need to keep track of the values for the color components.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                    //On keypress change rgb values
                    else if( e.type == SDL_KEYDOWN )
                    {
                        switch( e.key.keysym.sym )
                        {
                            //Increase red
                            case SDLK_q:
                            r += 32;
                            break;

                            //Increase green
                            case SDLK_w:
                            g += 32;
                            break;

                            //Increase blue
                            case SDLK_e:
                            b += 32;
                            break;

                            //Decrease red
                            case SDLK_a:
                            r -= 32;
                            break;

                            //Decrease green
                            case SDLK_s:
                            g -= 32;
                            break;

                            //Decrease blue
                            case SDLK_d:
                            b -= 32;
                            break;
                        }
                    }
                }
</code></pre><p>In our event loop we&#39;ll have the q, w, and e keys increase the red, green, and blue components and we&#39;ll have the a, s, and d key decrease the red, green, and blue components. They increase/decrease the components by 32 so it&#39;s noticable with every key press.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Modulate and render texture
                gModulatedTexture.setColor( r, g, b );
                gModulatedTexture.render( 0, 0 );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>And here we are setting the texture modulation and rendering the texture.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/12_color_modulation/12_color_modulation.zip">here</a>.</p>
<h2 id="alpha-blending">Alpha Blending</h2>
<p><img src="./res/13_preview.png" alt=""></p>
<p><strong>Last Updated 7/13/14</strong></p>
<p>Thanks to new hardware accelerated rendering, transparency is much faster in SDL 2.0. Here we&#39;ll use alpha modulation (which works much like <a href="#color-modulation">color modulation</a>) to control the transparency of a texture.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        //Deallocates texture
        void free();

        //Set color modulation
        void setColor( Uint8 red, Uint8 green, Uint8 blue );

        //Set blending
        void setBlendMode( SDL_BlendMode blending );

        //Set alpha modulation
        void setAlpha( Uint8 alpha );

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL );

        //Gets image dimensions
        int getWidth();
        int getHeight();

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>Here we&#39;re going to add two functions to support alpha transparency on a texture. First there&#39;s setAlpha which will function much like setColor did in the color modulation tutorial. There&#39;s also setBlendMode which will control how the texture is blended. In order to get blending to work properly, you must set the blend mode on the texture. We&#39;ll cover this in detail later.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load front alpha texture
    if( !gModulatedTexture.loadFromFile( &quot;13_alpha_blending/fadeout.png&quot; ) )
    {
        printf( &quot;Failed to load front texture!\n&quot; );
        success = false;
    }
    else
    {
        //Set standard alpha blending
        gModulatedTexture.setBlendMode( SDL_BLENDMODE_BLEND );
    }

    //Load background texture
    if( !gBackgroundTexture.loadFromFile( &quot;13_alpha_blending/fadein.png&quot; ) )
    {
        printf( &quot;Failed to load background texture!\n&quot; );
        success = false;
    }

    return success;
}
</code></pre><p>Here in the texture loading function we&#39;re loading the front texture we&#39;re going to alpha blend and a background texture. As the front texture gets more transparent, we&#39;ll be able to see more of the back texture. As you can see in the code, after we load the front texture successfully we set the <a href="http://wiki.libsdl.org/SDL_BlendMode">SDL_BlendMode</a> to blend so blending is enabled. Since the background isn&#39;t going to be transparent, we don&#39;t have to set the blending on it.</p>
<p>Now how does alpha work? Alpha is opacity, and the lower the opacity the more we can see through it. Like red, green, or blue color components it goes from 0 to 255 when modulating it. The best way to understand it is with some examples. Say if we had the front image on a white background.</p>
<p>This is the front image at 255 (100% alpha):<br><img src="./res/13_alpha100.png" alt=""></p>
<p>This is the front image at 191 (75% alpha):<br><img src="./res/13_alpha075.png" alt=""></p>
<p>This is the front image at 127 (50% alpha):<br><img src="./res/13_alpha050.png" alt=""></p>
<p>This is the front image at 63 (25% alpha):<br><img src="./res/13_alpha025.png" alt=""></p>
<p>This is the front image at 0 (0% alpha):<br><img src="./res/13_alpha000.png" alt=""></p>
<p>As you can see, the lower the alpha the more transparent it is.</p>
<pre><code>void LTexture::setBlendMode( SDL_BlendMode blending )
{
    //Set blending function
    SDL_SetTextureBlendMode( mTexture, blending );
}

void LTexture::setAlpha( Uint8 alpha )
{
    //Modulate texture alpha
    SDL_SetTextureAlphaMod( mTexture, alpha );
}
</code></pre><p>Here are the actual SDL functions that do the actual work. <a href="http://wiki.libsdl.org/SDL_SetTextureBlendMode">SDL_SetTextureBlendMode</a> in setBlendMode allows us to enable blending and <a href="http://wiki.libsdl.org/SDL_SetTextureAlphaMod">SDL_SetTextureAlphaMod</a> allows us to set the amount of alpha for the whole texture.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Modulation component
            Uint8 a = 255;

            //While application is running
            while( !quit )
            {
</code></pre><p>Right before entering the main loop, we declare a variable to control how much alpha the texture has. It is initialized to 255 so the front texture starts out completely opaque.</p>
<pre><code>                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                    //Handle key presses
                    else if( e.type == SDL_KEYDOWN )
                    {
                        //Increase alpha on w
                        if( e.key.keysym.sym == SDLK_w )
                        {
                            //Cap if over 255
                            if( a + 32 &gt; 255 )
                            {
                                a = 255;
                            }
                            //Increment otherwise
                            else
                            {
                                a += 32;
                            }
                        }
                        //Decrease alpha on s
                        else if( e.key.keysym.sym == SDLK_s )
                        {
                            //Cap if below 0
                            if( a - 32 &lt; 0 )
                            {
                                a = 0;
                            }
                            //Decrement otherwise
                            else
                            {
                                a -= 32;
                            }
                        }
                    }
                }
</code></pre><p>The event loop handles quit events and making the alpha value go up/down with the w/s keys.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render background
                gBackgroundTexture.render( 0, 0 );

                //Render front blended
                gModulatedTexture.setAlpha( a );
                gModulatedTexture.render( 0, 0 );

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>At the end of the main loop we do our rendering. After clearing the screen we render the background first and then we render the front modulated texture over it. Right before rendering the front texture, we set its alpha value. Try increasing/decreasing the alpha value to see how transparency affects the rendering.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/13_alpha_blending/13_alpha_blending.zip">here</a>.</p>
<h2 id="animated-sprites-and-vsync">Animated Sprites and VSync</h2>
<p><img src="./res/14_preview.png" alt=""></p>
<p><strong>Last Updated 2/09/14</strong></p>
<p>Animation in a nutshell is just showing one image after another to create the illusion of motion. Here we&#39;ll be showing different sprites to animate a stick figure.</p>
<p>Say if we had these frames of animation (that clearly demonstrate I am not an animator):<br><img src="./res/14_foo.png" alt=""></p>
<p>And showed one right after the other every 10th of a second we&#39;d get this animation:<br><img src="./res/14_foowalk.gif" alt=""></p>
<p>Since images in SDL 2 are typically SDL_Textures, animating in SDL is a matter of showing different parts of a texture (or different whole textures) one right after the other.</p>
<pre><code>//Walking animation
const int WALKING_ANIMATION_FRAMES = 4;
SDL_Rect gSpriteClips[ WALKING_ANIMATION_FRAMES ];
LTexture gSpriteSheetTexture;
</code></pre><p>So here we have the <a href="#clip-rendering-and-sprite-sheets">spritesheet with sprites</a> that we&#39;re going to use for the animation.</p>
<pre><code>            //Create vsynced renderer for window
            gRenderer = SDL_CreateRenderer( gWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC );
            if( gRenderer == NULL )
            {
                printf( &quot;Renderer could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
                success = false;
            }
</code></pre><p>For this (and future tutorials), we want to use Vertical Sync. VSync allows the rendering to update at the same time as when your monitor updates during vertical refresh. For this tutorial it will make sure the animation doesn&#39;t run too fast. Most monitors run at about 60 frames per second and that&#39;s the assumption we&#39;re making here. If you have a different monitor refresh rate, that would explain why the animation is running too fast or slow.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load sprite sheet texture
    if( !gSpriteSheetTexture.loadFromFile( &quot;14_animated_sprites_and_vsync/foo.png&quot; ) )
    {
        printf( &quot;Failed to load walking animation texture!\n&quot; );
        success = false;
    }
    else
    {
        //Set sprite clips
        gSpriteClips[ 0 ].x =   0;
        gSpriteClips[ 0 ].y =   0;
        gSpriteClips[ 0 ].w =  64;
        gSpriteClips[ 0 ].h = 205;

        gSpriteClips[ 1 ].x =  64;
        gSpriteClips[ 1 ].y =   0;
        gSpriteClips[ 1 ].w =  64;
        gSpriteClips[ 1 ].h = 205;

        gSpriteClips[ 2 ].x = 128;
        gSpriteClips[ 2 ].y =   0;
        gSpriteClips[ 2 ].w =  64;
        gSpriteClips[ 2 ].h = 205;

        gSpriteClips[ 3 ].x = 196;
        gSpriteClips[ 3 ].y =   0;
        gSpriteClips[ 3 ].w =  64;
        gSpriteClips[ 3 ].h = 205;
    }

    return success;
}
</code></pre><p>After we load the sprite sheet we want to define the sprites for the individual frames of animation.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Current animation frame
            int frame = 0;
</code></pre><p>Before the main loop we have to declare a variable to keep track of the current frame of animation.</p>
<pre><code>                //Render current frame
                SDL_Rect* currentClip = &amp;gSpriteClips[ frame / 4 ];
                gSpriteSheetTexture.render( ( SCREEN_WIDTH - currentClip-&gt;w ) / 2, ( SCREEN_HEIGHT - currentClip-&gt;h ) / 2, currentClip );

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>After the screen is cleared in the main loop, we want to render the current frame of animation.</p>
<p>The animation goes from frames 0 to 3. Since there are only 4 frames of animation, we want to slow down the animation a bit. This is why when we get the current clip sprite, we want to divide the frame by 4. This way the actual frame of animation only updates every 4 frames since with int data types 0 / 4 = 0, 1 / 4 = 0, 2 / 4 = 0, 3 / 4 = 0, 4 / 4 = 1, 5 / 4 = 1, etc.</p>
<p>After we get the current sprite, we want to render it to the screen and update the screen.</p>
<pre><code>                //Go to next frame
                ++frame;

                //Cycle animation
                if( frame / 4 &gt;= WALKING_ANIMATION_FRAMES )
                {
                    frame = 0;
                }
            }
</code></pre><p>Now in order for the frame to update, we need to increment the frame value every frame. If we didn&#39;t, then the animation would stay at the first frame.</p>
<p>We also want the animation to cycle, so when the frame hits the final value ( 16 / 4 = 4 ) we reset the frame back to 0 so the animation starts over again.</p>
<p>After we update the frame by either incrementing it or cycling it back to 0, we reach the end of the main loop. This main loop will keep showing a frame and updating the animation value to animate the sprite.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/14_animated_sprites_and_vsync/14_animated_sprites_and_vsync.zip">here</a>.</p>
<h2 id="rotation-and-flipping">Rotation and Flipping</h2>
<p><img src="./res/15_preview.png" alt=""></p>
<p><strong>Last Updated 4/09/17</strong></p>
<p>SDL 2&#39;s hardware accelerated texture rendering also gives ability to give us fast image flipping and rotation. In this tutorial we&#39;ll be using this to make an arrow texture spin and flip.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        //Deallocates texture
        void free();

        //Set color modulation
        void setColor( Uint8 red, Uint8 green, Uint8 blue );

        //Set blending
        void setBlendMode( SDL_BlendMode blending );

        //Set alpha modulation
        void setAlpha( Uint8 alpha );

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL, double angle = 0.0, SDL_Point* center = NULL, SDL_RendererFlip flip = SDL_FLIP_NONE );

        //Gets image dimensions
        int getWidth();
        int getHeight();

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>Here we&#39;re adding more functionality to the <a href="#color-keying">texture class</a>. The render function now takes in a rotation angle, a point to rotate the texture around, and a <a href="http://wiki.libsdl.org/SDL_RendererFlip">SDL flipping enum</a>.</p>
<p>Like with clipping rectangles, we give the arguments default values in case you want to render the texture without rotation or flipping.</p>
<pre><code>void LTexture::render( int x, int y, SDL_Rect* clip, double angle, SDL_Point* center, SDL_RendererFlip flip )
{
    //Set rendering space and render to screen
    SDL_Rect renderQuad = { x, y, mWidth, mHeight };

    //Set clip rendering dimensions
    if( clip != NULL )
    {
        renderQuad.w = clip-&gt;w;
        renderQuad.h = clip-&gt;h;
    }

    //Render to screen
    SDL_RenderCopyEx( gRenderer, mTexture, clip, &amp;renderQuad, angle, center, flip );
}
</code></pre><p>As you can see, all we&#39;re doing is passing in the arguments from our function to <a href="http://wiki.libsdl.org/SDL_RenderCopyEx">SDL_RenderCopyEx</a>. This function works the same as the original SDL_RenderCopy, but with additional arguments for rotation and flipping.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Angle of rotation
            double degrees = 0;

            //Flip type
            SDL_RendererFlip flipType = SDL_FLIP_NONE;
</code></pre><p>Before we enter the main loop we declare variables to keep track of the rotation angle and flipping type.</p>
<pre><code>                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                    else if( e.type == SDL_KEYDOWN )
                    {
                        switch( e.key.keysym.sym )
                        {
                            case SDLK_a:
                            degrees -= 60;
                            break;

                            case SDLK_d:
                            degrees += 60;
                            break;

                            case SDLK_q:
                            flipType = SDL_FLIP_HORIZONTAL;
                            break;

                            case SDLK_w:
                            flipType = SDL_FLIP_NONE;
                            break;

                            case SDLK_e:
                            flipType = SDL_FLIP_VERTICAL;
                            break;
                        }
                    }
                }
</code></pre><p>In the event loop, we want to increment/decrement the rotation with the a/d keys and change the type of flipping with the q,w, and e keys.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render arrow
                gArrowTexture.render( ( SCREEN_WIDTH - gArrowTexture.getWidth() ) / 2, ( SCREEN_HEIGHT - gArrowTexture.getHeight() ) / 2, NULL, degrees, NULL, flipType );

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>Here we do the actual rendering. First we pass in the x and y coordinates. That may seem like a complicated equation, but all it does is center the image. If the image is 440 pixels wide on a 640 pixel wide screen, we want it to be padded by 100 pixels on each side. In other words, the x coordinate will be the screen width (640) minus the image width (440) all divided by 2 ( (640 - 440 ) / 2 = 100).</p>
<p>The next argument is the clip rectangle and since we&#39;re rendering the whole texture it is set to null. The next argument is the rotation angle in degrees. The next argument is the point we&#39;re rotation around. When this is null, it will rotate around the center of the image. The last argument is how the image flipped.</p>
<p>The best way to wrap your mind around how to use rotation is to play around with it. Experiment to see the type of effects you get by combining different rotations/flipping.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/15_rotation_and_flipping/15_rotation_and_flipping.zip">here</a>.</p>
<h2 id="true-type-fonts">True Type Fonts</h2>
<p><img src="./res/16_preview.png" alt=""></p>
<p><strong>Last Updated 2/16/14</strong></p>
<p>One way to render text with SDL is with the extension library SDL_ttf. SDL_ttf allows you to create images from TrueType fonts which we&#39;ll use here to create textures from font text.</p>
<pre><code>//Using SDL, SDL_image, SDL_ttf, standard IO, math, and strings
#include &lt;SDL.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;SDL_ttf.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
</code></pre><p>To use SDL_ttf, you have to set up <a href="http://www.libsdl.org/projects/SDL_ttf/">the SDL_ttf extension library</a> just like you would <a href="#extension-libraries-and-loading-other-image-formats">set up SDL_image</a>. Like before, it&#39;s just a matter of having the headers files, library files, and binary files in the right place with your compiler configured to use them.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        //Creates image from font string
        bool loadFromRenderedText( std::string textureText, SDL_Color textColor );

        //Deallocates texture
        void free();

        //Set color modulation
        void setColor( Uint8 red, Uint8 green, Uint8 blue );

        //Set blending
        void setBlendMode( SDL_BlendMode blending );

        //Set alpha modulation
        void setAlpha( Uint8 alpha );

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL, double angle = 0.0, SDL_Point* center = NULL, SDL_RendererFlip flip = SDL_FLIP_NONE );

        //Gets image dimensions
        int getWidth();
        int getHeight();

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>Here we&#39;re adding another function to the <a href="#color-keying">texture class</a> called loadFromRenderedText. The way SDL_ttf works is that you create a new image from a font and color. For our texture class all that means is that we&#39;re going to be loading our image from text rendered by SDL_ttf instead of a file.</p>
<pre><code>//The window we&#39;ll be rendering to
SDL_Window* gWindow = NULL;

//The window renderer
SDL_Renderer* gRenderer = NULL;

//Globally used font
TTF_Font *gFont = NULL;

//Rendered texture
LTexture gTextTexture;
</code></pre><p>For this and future tutorials, we&#39;ll be using a global font for our text rendering. In SDL_ttf, the data type for fonts is <a href="http://www.libsdl.org/projects/docs/SDL_ttf/SDL_ttf_49.html">TTF_Font</a>.</p>
<p>We also have a texture which will be generated from the font.</p>
<pre><code>bool LTexture::loadFromRenderedText( std::string textureText, SDL_Color textColor )
{
    //Get rid of preexisting texture
    free();

    //Render text surface
    SDL_Surface* textSurface = TTF_RenderText_Solid( gFont, textureText.c_str(), textColor );
    if( textSurface == NULL )
    {
        printf( &quot;Unable to render text surface! SDL_ttf Error: %s\n&quot;, TTF_GetError() );
    }
    else
    {
        //Create texture from surface pixels
        mTexture = SDL_CreateTextureFromSurface( gRenderer, textSurface );
        if( mTexture == NULL )
        {
            printf( &quot;Unable to create texture from rendered text! SDL Error: %s\n&quot;, SDL_GetError() );
        }
        else
        {
            //Get image dimensions
            mWidth = textSurface-&gt;w;
            mHeight = textSurface-&gt;h;
        }

        //Get rid of old surface
        SDL_FreeSurface( textSurface );
    }

    //Return success
    return mTexture != NULL;
}
</code></pre><p>Here is where we actually create the text texture we&#39;re going to render from the font. This function takes in the string of text we want to render and the color we want to use to render it. After that, this function pretty much works like loading from a file does, only this time we&#39;re using a SDL_Surface created by SDL_ttf instead of a file.</p>
<p>After freeing any preexisting textures, we load a surface using <a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_43.html">TTF_RenderText_Solid</a>. This creates a solid color surface from the font, text, and color given. If the surface was created successfully, <a href="#texture-loading-and-rendering">we create a texture out of it</a> just like we did before when loading a surface from a file. After the text texture is created, we can render with it just like any other texture.</p>
<p>There are other ways to render text that are smoother or blended. Experiment with the different types of rendering outlined in the <a href="http://www.libsdl.org/projects/docs/SDL_ttf/SDL_ttf_35.html">SDL_ttf documentation</a>.</p>
<pre><code>                //Initialize PNG loading
                int imgFlags = IMG_INIT_PNG;
                if( !( IMG_Init( imgFlags ) &amp; imgFlags ) )
                {
                    printf( &quot;SDL_image could not initialize! SDL_image Error: %s\n&quot;, IMG_GetError() );
                    success = false;
                }

                 //Initialize SDL_ttf
                if( TTF_Init() == -1 )
                {
                    printf( &quot;SDL_ttf could not initialize! SDL_ttf Error: %s\n&quot;, TTF_GetError() );
                    success = false;
                }
</code></pre><p>Just like SDL_image, we have to initialize it or the font loading and rendering functions won&#39;t work properly. We start up SDL_ttf using <a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_8.html">TTF_init</a>. We can check for errors using TTF_GetError().</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Open the font
    gFont = TTF_OpenFont( &quot;16_true_type_fonts/lazy.ttf&quot;, 28 );
    if( gFont == NULL )
    {
        printf( &quot;Failed to load lazy font! SDL_ttf Error: %s\n&quot;, TTF_GetError() );
        success = false;
    }
    else
    {
        //Render text
        SDL_Color textColor = { 0, 0, 0 };
        if( !gTextTexture.loadFromRenderedText( &quot;The quick brown fox jumps over the lazy dog&quot;, textColor ) )
        {
            printf( &quot;Failed to render text texture!\n&quot; );
            success = false;
        }
    }

    return success;
}
</code></pre><p>In our loading function, we load our font using <a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_14.html">TTF_OpenFont</a>. This takes in the path to the font file and the point size we want to render at.</p>
<p>If the font loaded successfully, we want to load a text texture using our loading method. As a general rule, you want to minimize the number of time you render text. Only rerender it when you need to and since we&#39;re using the same text surface for this whole program, we only want to render once.</p>
<pre><code>void close()
{
    //Free loaded images
    gTextTexture.free();

    //Free global font
    TTF_CloseFont( gFont );
    gFont = NULL;

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    TTF_Quit();
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>In our clean up function, we want to free the font using <a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_18.html">TTF_CloseFont</a>. We also want to quit the SDL_ttf library with <a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_10.html">TTF_Quit</a> to complete the clean up.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render current frame
                gTextTexture.render( ( SCREEN_WIDTH - gTextTexture.getWidth() ) / 2, ( SCREEN_HEIGHT - gTextTexture.getHeight() ) / 2 );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>As you can see, after we render the text texture we can render it just like any other texture.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/16_true_type_fonts/16_true_type_fonts.zip">here</a>.</p>
<h2 id="mouse-events">Mouse Events</h2>
<p><img src="./res/17_preview.png" alt=""></p>
<p><strong>Last Updated 6/06/19</strong></p>
<p>Like with key presses, SDL has <a href="#event-driven-programming">event structures</a> to handle mouse events such as mouse motion, mouse button presses, and mouse button releasing. In this tutorial we&#39;ll make a bunch of buttons we can interact with.</p>
<pre><code>//Button constants
const int BUTTON_WIDTH = 300;
const int BUTTON_HEIGHT = 200;
const int TOTAL_BUTTONS = 4;

enum LButtonSprite
{
    BUTTON_SPRITE_MOUSE_OUT = 0,
    BUTTON_SPRITE_MOUSE_OVER_MOTION = 1,
    BUTTON_SPRITE_MOUSE_DOWN = 2,
    BUTTON_SPRITE_MOUSE_UP = 3,
    BUTTON_SPRITE_TOTAL = 4
};
</code></pre><p>For this tutorial we&#39;ll have 4 buttons on the screen. Depending on whether the mouse moved over, clicked on, released on, or moved out of the button we&#39;ll display a different sprite. These constants are here to define all this.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        #if defined(_SDL_TTF_H) || defined(SDL_TTF_H)
        //Creates image from font string
        bool loadFromRenderedText( std::string textureText, SDL_Color textColor );
        #endif

        //Deallocates texture
        void free();

        //Set color modulation
        void setColor( Uint8 red, Uint8 green, Uint8 blue );

        //Set blending
        void setBlendMode( SDL_BlendMode blending );

        //Set alpha modulation
        void setAlpha( Uint8 alpha );

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL, double angle = 0.0, SDL_Point* center = NULL, SDL_RendererFlip flip = SDL_FLIP_NONE );

        //Gets image dimensions
        int getWidth();
        int getHeight();

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>We&#39;re making a slight modification to the texture class. For this tutorial we won&#39;t be <a href="#true-type-fonts">using SDL_ttf to render text</a>. This means we don&#39;t need the loadFromRenderedText function. Rather than deleting code we may need in the future, we&#39;re going to wrap it in if defined statements so the compiler will ignore it if we do not include SDL_ttf. It checks the _SDL_TTF_H macro is defined (for earlier versions of SDL_ttf) or the SDL_TTF_H is defined (for newer versions of SDL_ttf). Like #include, #if is a macro which is used to talk to the compiler. In this case it says if SDL_ttf is not defined, ignore this piece of code.</p>
<pre><code>//The mouse button
class LButton
{
    public:
        //Initializes internal variables
        LButton();

        //Sets top left position
        void setPosition( int x, int y );

        //Handles mouse event
        void handleEvent( SDL_Event* e );

        //Shows button sprite
        void render();

    private:
        //Top left position
        SDL_Point mPosition;

        //Currently used global sprite
        LButtonSprite mCurrentSprite;
};
</code></pre><p>Here is the class to represent a button. It has a constructor to initialize, a position setter, an event handler for the event loop, and a rendering function. It also has a position and a sprite enumeration so we know which sprite to render for the button.</p>
<pre><code>#if defined(_SDL_TTF_H) || defined(SDL_TTF_H)
bool LTexture::loadFromRenderedText( std::string textureText, SDL_Color textColor )
{
    //Get rid of preexisting texture
    free();

    //Render text surface
    SDL_Surface* textSurface = TTF_RenderText_Solid( gFont, textureText.c_str(), textColor );
    if( textSurface == NULL )
    {
        printf( &quot;Unable to render text surface! SDL_ttf Error: %s\n&quot;, TTF_GetError() );
    }
    else
    {
        //Create texture from surface pixels
        mTexture = SDL_CreateTextureFromSurface( gRenderer, textSurface );
        if( mTexture == NULL )
        {
            printf( &quot;Unable to create texture from rendered text! SDL Error: %s\n&quot;, SDL_GetError() );
        }
        else
        {
            //Get image dimensions
            mWidth = textSurface-&gt;w;
            mHeight = textSurface-&gt;h;
        }

        //Get rid of old surface
        SDL_FreeSurface( textSurface );
    }

    //Return success
    return mTexture != NULL;
}
#endif
</code></pre><p>To make sure our source compiles without SDL_ttf, here again we sandwich the loading from font function in another if defined condition.</p>
<pre><code>LButton::LButton()
{
    mPosition.x = 0;
    mPosition.y = 0;

    mCurrentSprite = BUTTON_SPRITE_MOUSE_OUT;
}

void LButton::setPosition( int x, int y )
{
    mPosition.x = x;
    mPosition.y = y;
}
</code></pre><p>Here are the constructor for the button and a position setting function. As you can see, they initialize the default sprite and set position.</p>
<pre><code>void LButton::handleEvent( SDL_Event* e )
{
    //If mouse event happened
    if( e-&gt;type == SDL_MOUSEMOTION || e-&gt;type == SDL_MOUSEBUTTONDOWN || e-&gt;type == SDL_MOUSEBUTTONUP )
    {
        //Get mouse position
        int x, y;
        SDL_GetMouseState( &amp;x, &amp;y );
</code></pre><p>Here&#39;s the meat of the tutorial where we handle the mouse events. This function will be called in the event loop and will handle an event taken from the event queue for an individual button.</p>
<p>First we check if the event coming in is a mouse event specifically a mouse motion event (when the mouse moves), a mouse button down event (when you click a mouse button), or a mouse button up event (when you release a mouse click).</p>
<p>If one of these mouse events do occur, we check the mouse position using <a href="http://wiki.libsdl.org/SDL_GetMouseState">SDL_GetMouseState</a>. Depending on whether the mouse is over the button or not, we&#39;ll want to display different sprites.</p>
<pre><code>        //Check if mouse is in button
        bool inside = true;

        //Mouse is left of the button
        if( x &lt; mPosition.x )
        {
            inside = false;
        }
        //Mouse is right of the button
        else if( x &gt; mPosition.x + BUTTON_WIDTH )
        {
            inside = false;
        }
        //Mouse above the button
        else if( y &lt; mPosition.y )
        {
            inside = false;
        }
        //Mouse below the button
        else if( y &gt; mPosition.y + BUTTON_HEIGHT )
        {
            inside = false;
        }
</code></pre><p>Here we want to check if the mouse is inside the button or not. Since <a href="#geometry-rendering">we use a different coordinate system with SDL</a>, the origin of the button is at the top left. This means every x coordinate less than the x position is outside of the button and every y coordinate less than the y position is too. Everything right of the button is the x position + the width and everything below the button is the y position + the height.</p>
<p>This is what this piece of code does. If the mouse position is in any way outside the button, it marks the inside marker as false. Otherwise it remains the initial true value.</p>
<pre><code>        //Mouse is outside button
        if( !inside )
        {
            mCurrentSprite = BUTTON_SPRITE_MOUSE_OUT;
        }
        //Mouse is inside button
        else
        {
            //Set mouse over sprite
            switch( e-&gt;type )
            {
                case SDL_MOUSEMOTION:
                mCurrentSprite = BUTTON_SPRITE_MOUSE_OVER_MOTION;
                break;

                case SDL_MOUSEBUTTONDOWN:
                mCurrentSprite = BUTTON_SPRITE_MOUSE_DOWN;
                break;

                case SDL_MOUSEBUTTONUP:
                mCurrentSprite = BUTTON_SPRITE_MOUSE_UP;
                break;
            }
        }
    }
}
</code></pre><p>Finally, we set the button sprite depending on whether the mouse is inside the button and the mouse event.</p>
<p>If the mouse isn&#39;t inside the button, we set the mouse out sprite. If the mouse is inside we set the sprite to mouse over on a mouse motion, mouse down on a mouse button press, and mouse up on a mouse button release.</p>
<pre><code>void LButton::render()
{
    //Show current button sprite
    gButtonSpriteSheetTexture.render( mPosition.x, mPosition.y, &amp;gSpriteClips[ mCurrentSprite ] );
}
</code></pre><p>In the rendering function, we just render the current button sprite at the button position.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }

                    //Handle button events
                    for( int i = 0; i &lt; TOTAL_BUTTONS; ++i )
                    {
                        gButtons[ i ].handleEvent( &amp;e );
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render buttons
                for( int i = 0; i &lt; TOTAL_BUTTONS; ++i )
                {
                    gButtons[ i ].render();
                }

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>Here is our main loop. In the event loop, we handle the quit event and the events for all the buttons. In the rendering section, all the buttons are rendered to the screen.</p>
<p>There are also <a href="http://wiki.libsdl.org/SDL_MouseWheelEvent">mouse wheel events</a> which weren&#39;t covered here, but if you look at the documentation and play around with it it shouldn&#39;t be too hard to figure out.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/17_mouse_events/17_mouse_events.zip">here</a>.</p>
<h2 id="key-states">Key States</h2>
<p><img src="./res/18_preview.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>As we saw in the <a href="#mouse-events">mouse input tutorial</a>, there are ways to get the state of the input devices (mouse, keyboard, etc) other than using events. In this tutorial, we&#39;ll be remaking the <a href="#key-presses">keyboard input tutorial</a> using key states instead of events.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Current rendered texture
            LTexture* currentTexture = NULL;
</code></pre><p>Right before we enter the main loop, we declare a texture pointer to keep track of which texture we&#39;re rendering to the screen.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }
</code></pre><p>As you can see, we aren&#39;t checking for key events in the event loop. All our keyboard input is going to be handled with key states.</p>
<p>One important thing to know about how SDL handles key states is that you still need an event loop running. SDL&#39;s internal keystates are updated every time <a href="http://wiki.libsdl.org/SDL_PollEvent">SDL_PollEvent</a> is called, so make sure you polled all events on queue before checking key states.</p>
<pre><code>                //Set texture based on current keystate
                const Uint8* currentKeyStates = SDL_GetKeyboardState( NULL );
                if( currentKeyStates[ SDL_SCANCODE_UP ] )
                {
                    currentTexture = &amp;gUpTexture;
                }
                else if( currentKeyStates[ SDL_SCANCODE_DOWN ] )
                {
                    currentTexture = &amp;gDownTexture;
                }
                else if( currentKeyStates[ SDL_SCANCODE_LEFT ] )
                {
                    currentTexture = &amp;gLeftTexture;
                }
                else if( currentKeyStates[ SDL_SCANCODE_RIGHT ] )
                {
                    currentTexture = &amp;gRightTexture;
                }
                else
                {
                    currentTexture = &amp;gPressTexture;
                }
</code></pre><p>Here we set our texture that&#39;s going to be rendered. First we get a pointer to the array of key states using <a href="http://wiki.libsdl.org/SDL_GetKeyboardState">SDL_GetKeyboardState</a>. The state of all the keys are ordered by <a href="http://wiki.libsdl.org/SDL_Scancode">SDL_Scancode</a>. Scan codes are like the <a href="http://wiki.libsdl.org/SDL_Keycode">SDL_Keycode</a> values, only scan codes are designed to work with international keyboards. Depending on the keyboard layout, different letters might be in different places. Scan codes go off default physical position of the keys as opposed to where they might be on a specific keyboard.</p>
<p>All you have to do to check if a key is down is to check its state in the key state array. As you can see in the above code, if the key is down we set the current texture to the corresponding texture. If none of the keys are down, we set the default texture.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render current texture
                currentTexture-&gt;render( 0, 0 );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
        }
    }
</code></pre><p>Finally here we render the current texture to the screen.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/18_key_states/18_key_states.zip">here</a>.</p>
<h2 id="gamepads-and-joysticks">Gamepads and Joysticks</h2>
<p><img src="./res/19_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Just like with <a href="#mouse-events">mouse input</a> and <a href="#key-presses">keyboard input</a>, SDL has the ability to read input from a joystick/gamepad/game controller. In this tutorial we&#39;ll be making an arrow rotate based on the input of a joystick.</p>
<pre><code>//Analog joystick dead zone
const int JOYSTICK_DEAD_ZONE = 8000;
</code></pre><p>The way SDL handles analog sticks on a game controller is that it converts its position into a number between -32768 and 32767. This means a light tap could report a position of 1000+. We want to ignore light taps, so we want to create a dead zone where input from the joystick is ignored. This is why we define this constant and we&#39;ll see how it works later.</p>
<pre><code>//Game Controller 1 handler
SDL_Joystick* gGameController = NULL;
</code></pre><p>The data type for a game controller is <a href="http://wiki.libsdl.org/CategoryJoystick">SDL_Joystick</a>. Here we declare the global joystick handle we&#39;ll use to interact with the joystick.</p>
<pre><code>bool init()
{
    //Initialization flag
    bool success = true;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO | SDL_INIT_JOYSTICK ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
</code></pre><p>This is important.</p>
<p>Up until now, we&#39;ve been only initializing video so we can render to the screen. Now we need to initialize the joystick subsystem or reading from joystick won&#39;t work.</p>
<pre><code>        //Set texture filtering to linear
        if( !SDL_SetHint( SDL_HINT_RENDER_SCALE_QUALITY, &quot;1&quot; ) )
        {
            printf( &quot;Warning: Linear texture filtering not enabled!&quot; );
        }

        //Check for joysticks
        if( SDL_NumJoysticks() &lt; 1 )
        {
            printf( &quot;Warning: No joysticks connected!\n&quot; );
        }
        else
        {
            //Load joystick
            gGameController = SDL_JoystickOpen( 0 );
            if( gGameController == NULL )
            {
                printf( &quot;Warning: Unable to open game controller! SDL Error: %s\n&quot;, SDL_GetError() );
            }
        }
</code></pre><p>After initializing the joystick subsystem, we want to open our joystick. First we call <a href="http://wiki.libsdl.org/SDL_NumJoysticks">SDL_NumJoysticks</a> to check if there is at least one joystick connected. If there is, we call <a href="http://wiki.libsdl.org/SDL_JoystickOpen">SDL_JoystickOpen</a> to open the joystick at index 0. After the joystick is open, it will now report events to the SDL event queue.</p>
<pre><code>void close()
{
    //Free loaded images
    gArrowTexture.free();

    //Close game controller
    SDL_JoystickClose( gGameController );
    gGameController = NULL;

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>After we&#39;re done with the joystick, we close it with <a href="http://wiki.libsdl.org/SDL_JoystickClose">SDL_JoystickClosee</a>.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Normalized direction
            int xDir = 0;
            int yDir = 0;
</code></pre><p>For this demo, we want to keep track of the x and y direction. If the x equals -1, the joystick&#39;s x position is pointing left. If it is +1, the x position is pointing right. The y position for joysticks has positive being up and negative being down, so y = +1 is up and y = -1 is down. If x or y is 0, that means it&#39;s in the dead zone and is in the center.</p>
<pre><code>                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                    else if( e.type == SDL_JOYAXISMOTION )
                    {
                        //Motion on controller 0
                        if( e.jaxis.which == 0 )
                        {                        
                            //X axis motion
                            if( e.jaxis.axis == 0 )
                            {
                                //Left of dead zone
                                if( e.jaxis.value &lt; -JOYSTICK_DEAD_ZONE )
                                {
                                    xDir = -1;
                                }
                                //Right of dead zone
                                else if( e.jaxis.value &gt; JOYSTICK_DEAD_ZONE )
                                {
                                    xDir =  1;
                                }
                                else
                                {
                                    xDir = 0;
                                }
                            }
</code></pre><p>In our event loop, we check if the joystick has moved by checking for a <a href="http://wiki.libsdl.org/SDL_JoyAxisEvent">SDL_JoyAxisEvent</a>. The &quot;which&quot; variable says which controller the axis motion came from, and here we check that the event came from joystick 0.</p>
<p>Next we want to check whether it was a motion in the x direction or y direction, which the &quot;axis&quot; variable indicates. Typically, axis 0 is the x axis.</p>
<p>The &quot;value&quot; variable says what position the analog stick has on the axis. If the x position is less than the dead zone, the direction is set to negative. If the position is greater than the dead zone, the direction is set to positive. If it&#39;s in the dead zone, the direction is set to 0.</p>
<pre><code>                            //Y axis motion
                            else if( e.jaxis.axis == 1 )
                            {
                                //Below of dead zone
                                if( e.jaxis.value &lt; -JOYSTICK_DEAD_ZONE )
                                {
                                    yDir = -1;
                                }
                                //Above of dead zone
                                else if( e.jaxis.value &gt; JOYSTICK_DEAD_ZONE )
                                {
                                    yDir =  1;
                                }
                                else
                                {
                                    yDir = 0;
                                }
                            }
                        }
                    }
                }
</code></pre><p>Here we do the same thing again with the y axis, which is identified with the axis ID 1.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Calculate angle
                double joystickAngle = atan2( (double)yDir, (double)xDir ) * ( 180.0 / M_PI );

                //Correct angle
                if( xDir == 0 &amp;&amp; yDir == 0 )
                {
                    joystickAngle = 0;
                }
</code></pre><p>Before we render the arrow which will point in the direction the the analog stick is pushed, we need to calculate the angle. We do this using the cmath function atan2, which stands for arc tangent 2, AKA inverse tangent 2.</p>
<p>For those of you familiar with trigonometry, this is basically the inverse tangent function with some additional code inside that takes into account the which quadrant the values are coming from.</p>
<p>For those of you only familiar with geometry, just know you give it the y position and x position and it will give you the angle in radians. SDL wants rotation angles in degrees, so we have to convert the radians to degrees by multiplying it by 180 over Pi.</p>
<p>When both the x and y position are 0, we could get a garbage angle, so we correct the value to equal 0.</p>
<pre><code>                //Render joystick 8 way angle
                gArrowTexture.render( ( SCREEN_WIDTH - gArrowTexture.getWidth() ) / 2, ( SCREEN_HEIGHT - gArrowTexture.getHeight() ) / 2, NULL, joystickAngle );

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>Finally we render the arrow rotated on the screen.</p>
<p>There are other joystick events like <a href="http://wiki.libsdl.org/SDL_JoyButtonEvent">button presses</a>, <a href="http://wiki.libsdl.org/SDL_JoyHatEvent">pov hats</a>, and <a href="http://wiki.libsdl.org/SDL_JoyDeviceEvent">pluggin in or removing a controller</a>. They are fairly simple and you should be able to pick them up with some look at the documentation and experimentation.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/19_gamepads_and_joysticks/19_gamepads_and_joysticks.zip">here</a>.</p>
<h2 id="force-feedback">Force Feedback</h2>
<p><img src="./res/20_preview.png" alt=""></p>
<p><strong>Last Updated 3/2/14</strong></p>
<p>Now that we know how to how to <a href="#gamepads-and-joysticks">use joysticks with SDL</a>, we can now use the new haptics API to make the controller shake.</p>
<pre><code>//Game Controller 1 handler with force feedback
SDL_Joystick* gGameController = NULL;
SDL_Haptic* gControllerHaptic = NULL;
</code></pre><p>A haptic device is something that gives some sort of physical feedback. In this case, it makes the controller rumble. The datatype for a haptics device is intuitively named SDL_haptic.</p>
<pre><code>//Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO | SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
</code></pre><p>Like with the joysticks subsystem, you need to make sure to initialize the haptic specific subsystem in order to use haptics.</p>
<pre><code>        //Check for joysticks
        if( SDL_NumJoysticks() &lt; 1 )
        {
            printf( &quot;Warning: No joysticks connected!\n&quot; );
        }
        else
        {
            //Load joystick
            gGameController = SDL_JoystickOpen( 0 );
            if( gGameController == NULL )
            {
                printf( &quot;Warning: Unable to open game controller! SDL Error: %s\n&quot;, SDL_GetError() );
            }
            else
            {
                //Get controller haptic device
                gControllerHaptic = SDL_HapticOpenFromJoystick( gGameController );
                if( gControllerHaptic == NULL )
                {
                    printf( &quot;Warning: Controller does not support haptics! SDL Error: %s\n&quot;, SDL_GetError() );
                }
                else
                {
                    //Get initialize rumble
                    if( SDL_HapticRumbleInit( gControllerHaptic ) &lt; 0 )
                    {
                        printf( &quot;Warning: Unable to initialize rumble! SDL Error: %s\n&quot;, SDL_GetError() );
                    }
                }
            }
        }
</code></pre><p>After we initialize the joystick, we need to get the haptics device from the joystick using <a href="http://wiki.libsdl.org/SDL_HapticOpenFromJoystick">SDL_HapticOpenFromJoystick</a> on an opened joystick. If we manage to get the haptic device from controller we have to initialize the rumble using <a href="http://wiki.libsdl.org/SDL_HapticRumbleInit">SDL_HapticRumbleInit</a>.</p>
<pre><code>void close()
{
    //Free loaded images
    gSplashTexture.free();

    //Close game controller with haptics
    SDL_HapticClose( gControllerHaptic );
    SDL_JoystickClose( gGameController );
    gGameController = NULL;
    gControllerHaptic = NULL;

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>Once we&#39;re done with a haptic device, we call <a href="http://wiki.libsdl.org/SDL_HapticClose">SDL_HapticClose</a>.</p>
<pre><code>                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                    //Joystick button press
                    else if( e.type == SDL_JOYBUTTONDOWN )
                    {
                        //Play rumble at 75% strenght for 500 milliseconds
                        if( SDL_HapticRumblePlay( gControllerHaptic, 0.75, 500 ) != 0 )
                        {
                            printf( &quot;Warning: Unable to play rumble! %s\n&quot;, SDL_GetError() );
                        }
                    }
                }
</code></pre><p>To actually make the controller rumble, you need to make it play some sort of rumbling. The easiest way to make your controller shake is by calling <a href="http://wiki.libsdl.org/SDL_HapticRumblePlay">SDL_HapticRumblePlay</a>, which takes in the haptic device, strength in percentage, and duration of the rumble. Here we make the controller rumble at 75% strength for half a second whenever a <a href="http://wiki.libsdl.org/SDL_JoyButtonEvent">SDL_JoyButtonEvent</a> happens.</p>
<p>Now the SDL 2 haptics API has many more features not covered here including making custom effects, handling multi rumble devices, and handling haptic mice. You can check them out in the <a href="http://wiki.libsdl.org/CategoryForceFeedback">SDL 2 force feedback documentation</a>.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/20_force_feedback/20_force_feedback.zip">here</a>.</p>
<h2 id="sound-effects-and-music">Sound Effects and Music</h2>
<p><img src="./res/21_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Up until now we&#39;ve only been dealing with video and input. Most games made require some sort of sound and here we&#39;ll be using SDL_mixer to play audio for us.</p>
<pre><code>//Using SDL, SDL_image, SDL_mixer, standard IO, and strings
#include &lt;SDL.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;SDL_mixer.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
</code></pre><p><a href="http://www.libsdl.org/projects/SDL_mixer/">SDL_mixer</a> is a library we use to make audio playing easier (because it can get <a href="http://wiki.libsdl.org/CategoryAudio">complicated</a>). We have to set it up just like we set up <a href="#extension-libraries-and-loading-other-image-formats">SDL_image</a>. Like before, it&#39;s just a matter of having the headers files, library files, and binary files in the right place with your compiler configured to use them.</p>
<pre><code>//The music that will be played
Mix_Music *gMusic = NULL;

//The sound effects that will be used
Mix_Chunk *gScratch = NULL;
Mix_Chunk *gHigh = NULL;
Mix_Chunk *gMedium = NULL;
Mix_Chunk *gLow = NULL;
</code></pre><p>The SDL_mixer data type for music is <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_86.html">Mix_Music</a> and one for short sounds is <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_85.html">Mix_Chunk</a>. Here we declare pointers for the music and sound effects we&#39;ll be using.</p>
<pre><code>    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO | SDL_INIT_AUDIO ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
</code></pre><p>Since we&#39;re using music and sound effects, we need to initialize audio along with video for this demo.</p>
<pre><code>                //Initialize PNG loading
                int imgFlags = IMG_INIT_PNG;
                if( !( IMG_Init( imgFlags ) &amp; imgFlags ) )
                {
                    printf( &quot;SDL_image could not initialize! SDL_image Error: %s\n&quot;, IMG_GetError() );
                    success = false;
                }

                 //Initialize SDL_mixer
                if( Mix_OpenAudio( 44100, MIX_DEFAULT_FORMAT, 2, 2048 ) &lt; 0 )
                {
                    printf( &quot;SDL_mixer could not initialize! SDL_mixer Error: %s\n&quot;, Mix_GetError() );
                    success = false;
                }
</code></pre><p>To initialize SDL_mixer we need to call <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_11.html">Mix_OpenAudio</a>. The first argument sets the sound frequency, and 44100 is a standard frequency that works on most systems. The second argument determines the sample format, which again here we&#39;re using the default. The third argument is the number of hardware channels, and here we&#39;re using 2 channels for stereo. The last argument is the sample size, which determines the size of the chunks we use when playing sound. 2048 bytes (AKA 2 kilobyes) worked fine for me, but you may have to experiment with this value to minimize lag when playing sounds.</p>
<p>If there&#39;s any errors with SDL_mixer, they&#39;re reported with Mix_GetError.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load prompt texture
    if( !gPromptTexture.loadFromFile( &quot;21_sound_effects_and_music/prompt.png&quot; ) )
    {
        printf( &quot;Failed to load prompt texture!\n&quot; );
        success = false;
    }

    //Load music
    gMusic = Mix_LoadMUS( &quot;21_sound_effects_and_music/beat.wav&quot; );
    if( gMusic == NULL )
    {
        printf( &quot;Failed to load beat music! SDL_mixer Error: %s\n&quot;, Mix_GetError() );
        success = false;
    }

    //Load sound effects
    gScratch = Mix_LoadWAV( &quot;21_sound_effects_and_music/scratch.wav&quot; );
    if( gScratch == NULL )
    {
        printf( &quot;Failed to load scratch sound effect! SDL_mixer Error: %s\n&quot;, Mix_GetError() );
        success = false;
    }

    gHigh = Mix_LoadWAV( &quot;21_sound_effects_and_music/high.wav&quot; );
    if( gHigh == NULL )
    {
        printf( &quot;Failed to load high sound effect! SDL_mixer Error: %s\n&quot;, Mix_GetError() );
        success = false;
    }

    gMedium = Mix_LoadWAV( &quot;21_sound_effects_and_music/medium.wav&quot; );
    if( gMedium == NULL )
    {
        printf( &quot;Failed to load medium sound effect! SDL_mixer Error: %s\n&quot;, Mix_GetError() );
        success = false;
    }

    gLow = Mix_LoadWAV( &quot;21_sound_effects_and_music/low.wav&quot; );
    if( gLow == NULL )
    {
        printf( &quot;Failed to load low sound effect! SDL_mixer Error: %s\n&quot;, Mix_GetError() );
        success = false;
    }

    return success;
}
</code></pre><p>Here we load our splash texture and sound.</p>
<p>To load music we call <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_55.html">Mix_LoadMUS</a> and to load sound effect we call <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_19.html">Mix_LoadWAV</a>.</p>
<pre><code>void close()
{
    //Free loaded images
    gPromptTexture.free();

    //Free the sound effects
    Mix_FreeChunk( gScratch );
    Mix_FreeChunk( gHigh );
    Mix_FreeChunk( gMedium );
    Mix_FreeChunk( gLow );
    gScratch = NULL;
    gHigh = NULL;
    gMedium = NULL;
    gLow = NULL;

    //Free the music
    Mix_FreeMusic( gMusic );
    gMusic = NULL;

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    Mix_Quit();
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>When we&#39;re done with audio and want to free it, we call <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_56.html">Mix_FreeMusic</a> to free music and <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_24.html">Mix_FreeChunk</a> to free a sound effect. We call <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_10.html">Mix_Quit</a> to close down SDL_mixer.</p>
<pre><code>                    //Handle key press
                    else if( e.type == SDL_KEYDOWN )
                    {
                        switch( e.key.keysym.sym )
                        {
                            //Play high sound effect
                            case SDLK_1:
                            Mix_PlayChannel( -1, gHigh, 0 );
                            break;

                            //Play medium sound effect
                            case SDLK_2:
                            Mix_PlayChannel( -1, gMedium, 0 );
                            break;

                            //Play low sound effect
                            case SDLK_3:
                            Mix_PlayChannel( -1, gLow, 0 );
                            break;

                            //Play scratch sound effect
                            case SDLK_4:
                            Mix_PlayChannel( -1, gScratch, 0 );
                            break;
</code></pre><p>In the event loop, we play a sound effect when the 1, 2, 3, or 4 keys are pressed. The way to play a Mix_Chunk is by calling <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_28.html">Mix_PlayChannel</a>. The first argument is the channel you want to use to play it. Since we don&#39;t care which channel it comes out of, we set the channel to negative 1 which will use the nearest available channel. The second argument is the sound effect and last argument is the number of times to repeat the effect. We only want it to play once per button press, so we have it repeat 0 times.</p>
<p>A channel in this case is not the same as a hardware channel that can represent the left and right channel of a stereo system. Every sound effect that&#39;s played has a channel associated with it. When you want to pause or stop an effect that is playing, you can halt its channel.</p>
<pre><code>                            case SDLK_9:
                            //If there is no music playing
                            if( Mix_PlayingMusic() == 0 )
                            {
                                //Play the music
                                Mix_PlayMusic( gMusic, -1 );
                            }
                            //If music is being played
                            else
                            {
                                //If the music is paused
                                if( Mix_PausedMusic() == 1 )
                                {
                                    //Resume the music
                                    Mix_ResumeMusic();
                                }
                                //If the music is playing
                                else
                                {
                                    //Pause the music
                                    Mix_PauseMusic();
                                }
                            }
                            break;

                            case SDLK_0:
                            //Stop the music
                            Mix_HaltMusic();
                            break;
                        }
                    }
</code></pre><p>For this demo, we want to play/pause the music on a 9 keypress and stop the music on a 0 keypress.</p>
<p>When the 9 key pressed we first check if the music is not playing with <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_71.html">Mix_PlayingMusic</a>. If it isn&#39;t, we start the music with <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_57.html">Mix_PlayMusic</a>. The first argument is the music we want to play and the last argument is the number of times to repeat it. Negative 1 is a special value saying we want to loop it until it is stopped.</p>
<p>If there is music playing, we check if the music is paused using <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_72.html">Mix_PausedMusic</a>. If the music is paused, we resume it using <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_63.html">Mix_ResumeMusic</a>. If the music is not paused we pause it using <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_62.html">Mix_PauseMusic</a>.</p>
<p>When 0 is pressed, we stop music if it&#39;s playing using <a href="http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_67.html">Mix_HaltMusic</a>.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/21_sound_effects_and_music/21_sound_effects_and_music.zip">here</a>.</p>
<h2 id="timing">Timing</h2>
<p><img src="./res/22_preview.png" alt=""></p>
<p><strong>Last Updated 3/10/14</strong></p>
<p>Another important part of any sort of gaming API is the ability to handle time. In this tutorial we&#39;ll make a timer we can restart.</p>
<pre><code>//Using SDL, SDL_image, SDL_ttf, standard IO, strings, and string streams
#include &lt;SDL.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;SDL_ttf.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
</code></pre><p>For this tutorial we&#39;ll be using string streams and have to include the sstream header which should come standard with your C++ compiler.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Open the font
    gFont = TTF_OpenFont( &quot;22_timing/lazy.ttf&quot;, 28 );
    if( gFont == NULL )
    {
        printf( &quot;Failed to load lazy font! SDL_ttf Error: %s\n&quot;, TTF_GetError() );
        success = false;
    }
    else
    {
        //Set text color as black
        SDL_Color textColor = { 0, 0, 0, 255 };

        //Load prompt texture
        if( !gPromptTextTexture.loadFromRenderedText( &quot;Press Enter to Reset Start Time.&quot;, textColor ) )
        {
            printf( &quot;Unable to render prompt texture!\n&quot; );
            success = false;
        }
    }

    return success;
}
</code></pre><p>As mentioned in the <a href="#true-type-fonts">font rendering tutorial</a>, you want to minimize the amount of times you render text. We&#39;ll have a texture to prompt input and a texture to display the current time in milliseconds. The time texture changes every frame so we have to render that every frame, but the prompt texture doesn&#39;t change so we can render it once in the file loading function.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Set text color as black
            SDL_Color textColor = { 0, 0, 0, 255 };

            //Current time start time
            Uint32 startTime = 0;

            //In memory text stream
            std::stringstream timeText;
</code></pre><p>Before we enter the main loop we want to declare some variables. The two we want to pay attention to is the startTime variable (which is an Unsigned integer that&#39;s 32bits) and the timeText variable which is a string stream.</p>
<p>For those of you who have never used string streams, just know that they function like iostreams only instead of reading or writing to the console, they allow you to read and write to a string in memory. It&#39;ll be easier to see when we see them used further on in the program.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                    //Reset start time on return keypress
                    else if( e.type == SDL_KEYDOWN &amp;&amp; e.key.keysym.sym == SDLK_RETURN )
                    {
                        startTime = SDL_GetTicks();
                    }
                }
</code></pre><p>There&#39;s a function called <a href="http://wiki.libsdl.org/SDL_GetTicks">SDL_GetTicks</a> which returns the time since the program started in milliseconds. For this demo, we&#39;ll be having a timer that restarts every time we press the return key.</p>
<p>Remember how we initialized the start time to 0 at the start of the program? This means the timer&#39;s time is just the current time since the program started returned by SDL_GetTicks. If we were to restart the timer when SDL_GetTicks was at 5000 milliseconds (5 seconds), then at 10,000 milliseconds the current time - the start time would be 10000 minus 5000 would be 5000 milliseconds. So even though the timer contained by SDL_GetTicks hasn&#39;t restarted, we can have a timer keep track of a relative start time and reset its start time.</p>
<pre><code>                //Set text to be rendered
                timeText.str( &quot;&quot; );
                timeText &lt;&lt; &quot;Milliseconds since start time &quot; &lt;&lt; SDL_GetTicks() - startTime;
</code></pre><p>Here we&#39;re using our string stream. First we call str with an empty string to initialize it to be empty. Then we treat it like cout and print to it &quot;Milliseconds since start time &quot; and the current time minus the relative start time so it will print the time since we last started the timer.</p>
<pre><code>                //Render text
                if( !gTimeTextTexture.loadFromRenderedText( timeText.str().c_str(), textColor ) )
                {
                    printf( &quot;Unable to render time texture!\n&quot; );
                }
</code></pre><p>Now that we have the time in a string stream, we can get a string from it and use it to render the current time to a texture.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render textures
                gPromptTextTexture.render( ( SCREEN_WIDTH - gPromptTextTexture.getWidth() ) / 2, 0 );
                gTimeTextTexture.render( ( SCREEN_WIDTH - gPromptTextTexture.getWidth() ) / 2, ( SCREEN_HEIGHT - gPromptTextTexture.getHeight() ) / 2 );

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>Finally we render the prompt texture and the time texture to the screen.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/22_timing/22_timing.zip">here</a>.</p>
<h2 id="advanced-timers">Advanced Timers</h2>
<p><img src="./res/23_preview.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>Now that we&#39;ve made a <a href="#timing">basic timer with SDL</a>, it&#39;s time to make one that can start/stop/pause.</p>
<pre><code>//The application time based timer
class LTimer
{
    public:
        //Initializes variables
        LTimer();

        //The various clock actions
        void start();
        void stop();
        void pause();
        void unpause();

        //Gets the timer&#39;s time
        Uint32 getTicks();

        //Checks the status of the timer
        bool isStarted();
        bool isPaused();

    private:
        //The clock time when the timer started
        Uint32 mStartTicks;

        //The ticks stored when the timer was paused
        Uint32 mPausedTicks;

        //The timer status
        bool mPaused;
        bool mStarted;
};
</code></pre><p>For these new features, we&#39;re going to make a timer class. It has all the basic function to start/stop/pause/unpause the timer and check its status. In terms of data members, we have the start time like before, a variable to store the time when paused, and status flags to keep track of whether the timer is running or paused.</p>
<pre><code>LTimer::LTimer()
{
    //Initialize the variables
    mStartTicks = 0;
    mPausedTicks = 0;

    mPaused = false;
    mStarted = false;
}
</code></pre><p>Our constructor initializes the internal data members.</p>
<pre><code>void LTimer::start()
{
    //Start the timer
    mStarted = true;

    //Unpause the timer
    mPaused = false;

    //Get the current clock time
    mStartTicks = SDL_GetTicks();
    mPausedTicks = 0;
}
</code></pre><p>The start function sets the started and paused flags, gets the timer&#39;s start time and initializes the pause time to 0. For this timer, if we want to restart it we just call start again. Since we can start the timer if it is paused and/or running, we should make sure to clear out the paused data.</p>
<pre><code>void LTimer::stop()
{
    //Stop the timer
    mStarted = false;

    //Unpause the timer
    mPaused = false;

    //Clear tick variables
    mStartTicks = 0;
    mPausedTicks = 0;
}
</code></pre><p>The stop function basically reinitializes all the variables.</p>
<pre><code>void LTimer::pause()
{
    //If the timer is running and isn&#39;t already paused
    if( mStarted &amp;&amp; !mPaused )
    {
        //Pause the timer
        mPaused = true;

        //Calculate the paused ticks
        mPausedTicks = SDL_GetTicks() - mStartTicks;
        mStartTicks = 0;
    }
}
</code></pre><p>When pausing, we want to check if the timer is running because it doesn&#39;t make sense to pause a timer that hasn&#39;t started. If the timer is running, we set the pause flag, store the time when the timer was paused in mPausedTicks, and reset the start time.</p>
<pre><code>void LTimer::unpause()
{
    //If the timer is running and paused
    if( mStarted &amp;&amp; mPaused )
    {
        //Unpause the timer
        mPaused = false;

        //Reset the starting ticks
        mStartTicks = SDL_GetTicks() - mPausedTicks;

        //Reset the paused ticks
        mPausedTicks = 0;
    }
}
</code></pre><p>So when we unpause the timer, we want to make sure the timer is running and paused because we can&#39;t unpause a timer that&#39;s stopped or running. We set the paused flag to false and set the new start time.</p>
<p>Say if you start the timer when SDL_GetTicks() reports 5000 ms and then you pause it at 10000ms. This means the relative time at the time of pausing is 5000ms. If we were to unpause it when SDL_GetTicks was at 20000, the new start time would be 20000 - 5000ms or 15000ms. This way the relative time will still be 5000ms away from the current SDL_GetTicks time.</p>
<pre><code>Uint32 LTimer::getTicks()
{
    //The actual timer time
    Uint32 time = 0;

    //If the timer is running
    if( mStarted )
    {
        //If the timer is paused
        if( mPaused )
        {
            //Return the number of ticks when the timer was paused
            time = mPausedTicks;
        }
        else
        {
            //Return the current time minus the start time
            time = SDL_GetTicks() - mStartTicks;
        }
    }

    return time;
}
</code></pre><p>Getting the time is a little bit tricky since our timer can be running, paused, or stopped. If the timer is stopped, we just return the initial 0 value. If the timer is paused, we return the time stored when paused. If the timer is running and not paused, we return the time relative to when it started.</p>
<pre><code>bool LTimer::isStarted()
{
    //Timer is running and paused or unpaused
    return mStarted;
}

bool LTimer::isPaused()
{
    //Timer is running and paused
    return mPaused &amp;&amp; mStarted;
}
</code></pre><p>Here we have some acccessor functions to check the status of the timer.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Set text color as black
            SDL_Color textColor = { 0, 0, 0, 255 };

            //The application timer
            LTimer timer;

            //In memory text stream
            std::stringstream timeText;
</code></pre><p>Before we enter the main loop, we declare a timer object and a string stream to turn the time value into text.</p>
<pre><code>                    else if( e.type == SDL_KEYDOWN )
                    {
                        //Start/stop
                        if( e.key.keysym.sym == SDLK_s )
                        {
                            if( timer.isStarted() )
                            {
                                timer.stop();
                            }
                            else
                            {
                                timer.start();
                            }
                        }
                        //Pause/unpause
                        else if( e.key.keysym.sym == SDLK_p )
                        {
                            if( timer.isPaused() )
                            {
                                timer.unpause();
                            }
                            else
                            {
                                timer.pause();
                            }
                        }
                    }
</code></pre><p>When we press s key, we check if the timer is started. If it is, we stop it. If it isn&#39;t, we start it. When we press p, we check if the timer is paused. If it is, we unpause it. Otherwise we pause it.</p>
<pre><code>                //Set text to be rendered
                timeText.str( &quot;&quot; );
                timeText &lt;&lt; &quot;Seconds since start time &quot; &lt;&lt; ( timer.getTicks() / 1000.f ) ; 

                //Render text
                if( !gTimeTextTexture.loadFromRenderedText( timeText.str().c_str(), textColor ) )
                {
                    printf( &quot;Unable to render time texture!\n&quot; );
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render textures
                gStartPromptTexture.render( ( SCREEN_WIDTH - gStartPromptTexture.getWidth() ) / 2, 0 );
                gPausePromptTexture.render( ( SCREEN_WIDTH - gPausePromptTexture.getWidth() ) / 2, gStartPromptTexture.getHeight() );
                gTimeTextTexture.render( ( SCREEN_WIDTH - gTimeTextTexture.getWidth() ) / 2, ( SCREEN_HEIGHT - gTimeTextTexture.getHeight() ) / 2 );

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>Before we render, we write the current time to a string stream. The reason we divide it by 1000 is because we want seconds and there are 1000 milliseconds per second.</p>
<p>After that we render the text to a texture and then finally draw all the textures to the screen.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/23_advanced_timers/23_advanced_timers.zip">here</a>.</p>
<h2 id="calculating-frame-rate">Calculating Frame Rate</h2>
<p><img src="./res/24_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Now that we know <a href="#advanced-timers">how to make a timer with SDL</a> it&#39;s time to put it to use. We&#39;re going to use the timer to measure fps.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Set text color as black
            SDL_Color textColor = { 0, 0, 0, 255 };

            //The frames per second timer
            LTimer fpsTimer;

            //In memory text stream
            std::stringstream timeText;

            //Start counting frames per second
            int countedFrames = 0;
            fpsTimer.start();
</code></pre><p>In order to calculate the frames per second, we need to keep track of the number of frames rendered and the number of seconds passed. Before we enter the main loop, we start a timer used to calculate fps and declare a variable to keep track of the number of frames rendered.</p>
<pre><code>                //Calculate and correct fps
                float avgFPS = countedFrames / ( fpsTimer.getTicks() / 1000.f );
                if( avgFPS &gt; 2000000 )
                {
                    avgFPS = 0;
                }
</code></pre><p>To calculate frames per second, you just take the number of rendered frames and divide it by the seconds passed. Now it is possible for there to be a very small amount of time passed for the first frame and have it give us a really high fps. This is why we correct the value if it is really high.</p>
<pre><code>                //Set text to be rendered
                timeText.str( &quot;&quot; );
                timeText &lt;&lt; &quot;Average Frames Per Second &quot; &lt;&lt; avgFPS; 

                //Render text
                if( !gFPSTextTexture.loadFromRenderedText( timeText.str().c_str(), textColor ) )
                {
                    printf( &quot;Unable to render FPS texture!\n&quot; );
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render textures
                gFPSTextTexture.render( ( SCREEN_WIDTH - gFPSTextTexture.getWidth() ) / 2, ( SCREEN_HEIGHT - gFPSTextTexture.getHeight() ) / 2 );

                //Update screen
                SDL_RenderPresent( gRenderer );
                ++countedFrames;
</code></pre><p>After calculating the fps, we render the value as a texture to the screen. After we&#39;re done rendering the scene, we increment the frame counter.</p>
<p>Since this program is vsynced, it is probably going to report 60 fps. If you want to find out how much you hardware can do, just create a renderer without vsync.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/24_calculating_frame_rate/24_calculating_frame_rate.zip">here</a>.</p>
<h2 id="capping-frame-rate">Capping Frame Rate</h2>
<p><img src="./res/25_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Another thing we can do with <a href="#advanced-timers">SDL timers</a> is manually cap the frame rate. Here we&#39;ll disable vsync and maintain a maximum frame rate.</p>
<pre><code>//Screen dimension constants
const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;
const int SCREEN_FPS = 60;
const int SCREEN_TICKS_PER_FRAME = 1000 / SCREEN_FPS;
</code></pre><p>For this demo, we&#39;re going render our frame normally, but at the end of the frame we&#39;re going to wait until the frame time is completed. For example here, when you want to render at 60 fps you have to spend 16 and 2/3rd milliseconds per frame ( 1000ms / 60 frames ). This is why here we calculate the number of ticks per frame in milliseconds.</p>
<pre><code>            //Create renderer for window
            gRenderer = SDL_CreateRenderer( gWindow, -1, SDL_RENDERER_ACCELERATED );
</code></pre><p>As you can see, we&#39;re disabling VSync for this demo because we&#39;ll be manually capping the frame rate.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Set text color as black
            SDL_Color textColor = { 0, 0, 0, 255 };

            //The frames per second timer
            LTimer fpsTimer;

            //The frames per second cap timer
            LTimer capTimer;

            //In memory text stream
            std::stringstream timeText;

            //Start counting frames per second
            int countedFrames = 0;
            fpsTimer.start();
</code></pre><p>For this program we&#39;ll not only need a timer to <a href="#calculating-frame-rate">calculate the frame rate</a>, but also a timer to cap the frames per second. Here before we enter the main loop we declare some variables and start the fps calculator timer.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Start cap timer
                capTimer.start();
</code></pre><p>To cap the FPS we need to know how long the frame has taken to render which is why we start a timer at the beginning of each frame.</p>
<pre><code>                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Calculate and correct fps
                float avgFPS = countedFrames / ( fpsTimer.getTicks() / 1000.f );
                if( avgFPS &gt; 2000000 )
                {
                    avgFPS = 0;
                }

                //Set text to be rendered
                timeText.str( &quot;&quot; );
                timeText &lt;&lt; &quot;Average Frames Per Second (With Cap) &quot; &lt;&lt; avgFPS; 

                //Render text
                if( !gFPSTextTexture.loadFromRenderedText( timeText.str().c_str(), textColor ) )
                {
                    printf( &quot;Unable to render FPS texture!\n&quot; );
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render textures
                gFPSTextTexture.render( ( SCREEN_WIDTH - gFPSTextTexture.getWidth() ) / 2, ( SCREEN_HEIGHT - gFPSTextTexture.getHeight() ) / 2 );

                //Update screen
                SDL_RenderPresent( gRenderer );
                ++countedFrames;
</code></pre><p>Here we have frame rendering and fps calculation code from before.</p>
<pre><code>                //If frame finished early
                int frameTicks = capTimer.getTicks();
                if( frameTicks &lt; SCREEN_TICKS_PER_FRAME )
                {
                    //Wait remaining time
                    SDL_Delay( SCREEN_TICKS_PER_FRAME - frameTicks );
                }
            }
</code></pre><p>Finally here we have the code to cap the frame rate. First we get how many ticks the frame took to complete. If the number of ticks the frame took to execute is less than the ticks needed per frame, we then delay for the remaining time to prevent the application from running too fast.</p>
<p>There&#39;s a reason we&#39;ll be using VSync for these tutorials as opposed to manually capping the frame rate. When running this application, you&#39;ll notice that it runs slightly fast. Since we&#39;re using integers (because floating point numbers are not precise), the ticks per frame will be 16ms as opposed to the exact 16 2/3ms. This solution is more of a stop gap in case you have to deal with hardware that does not support VSync.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/25_capping_frame_rate/25_capping_frame_rate.zip">here</a>.</p>
<h2 id="motion">Motion</h2>
<p><img src="./res/26_preview.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>Now that we know how to render, handle input, and deal with time we now know everything we need move around things on the screen. Here we will do a basic program with a dot moving around.</p>
<pre><code>//The dot that will move around on the screen
class Dot
{
    public:
        //The dimensions of the dot
        static const int DOT_WIDTH = 20;
        static const int DOT_HEIGHT = 20;

        //Maximum axis velocity of the dot
        static const int DOT_VEL = 10;

        //Initializes the variables
        Dot();

        //Takes key presses and adjusts the dot&#39;s velocity
        void handleEvent( SDL_Event&amp; e );

        //Moves the dot
        void move();

        //Shows the dot on the screen
        void render();

    private:
        //The X and Y offsets of the dot
        int mPosX, mPosY;

        //The velocity of the dot
        int mVelX, mVelY;
};
</code></pre><p>Here is the class for the dot we&#39;re going to be moving around on the screen. It has some constants to define its dimensions and velocity. It has a constructor, an event handler, a function to move it every frame, and a function to render it. As for data members, it has variables for its x/y position and x/y velocity.</p>
<pre><code>Dot::Dot()
{
    //Initialize the offsets
    mPosX = 0;
    mPosY = 0;

    //Initialize the velocity
    mVelX = 0;
    mVelY = 0;
}
</code></pre><p>The constructor simply initializes the variables.</p>
<pre><code>void Dot::handleEvent( SDL_Event&amp; e )
{
    //If a key was pressed
    if( e.type == SDL_KEYDOWN &amp;&amp; e.key.repeat == 0 )
    {
        //Adjust the velocity
        switch( e.key.keysym.sym )
        {
            case SDLK_UP: mVelY -= DOT_VEL; break;
            case SDLK_DOWN: mVelY += DOT_VEL; break;
            case SDLK_LEFT: mVelX -= DOT_VEL; break;
            case SDLK_RIGHT: mVelX += DOT_VEL; break;
        }
    }
</code></pre><p>In our event handler we&#39;re going to set the velocity based on the key press.</p>
<p>You may be wondering why we don&#39;t simply just increase the positon when we press the key. If we were to say add to the x position every time we press the right key, we would have to repeatedly press the right key to keep it moving. By setting the velocity, we just have to press the key once.</p>
<p>If you&#39;re wondering why we&#39;re checking if the key repeat is 0, it&#39;s because key repeat is enabled by default and if you press and hold a key it will report multiple key presses. That means we have to check if the key press is the first one because we only care when the key was first pressed.</p>
<p>For those of you who haven&#39;t studied physics yet, velocity is the speed/direction of an object. If an object is moving right at 10 pixels per frame, it has a velocity of 10. If it is moving to the left at 10 pixel per frame, it has a velocity of -10. If the dot&#39;s velocity is 10, this means after 10 frames it will have moved 100 pixels over.</p>
<pre><code>    //If a key was released
    else if( e.type == SDL_KEYUP &amp;&amp; e.key.repeat == 0 )
    {
        //Adjust the velocity
        switch( e.key.keysym.sym )
        {
            case SDLK_UP: mVelY += DOT_VEL; break;
            case SDLK_DOWN: mVelY -= DOT_VEL; break;
            case SDLK_LEFT: mVelX += DOT_VEL; break;
            case SDLK_RIGHT: mVelX -= DOT_VEL; break;
        }
    }
}
</code></pre><p>When we release a key, we have to undo the velocity change when first pressed it. When we pressed right key, we added to the x velocity. When we release the right key here, we subtract from the x velocity to return it to 0.</p>
<pre><code>void Dot::move()
{
    //Move the dot left or right
    mPosX += mVelX;

    //If the dot went too far to the left or right
    if( ( mPosX &lt; 0 ) || ( mPosX + DOT_WIDTH &gt; SCREEN_WIDTH ) )
    {
        //Move back
        mPosX -= mVelX;
    }
</code></pre><p>Here&#39;s the function we call every frame to move the dot.</p>
<p>First we move the dot along the x axis based on its x velocity. After that we check if the dot moved off the screen. If it did, we then undo the movement along the x axis.</p>
<pre><code>    //Move the dot up or down
    mPosY += mVelY;

    //If the dot went too far up or down
    if( ( mPosY &lt; 0 ) || ( mPosY + DOT_HEIGHT &gt; SCREEN_HEIGHT ) )
    {
        //Move back
        mPosY -= mVelY;
    }
}
</code></pre><p>Then here we do the same for the y axis.</p>
<pre><code>void Dot::render()
{
    //Show the dot
    gDotTexture.render( mPosX, mPosY );
}
</code></pre><p>In the rendering function we render the dot texture at the dot&#39;s position.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //The dot that will be moving around on the screen
            Dot dot;
</code></pre><p>Before we enter the main loop we declare a dot object.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }

                    //Handle input for the dot
                    dot.handleEvent( e );
                }

                //Move the dot
                dot.move();

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render objects
                dot.render();

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>Finally here we use our dot in the main loop. In the event loop we handle events for the dot. After that we update the dot&#39;s position and then render it to the screen.</p>
<p>Now in this tutorial we&#39;re basing the velocity as amount moved per frame. In most games, the velocity is done per second. The reason were doing it per frame is that it is easier, but if you know physics it shouldn&#39;t be hard to update the dot&#39;s position based on time. If you don&#39;t know physics, just stick with per frame velocity for now.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/26_motion/26_motion.zip">here</a>.</p>
<h2 id="collision-detection">Collision Detection</h2>
<p><img src="./res/27_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>In games you often need to tell if two objects hit each other. For simple games, this is usually done with bounding box collision detection.<br>Collision boxes are a standard way to check collision between two objects. Two polygons are in collision when they are not separated.</p>
<p>Here we have two boxes that are not collided. As you can see, their x projections are on the bottom and their y projections are on the left:<br><img src="./res/27_xy_separation.png" alt=""></p>
<p>Here you see the boxes have collided along the y axis but they are separated on the x axis:<br><img src="./res/27_x_separation.png" alt=""></p>
<p>Here the boxes are collided on the x axis but they are separated on the y axis:<br><img src="./res/27_y_separation.png" alt=""></p>
<p>When there is no separation on any of the axes there is a collision:<br><a href="./res/27_collision.png">./res/27_collision.png</a></p>
<p>This form of collision detection where we try to find an axis where the objects are separated is called the separating axis test. If there is no separating axis, then the objects are colliding.</p>
<pre><code>//The dot that will move around on the screen
class Dot
{
    public:
        //The dimensions of the dot
        static const int DOT_WIDTH = 20;
        static const int DOT_HEIGHT = 20;

        //Maximum axis velocity of the dot
        static const int DOT_VEL = 10;

        //Initializes the variables
        Dot();

        //Takes key presses and adjusts the dot&#39;s velocity
        void handleEvent( SDL_Event&amp; e );

        //Moves the dot and checks collision
        void move( SDL_Rect&amp; wall );

        //Shows the dot on the screen
        void render();

    private:
        //The X and Y offsets of the dot
        int mPosX, mPosY;

        //The velocity of the dot
        int mVelX, mVelY;

        //Dot&#39;s collision box
        SDL_Rect mCollider;
};
</code></pre><p>Here is the dot from the <a href="#motion">motion tutorial</a> with some new features. The move function takes in a rectangle that is the collision box for the wall and the dot has a data member called mCollider to represent the collision box.</p>
<pre><code>//Starts up SDL and creates window
bool init();

//Loads media
bool loadMedia();

//Frees media and shuts down SDL
void close();

//Box collision detector
bool checkCollision( SDL_Rect a, SDL_Rect b );
</code></pre><p>We&#39;re also declaring a function to check collision between two boxes.</p>
<pre><code>Dot::Dot()
{
    //Initialize the offsets
    mPosX = 0;
    mPosY = 0;

    //Set collision box dimension
    mCollider.w = DOT_WIDTH;
    mCollider.h = DOT_HEIGHT;

    //Initialize the velocity
    mVelX = 0;
    mVelY = 0;
}
</code></pre><p>In the contructor we should make sure the collider&#39;s dimensions are set.</p>
<pre><code>void Dot::move( SDL_Rect&amp; wall )
{
    //Move the dot left or right
    mPosX += mVelX;
    mCollider.x = mPosX;

    //If the dot collided or went too far to the left or right
    if( ( mPosX &lt; 0 ) || ( mPosX + DOT_WIDTH &gt; SCREEN_WIDTH ) || checkCollision( mCollider, wall ) )
    {
        //Move back
        mPosX -= mVelX;
        mCollider.x = mPosX;
    }

    //Move the dot up or down
    mPosY += mVelY;
    mCollider.y = mPosY;

    //If the dot collided or went too far up or down
    if( ( mPosY &lt; 0 ) || ( mPosY + DOT_HEIGHT &gt; SCREEN_HEIGHT ) || checkCollision( mCollider, wall ) )
    {
        //Move back
        mPosY -= mVelY;
        mCollider.y = mPosY;
    }
}
</code></pre><p>Here is the new moving function that now checks if we hit the wall. It works much like before only now it makes the dot move back if we go off the screen or hit the wall.</p>
<p>First we move the dot along the x axis, but we also have to change the position of the collider. Whenever we change the dot&#39;s position, the collider&#39;s position has to follow. Then we check if the dot has gone off screen or hit the wall. If it does we move the dot back along the x axis. Finally, we do this again for motion on the y axis.</p>
<pre><code>bool checkCollision( SDL_Rect a, SDL_Rect b )
{
    //The sides of the rectangles
    int leftA, leftB;
    int rightA, rightB;
    int topA, topB;
    int bottomA, bottomB;

    //Calculate the sides of rect A
    leftA = a.x;
    rightA = a.x + a.w;
    topA = a.y;
    bottomA = a.y + a.h;

    //Calculate the sides of rect B
    leftB = b.x;
    rightB = b.x + b.w;
    topB = b.y;
    bottomB = b.y + b.h;
</code></pre><p>Here is where the collision detection happens. This code calculates the top/bottom and left/right of each of the collison boxes.</p>
<pre><code>    //If any of the sides from A are outside of B
    if( bottomA &lt;= topB )
    {
        return false;
    }

    if( topA &gt;= bottomB )
    {
        return false;
    }

    if( rightA &lt;= leftB )
    {
        return false;
    }

    if( leftA &gt;= rightB )
    {
        return false;
    }

    //If none of the sides from A are outside B
    return true;
}
</code></pre><p>Here is where we do our separating axis test. First we check the top and bottom of the boxes to see if they are separated along the y axis. Then we check the left/right to see if they are separated on the x axis. If there is any separation, then there is no collision and we return false. If we cannot find any separation, then there is a collision and we return true.</p>
<p>Note: SDL does have some <a href="https://wiki.libsdl.org/CategoryRect">built in collision detection functions</a>, but for this tutorial set we&#39;ll be hand rolling our own. Mainly because it&#39;s important to know how these work and secondly because if you can roll your own you can use your collision detection with SDL rendering, OpenGL, Direct3D, Mantle, Metal, or any other rendering API.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //The dot that will be moving around on the screen
            Dot dot;

            //Set the wall
            SDL_Rect wall;
            wall.x = 300;
            wall.y = 40;
            wall.w = 40;
            wall.h = 400;
</code></pre><p>Before we enter the main loop, we declare the dot and define the postion and dimensions of the wall.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }

                    //Handle input for the dot
                    dot.handleEvent( e );
                }

                //Move the dot and check collision
                dot.move( wall );

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render wall
                SDL_SetRenderDrawColor( gRenderer, 0x00, 0x00, 0x00, 0xFF );        
                SDL_RenderDrawRect( gRenderer, &amp;wall );

                //Render dot
                dot.render();

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>Here is our main loop with the dot handling events, moving while checking for collision against the wall and finally rendering the wall and the dot onto the screen.<br>These next two sections are for future reference. Odds are if you&#39;re reading this tutorial, you&#39;re a beginner and this stuff is way too advanced. This is more for down the road when you need to use more advanced collision detection.</p>
<p>Now when you&#39;re starting out and just want to make something simple like tetris, this sort of collision detection is fine. For something like a physics simulator things get much more complicated.</p>
<p>For something like a rigid body simulator, we have our logic do this every frame:<br>1) Apply all the forces to all the objects in the scene (gravity, wind, propulsion, etc).</p>
<p>2) Move the objects by applying the acceleration and velocity to the position.</p>
<p>3) Check collisions for all of the objects and create a set of contacts. A contact is a data structure that typically contains pointers to the two objects that are colliding, a normal vector from the first to the second object, and the amount the objects are penetrating.</p>
<p>4) Take the set of generated contacts and resolve the collisions. This typically involves checking for contacts again (within a limit) and resolving them.</p>
<p>Now if you&#39;re barely learning collision detection, this is out of your league for now. This would take an entire tutorial set (that I currently do not have time to make) to explain it. Not only that it involves vector math and physics which is beyond the scope of these tutorials. Just keep this in mind later on when you need games that have large amounts of colliding objects and are wondering how the over all structure for a physics engine works.<br>Another thing is that the boxes we have here are AABBs or axis aligned bounding boxes. This means they have sides that are aligned with the x and y axis. If you want to have boxes that are rotated, you can still use the separating axis test on OBBs (oriented bounding boxes). Instead of projecting the corners on the x and y axis, you project all of the corners of the boxes on the I and J axis for each of the boxes. You then check if the boxes are separated along each axis. You can extend this further for any type of polygon by projecting all of the corners of each axis along each of the polygon&#39;s axis to see if there is any separation. This all involves vector math and this as mentioned before is beyond the scope of this tutorial set.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/27_collision_detection/27_collision_detection.zip">here</a>.</p>
<h2 id="per-pixel-collision-detection">Per-pixel Collision Detection</h2>
<p><img src="./res/28_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Once you know how to <a href="#collision-detection">check collision between two rectangles</a>, you can check collision between any two images since all images are made out of rectangles.<br>Everything can be made out of rectangles in a video game, even this dot:<br><img src="./res/28_normal.jpg" alt=""></p>
<p>Don&#39;t see it? Let&#39;s zoom in:<br><img src="./res/28_big.jpg" alt=""></p>
<p>Still don&#39;t see it? How about now:<br><img src="./res/28_highlight.jpg" alt=""></p>
<p>Images are made out of pixels which are squares which are rectangles. To do per-pixel collision detection all we have to do is have each object have a set of box colliders and check collision of one set of collision boxes against another like so:<br><img src="./res/28_scan.gif" alt=""></p>
<pre><code>//The dot that will move around on the screen
class Dot
{
    public:
        //The dimensions of the dot
        static const int DOT_WIDTH = 20;
        static const int DOT_HEIGHT = 20;

        //Maximum axis velocity of the dot
        static const int DOT_VEL = 1;

        //Initializes the variables
        Dot( int x, int y );

        //Takes key presses and adjusts the dot&#39;s velocity
        void handleEvent( SDL_Event&amp; e );

        //Moves the dot and checks collision
        void move( std::vector&lt;SDL_Rect&gt;&amp; otherColliders );

        //Shows the dot on the screen
        void render();

        //Gets the collision boxes
        std::vector&lt;SDL_Rect&gt;&amp; getColliders();

    private:
        //The X and Y offsets of the dot
        int mPosX, mPosY;

        //The velocity of the dot
        int mVelX, mVelY;

        //Dot&#39;s collision boxes
        std::vector&lt;SDL_Rect&gt; mColliders;

        //Moves the collision boxes relative to the dot&#39;s offset
        void shiftColliders();
};
</code></pre><p>Here is our dot now with per-pixel collision detection. Its velocity is reduced to 1 pixel per frame to make the collision easier to see. The move function now takes in a vector of collision boxes so we can check two sets against each other. Since we&#39;re going to have two dots colliding, we need to be able to get the colliders so we have a function for that.</p>
<p>Instead of having a single collision box, we have a vector of colliders. We also have an internal function to shift the colliders to match the position of the dot.</p>
<pre><code>//Starts up SDL and creates window
bool init();

//Loads media
bool loadMedia();

//Frees media and shuts down SDL
void close();

//Box set collision detector
bool checkCollision( std::vector&lt;SDL_Rect&gt;&amp; a, std::vector&lt;SDL_Rect&gt;&amp; b );
</code></pre><p>Here we have our new collision detector that checks sets of collision boxes against each other.</p>
<pre><code>Dot::Dot( int x, int y )
{
    //Initialize the offsets
    mPosX = x;
    mPosY = y;

    //Create the necessary SDL_Rects
    mColliders.resize( 11 );

    //Initialize the velocity
    mVelX = 0;
    mVelY = 0;

    //Initialize the collision boxes&#39; width and height
    mColliders[ 0 ].w = 6;
    mColliders[ 0 ].h = 1;

    mColliders[ 1 ].w = 10;
    mColliders[ 1 ].h = 1;

    mColliders[ 2 ].w = 14;
    mColliders[ 2 ].h = 1;

    mColliders[ 3 ].w = 16;
    mColliders[ 3 ].h = 2;

    mColliders[ 4 ].w = 18;
    mColliders[ 4 ].h = 2;

    mColliders[ 5 ].w = 20;
    mColliders[ 5 ].h = 6;

    mColliders[ 6 ].w = 18;
    mColliders[ 6 ].h = 2;

    mColliders[ 7 ].w = 16;
    mColliders[ 7 ].h = 2;

    mColliders[ 8 ].w = 14;
    mColliders[ 8 ].h = 1;

    mColliders[ 9 ].w = 10;
    mColliders[ 9 ].h = 1;

    mColliders[ 10 ].w = 6;
    mColliders[ 10 ].h = 1;

    //Initialize colliders relative to position
    shiftColliders();
}
</code></pre><p>Just like before, we have to set the collider dimensions in the constructor. Only difference here is that we have multiple collision boxes to set.</p>
<pre><code>void Dot::move( std::vector&lt;SDL_Rect&gt;&amp; otherColliders )
{
    //Move the dot left or right
    mPosX += mVelX;
    shiftColliders();

    //If the dot collided or went too far to the left or right
    if( ( mPosX &lt; 0 ) || ( mPosX + DOT_WIDTH &gt; SCREEN_WIDTH ) || checkCollision( mColliders, otherColliders ) )
    {
        //Move back
        mPosX -= mVelX;
        shiftColliders();
    }

    //Move the dot up or down
    mPosY += mVelY;
    shiftColliders();

    //If the dot collided or went too far up or down
    if( ( mPosY &lt; 0 ) || ( mPosY + DOT_HEIGHT &gt; SCREEN_HEIGHT ) || checkCollision( mColliders, otherColliders ) )
    {
        //Move back
        mPosY -= mVelY;
        shiftColliders();
    }
}
</code></pre><p>This function is pretty much the same as before. Whenever we move the dot, we move the collider(s) with it. After we move the dot, we check if it went off screen or hit something. If it did, we move the dot back and move its colliders with it.</p>
<pre><code>void Dot::shiftColliders()
{
    //The row offset
    int r = 0;

    //Go through the dot&#39;s collision boxes
    for( int set = 0; set &lt; mColliders.size(); ++set )
    {
        //Center the collision box
        mColliders[ set ].x = mPosX + ( DOT_WIDTH - mColliders[ set ].w ) / 2;

        //Set the collision box at its row offset
        mColliders[ set ].y = mPosY + r;

        //Move the row offset down the height of the collision box
        r += mColliders[ set ].h;
    }
}

std::vector&amp; Dot::getColliders()
{
    return mColliders;
}
</code></pre><p>Don&#39;t worry too much about how shiftColliders works. It&#39;s a short hand way of mColliders[ 0 ].x = ..., mColliders[ 1 ].x = ..., etc and it works for this specific case. For your own per-pixel objects you&#39;ll have your own placing functions.</p>
<p>And after shiftColliders, have an accessor function to get the colliders.</p>
<pre><code>bool checkCollision( std::vector&lt;SDL_Rect&gt;&amp; a, std::vector&lt;SDL_Rect&gt;&amp; b )
{
    //The sides of the rectangles
    int leftA, leftB;
    int rightA, rightB;
    int topA, topB;
    int bottomA, bottomB;

    //Go through the A boxes
    for( int Abox = 0; Abox &lt; a.size(); Abox++ )
    {
        //Calculate the sides of rect A
        leftA = a[ Abox ].x;
        rightA = a[ Abox ].x + a[ Abox ].w;
        topA = a[ Abox ].y;
        bottomA = a[ Abox ].y + a[ Abox ].h;
</code></pre><p>Here in our collision detection function, we have a for loop that calculates the top/bottom/left/right of each collision box in object a.</p>
<pre><code>        //Go through the B boxes
        for( int Bbox = 0; Bbox &lt; b.size(); Bbox++ )
        {
            //Calculate the sides of rect B
            leftB = b[ Bbox ].x;
            rightB = b[ Bbox ].x + b[ Bbox ].w;
            topB = b[ Bbox ].y;
            bottomB = b[ Bbox ].y + b[ Bbox ].h;

            //If no sides from A are outside of B
            if( ( ( bottomA &lt;= topB ) || ( topA &gt;= bottomB ) || ( rightA &lt;= leftB ) || ( leftA &gt;= rightB ) ) == false )
            {
                //A collision is detected
                return true;
            }
        }
    }

    //If neither set of collision boxes touched
    return false;
}
</code></pre><p>We then calculate the top/bottom/left/right of each collision box in object b. We then check if there is no separating axis. If there no separating axis, we return true. If we get through both sets without a collision, we return false.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //The dot that will be moving around on the screen
            Dot dot( 0, 0 );

            //The dot that will be collided against
            Dot otherDot( SCREEN_WIDTH / 4, SCREEN_HEIGHT / 4 );
</code></pre><p>Before we go into the main loop we declare our dot and the other dot we&#39;ll be colliding against.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }

                    //Handle input for the dot
                    dot.handleEvent( e );
                }

                //Move the dot and check collision
                dot.move( otherDot.getColliders() );

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render dots
                dot.render();
                otherDot.render();

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>Once again in the main loop we handle events for the dot, move with collision check for the dot, and then finally we render our objects.<br>A questions I get asked a lot is how to make a function that loads an image and auto generates the set of collision boxes for per pixel collision detection. The answer is simple:</p>
<p>Don&#39;t.</p>
<p>In most games, you don&#39;t want 100% accuracy. The more collision boxes you have the more collision checks you have and the slower it is. What most games go for is close enough, like in Street Fighter:<br><img src="./res/28_street_fighter.png" alt=""></p>
<p>The results are not pixel perfect but they are close enough.</p>
<p>Also there&#39;s one optimization we could have done here. We could have had a bounding box for the dot that encapsulates all the other collision boxes and then checks that one first before getting to the per-pixel collison boxes. This does add one more collision detection, but since it is much more likely that two objects do not collide it will more likely save us additional collision detection. In games, this is usually done with a tree structure that has different levels of detail to allow for early outs to prevent unneeded checks at the per-pixel level. Like in previous tutorials, tree structures are outside the scope of these tutorials.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/28_per-pixel_collision_detection/28_per-pixel_collision_detection.zip">here</a>.</p>
<h2 id="circular-collision-detection">Circular Collision Detection</h2>
<p><img src="./res/29_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Along with collision boxes, circles are the most common form of collider. Here we&#39;ll be checking collision between two circles and a circle and a box.<br>Checking collision between two circles is easy. All you have to do is check whether the distance between the center of each circle is less than the sum of their radii (radii is the plural for radius).</p>
<p>For box/circle collision, you have to find the point on the collision box that is closest to the center of the circle. If that point is less than the radius of the circle, there is a collision.</p>
<pre><code>//A circle stucture
struct Circle
{
    int x, y;
    int r;
};
</code></pre><p>SDL has a built in rectangle structure, but we have to make our own circle structure with a position and radius.</p>
<pre><code>//The dot that will move around on the screen
class Dot
{
    public:
        //The dimensions of the dot
        static const int DOT_WIDTH = 20;
        static const int DOT_HEIGHT = 20;

        //Maximum axis velocity of the dot
        static const int DOT_VEL = 1;

        //Initializes the variables
        Dot( int x, int y );

        //Takes key presses and adjusts the dot&#39;s velocity
        void handleEvent( SDL_Event&amp; e );

        //Moves the dot and checks collision
        void move( SDL_Rect&amp; square, Circle&amp; circle );

        //Shows the dot on the screen
        void render();

        //Gets collision circle
        Circle&amp; getCollider();

    private:
        //The X and Y offsets of the dot
        int mPosX, mPosY;

        //The velocity of the dot
        int mVelX, mVelY;

        //Dot&#39;s collision circle
        Circle mCollider;

        //Moves the collision circle relative to the dot&#39;s offset
        void shiftColliders();
};
</code></pre><p>Here is the dot class from previous <a href="#collision-detection">collision detection tutorials</a> with some more additons. The move function takes in a circle and a rectangle to check collision against when moving. We also now have a circle collider instead of a rectangle collider.</p>
<pre><code>//Circle/Circle collision detector
bool checkCollision( Circle&amp; a, Circle&amp; b );

//Circle/Box collision detector
bool checkCollision( Circle&amp; a, SDL_Rect&amp; b );

//Calculates distance squared between two points
double distanceSquared( int x1, int y1, int x2, int y2 );
</code></pre><p>For this tutorial we have our collision detection functions for circle/circle and circle/rectangle collisions. We also have a function that calculates the distance between two points squared.</p>
<p>Using the distance squared instead of the distance is an optimization we&#39;ll go into more detail later.</p>
<pre><code>Dot::Dot( int x, int y )
{
    //Initialize the offsets
    mPosX = x;
    mPosY = y;

    //Set collision circle size
    mCollider.r = DOT_WIDTH / 2;

    //Initialize the velocity
    mVelX = 0;
    mVelY = 0;

    //Move collider relative to the circle
    shiftColliders();
}
</code></pre><p>The constructor takes in a position and initializes the colliders and velocity.</p>
<pre><code>void Dot::move( SDL_Rect&amp; square, Circle&amp; circle )
{
    //Move the dot left or right
    mPosX += mVelX;
    shiftColliders();

    //If the dot collided or went too far to the left or right
    if( ( mPosX - mCollider.r &lt; 0 ) || ( mPosX + mCollider.r &gt; SCREEN_WIDTH ) || checkCollision( mCollider, square ) || checkCollision( mCollider, circle ) )
    {
        //Move back
        mPosX -= mVelX;
        shiftColliders();
    }

    //Move the dot up or down
    mPosY += mVelY;
    shiftColliders();

    //If the dot collided or went too far up or down
    if( ( mPosY - mCollider.r &lt; 0 ) || ( mPosY + mCollider.r &gt; SCREEN_HEIGHT ) || checkCollision( mCollider, square ) || checkCollision( mCollider, circle ) )
    {
        //Move back
        mPosY -= mVelY;
        shiftColliders();
    }
}
</code></pre><p>Like in previous <a href="#per-pixel-collision-detection">collision detection tutorials</a>, we move along the x axis, check collision against the edges of the screen, and check against the other scene objects. If the dot hits something we move back. As always, whenever the dot moves its colliders move with it.</p>
<p>Then we do this again for the y axis.</p>
<pre><code>void Dot::render()
{
    //Show the dot
    gDotTexture.render( mPosX - mCollider.r, mPosY - mCollider.r );
}
</code></pre><p>The rendering code is a little different. SDL_Rects have their position at the top left where our circle structure has the position at the center. This means we need to offset the render position to the top left of the circle by subtracting the radius from the x and y position.</p>
<pre><code>bool checkCollision( Circle&amp; a, Circle&amp; b )
{
    //Calculate total radius squared
    int totalRadiusSquared = a.r + b.r;
    totalRadiusSquared = totalRadiusSquared * totalRadiusSquared;

    //If the distance between the centers of the circles is less than the sum of their radii
    if( distanceSquared( a.x, a.y, b.x, b.y ) &lt; ( totalRadiusSquared ) )
    {
        //The circles have collided
        return true;
    }

    //If not
    return false;
}
</code></pre><p>Here is our circle to circle collision detector. It simply checks if the distance squared between the centers is less than the sum of the radii squared. If it is, there is a collison.</p>
<p>Why are we using the distance squared as opposed to the plain distance? Because to calculate the distance involves a square root and calculating a square root is a relatively expensive operation. Fortunately if x &gt; y then x^2 &gt; y^2, so we can save a square root operation by just comparing the distance squared.</p>
<pre><code>bool checkCollision( Circle&amp; a, SDL_Rect&amp; b )
{
    //Closest point on collision box
    int cX, cY;

    //Find closest x offset
    if( a.x &lt; b.x )
    {
        cX = b.x;
    }
    else if( a.x &gt; b.x + b.w )
    {
        cX = b.x + b.w;
    }
    else
    {
        cX = a.x;
    }
</code></pre><p>To check if a box and circle collided we need to find the closest point on the box.</p>
<p>If the circle&#39;s center is to the left of the box, the x position of the closest point is on the left side of the box.<br><img src="./res/29_less.jpg" alt=""></p>
<p>If the circle&#39;s center is to the right of the box, the x position of the closest point is on the right side of the box.<br><img src="./res/29_greater.jpg" alt=""></p>
<p>If the circle&#39;s center is inside of the box, the x position of the closest point is the same as the x position of the circle.<br><img src="./res/29_equal.jpg" alt=""></p>
<pre><code>    //Find closest y offset
    if( a.y &lt; b.y )
    {
        cY = b.y;
    }
    else if( a.y &gt; b.y + b.h )
    {
        cY = b.y + b.h;
    }
    else
    {
        cY = a.y;
    }

    //If the closest point is inside the circle
    if( distanceSquared( a.x, a.y, cX, cY ) &lt; a.r * a.r )
    {
        //This box and the circle have collided
        return true;
    }

    //If the shapes have not collided
    return false;
}
</code></pre><p>Here we find the closest y position much like we did the x position. If the distance squared between the closest point on the box and the center of the circle is less than the circle&#39;s radius squared, then there is a collision.</p>
<pre><code>double distanceSquared( int x1, int y1, int x2, int y2 )
{
    int deltaX = x2 - x1;
    int deltaY = y2 - y1;
    return deltaX*deltaX + deltaY*deltaY;
}
</code></pre><p>Here is the distance squared function. It&#39;s just a distance calculation ( squareRoot( x^2 + y^2 ) ) without the square root.</p>
<pre><code>            //The dot that will be moving around on the screen
            Dot dot( Dot::DOT_WIDTH / 2, Dot::DOT_HEIGHT / 2 );
            Dot otherDot( SCREEN_WIDTH / 4, SCREEN_HEIGHT / 4 );

            //Set the wall
            SDL_Rect wall;
            wall.x = 300;
            wall.y = 40;
            wall.w = 40;
            wall.h = 400;
</code></pre><p>Before we enter the main loop we define the scene objects.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }

                    //Handle input for the dot
                    dot.handleEvent( e );
                }

                //Move the dot and check collision
                dot.move( wall, otherDot.getCollider() );

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render wall
                SDL_SetRenderDrawColor( gRenderer, 0x00, 0x00, 0x00, 0xFF );        
                SDL_RenderDrawRect( gRenderer, &amp;wall );

                //Render dots
                dot.render();
                otherDot.render();

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>Finally in our main loop we handle input, move the dot with collision check and render the scene objects to the screen.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/29_circular_collision_detection/29_circular_collision_detection.zip">here</a>.</p>
<h2 id="scrolling">Scrolling</h2>
<p><img src="./res/30_preview.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>Up until now we&#39;ve only been dealing with levels the size of the screen. With scrolling you can navigate through levels of any size by rendering everything relative to a camera.<br>The basic principle of scrolling is that you have a rectangle that functions as a camera:</p>
<p>And then you only render what&#39;s in the camera, which usually involves rendering things relative to the camera or only showing portions of objects inside the camera.</p>
<pre><code>//The dimensions of the level
const int LEVEL_WIDTH = 1280;
const int LEVEL_HEIGHT = 960;

//Screen dimension constants
const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;
</code></pre><p>Since the level is no longer the size of the screen we have to have a separate set of constants to define the level size.</p>
<pre><code>//The dot that will move around on the screen
class Dot
{
    public:
        //The dimensions of the dot
        static const int DOT_WIDTH = 20;
        static const int DOT_HEIGHT = 20;

        //Maximum axis velocity of the dot
        static const int DOT_VEL = 10;

        //Initializes the variables
        Dot();

        //Takes key presses and adjusts the dot&#39;s velocity
        void handleEvent( SDL_Event&amp; e );

        //Moves the dot
        void move();

        //Shows the dot on the screen relative to the camera
        void render( int camX, int camY );

        //Position accessors
        int getPosX();
        int getPosY();

    private:
        //The X and Y offsets of the dot
        int mPosX, mPosY;

        //The velocity of the dot
        int mVelX, mVelY;
};
</code></pre><p>This time the dot has to render relative to the camera, so its rendering function takes in a camera position.</p>
<pre><code>void Dot::move()
{
    //Move the dot left or right
    mPosX += mVelX;

    //If the dot went too far to the left or right
    if( ( mPosX &lt; 0 ) || ( mPosX + DOT_WIDTH &gt; LEVEL_WIDTH ) )
    {
        //Move back
        mPosX -= mVelX;
    }

    //Move the dot up or down
    mPosY += mVelY;

    //If the dot went too far up or down
    if( ( mPosY &lt; 0 ) || ( mPosY + DOT_HEIGHT &gt; LEVEL_HEIGHT ) )
    {
        //Move back
        mPosY -= mVelY;
    }
}
</code></pre><p>This time when moving the dot, we check if the dot moved off the level as opposed to checking if it moved off the screen since the screen is going to move around the level.</p>
<pre><code>void Dot::render( int camX, int camY )
{
    //Show the dot relative to the camera
    gDotTexture.render( mPosX - camX, mPosY - camY );
}
</code></pre><p>Now when we render objects to the screen, we render them relative to the camera by subtracting the camera offset.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //The dot that will be moving around on the screen
            Dot dot;

            //The camera area
            SDL_Rect camera = { 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT };
</code></pre><p>Before we go into the main loop, we declare the dot and the camera that is going to be following it.</p>
<pre><code>                //Move the dot
                dot.move();

                //Center the camera over the dot
                camera.x = ( dot.getPosX() + Dot::DOT_WIDTH / 2 ) - SCREEN_WIDTH / 2;
                camera.y = ( dot.getPosY() + Dot::DOT_HEIGHT / 2 ) - SCREEN_HEIGHT / 2;

                //Keep the camera in bounds
                if( camera.x &lt; 0 )
                { 
                    camera.x = 0;
                }
                if( camera.y &lt; 0 )
                {
                    camera.y = 0;
                }
                if( camera.x &gt; LEVEL_WIDTH - camera.w )
                {
                    camera.x = LEVEL_WIDTH - camera.w;
                }
                if( camera.y &gt; LEVEL_HEIGHT - camera.h )
                {
                    camera.y = LEVEL_HEIGHT - camera.h;
                }
</code></pre><p>After we move the dot, we want to change the camera position to center over it. We don&#39;t want the camera to go outside of the level so we keep it in bounds after moving it.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render background
                gBGTexture.render( 0, 0, &amp;camera );

                //Render objects
                dot.render( camera.x, camera.y );

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>After the camera is in place we render the portion of the background that is inside that camera and then render the dot relative to the camera position.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/30_scrolling/30_scrolling.zip">here</a>.</p>
<h2 id="scrolling-backgrounds">Scrolling Backgrounds</h2>
<p><img src="./res/31_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Often times in games you may want an infinite or looping background. With scrolling backgrounds, you can cycle a background that goes on forever.<br>Say if we want to move around a dot an a infinite background:<br><img src="./res/31_scrolling.gif" alt=""></p>
<p>All we have to do is render two iterations of the background next to each other and move them a little every frame. When the background have moved completely over, you can reset the motion:<br><img src="./res/31_looping.gif" alt=""></p>
<pre><code>//The dot that will move around on the screen
class Dot
{
    public:
        //The dimensions of the dot
        static const int DOT_WIDTH = 20;
        static const int DOT_HEIGHT = 20;

        //Maximum axis velocity of the dot
        static const int DOT_VEL = 10;

        //Initializes the variables
        Dot();

        //Takes key presses and adjusts the dot&#39;s velocity
        void handleEvent( SDL_Event&amp; e );

        //Moves the dot
        void move();

        //Shows the dot on the screen
        void render();

    private:
        //The X and Y offsets of the dot
        int mPosX, mPosY;

        //The velocity of the dot
        int mVelX, mVelY;
};
</code></pre><p>For this tutorial we&#39;ll be using a plain version of the dot that just stays on screen.</p>
<pre><code>            //The dot that will be moving around on the screen
            Dot dot;

            //The background scrolling offset
            int scrollingOffset = 0;
</code></pre><p>Before we enter the main loop we declare a Dot object and the scrolling offset.</p>
<pre><code>                //Move the dot
                dot.move();

                //Scroll background
                --scrollingOffset;
                if( scrollingOffset &lt; -gBGTexture.getWidth() )
                {
                    scrollingOffset = 0;
                }
</code></pre><p>Here we&#39;re updating the dot and updating the scrolling background.</p>
<p>Updating the position of the scrolling background is just decrementing the x position and if the x position is less than the width of the background that means the background has gone completely off screen and the position needs to be reset.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render background
                gBGTexture.render( scrollingOffset, 0 );
                gBGTexture.render( scrollingOffset + gBGTexture.getWidth(), 0 );

                //Render objects
                dot.render();

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>Here we&#39;re rendering the background and the dot. First we render the scrolling background by rendering two iterations of the texture next to each other and then we render the dot over it. This will give us the effect of a smooth scrolling infinite background.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/31_scrolling_backgrounds/31_scrolling_backgrounds.zip">here</a>.</p>
<h2 id="text-input-and-clipboard-handling">Text Input And Clipboard Handling</h2>
<p><img src="./res/32_preview.png" alt=""></p>
<p><strong>Last Updated 6/24/19</strong></p>
<p>Getting text input from the keyboard is a common task in games. Here we&#39;ll be getting text using SDL 2&#39;s new text input and clipboard handling.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Set text color as black
            SDL_Color textColor = { 0, 0, 0, 0xFF };

            //The current input text.
            std::string inputText = &quot;Some Text&quot;;
            gInputTextTexture.loadFromRenderedText( inputText.c_str(), textColor );

            //Enable text input
            SDL_StartTextInput();
</code></pre><p>Before we go into the main loop we declare a string to hold our text and render it to a texture. We then call <a href="http://wiki.libsdl.org/SDL_StartTextInput">SDL_StartTextInput</a> so the SDL text input functionality is enabled.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //The rerender text flag
                bool renderText = false;

                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
</code></pre><p>We only want to update the input text texture when we need to so we have a flag that keeps track of whether we need to update the texture.</p>
<pre><code>                    //Special key input
                    else if( e.type == SDL_KEYDOWN )
                    {
                        //Handle backspace
                        if( e.key.keysym.sym == SDLK_BACKSPACE &amp;&amp; inputText.length() &gt; 0 )
                        {
                            //lop off character
                            inputText.pop_back();
                            renderText = true;
                        }
                        //Handle copy
                        else if( e.key.keysym.sym == SDLK_c &amp;&amp; SDL_GetModState() &amp; KMOD_CTRL )
                        {
                            SDL_SetClipboardText( inputText.c_str() );
                        }
                        //Handle paste
                        else if( e.key.keysym.sym == SDLK_v &amp;&amp; SDL_GetModState() &amp; KMOD_CTRL )
                        {
                            inputText = SDL_GetClipboardText();
                            renderText = true;
                        }
                    }
</code></pre><p>There are a couple special key presses we want to handle. When the user presses backspace we want to remove the last character from the string.</p>
<p>When the user is holding control and presses c, we want to copy the current text to the clip board using <a href="http://wiki.libsdl.org/SDL_SetClipboardText">SDL_SetClipboardText</a>. You can check if the ctrl key is being held using <a href="http://wiki.libsdl.org/SDL_GetModState">SDL_GetModState</a>.</p>
<p>When the user does ctrl + v, we want to get the text from the clip board using <a href="http://wiki.libsdl.org/SDL_GetClipboardText">SDL_GetClipboardText</a>. Also notice that whenever we alter the contents of the string we set the text update flag.</p>
<pre><code>                    //Special text input event
                    else if( e.type == SDL_TEXTINPUT )
                    {
                        //Not copy or pasting
                        if( !( SDL_GetModState() &amp; KMOD_CTRL &amp;&amp; ( e.text.text[ 0 ] == &#39;c&#39; || e.text.text[ 0 ] == &#39;C&#39; || e.text.text[ 0 ] == &#39;v&#39; || e.text.text[ 0 ] == &#39;V&#39; ) ) )
                        {
                            //Append character
                            inputText += e.text.text;
                            renderText = true;
                        }
                    }
                }
</code></pre><p>With text input enabled, your key presses will also generate <a href="http://wiki.libsdl.org/SDL_TextInputEvent">SDL_TextInputEvents</a> which simplifies things like shift key and caps lock. Here we first want to check that we&#39;re not getting a ctrl and c/v event because we want to ignore those since they are already handled as keydown events. If it isn&#39;t a copy or paste event, we append the character to our input string.</p>
<pre><code>                //Rerender text if needed
                if( renderText )
                {
                    //Text is not empty
                    if( inputText != &quot;&quot; )
                    {
                        //Render new text
                        gInputTextTexture.loadFromRenderedText( inputText.c_str(), textColor );
                    }
                    //Text is empty
                    else
                    {
                        //Render space texture
                        gInputTextTexture.loadFromRenderedText( &quot; &quot;, textColor );
                    }
                }
</code></pre><p>If the text render update flag has been set, we rerender the texture. One little hack we have here is if we have an empty string, we render a space because SDL_ttf will not render an empty string.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render text textures
                gPromptTextTexture.render( ( SCREEN_WIDTH - gPromptTextTexture.getWidth() ) / 2, 0 );
                gInputTextTexture.render( ( SCREEN_WIDTH - gInputTextTexture.getWidth() ) / 2, gPromptTextTexture.getHeight() );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>At the end of the main loop we render the prompt text and the input text.</p>
<pre><code>            //Disable text input
            SDL_StopTextInput();
</code></pre><p>Once we&#39;re done with text input we disable it since enabling text input introduces some overhead.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/32_text_input_and_clipboard_handling/32_text_input_and_clipboard_handling.zip">here</a>.</p>
<h2 id="file-reading-and-writing">File Reading and Writing</h2>
<p><img src="./res/33_preview.png" alt=""></p>
<p><strong>Last Updated 1/09/19</strong></p>
<p>Being able to save and load data is needed to keep data between play sessions. SDL_RWops file handling allows us to do cross platform file IO to save data.</p>
<pre><code>//Data points
Sint32 gData[ TOTAL_DATA ];
</code></pre><p>Here we&#39;re declaring an array of Signed integers that are 32 bits long. This will be the data we will be loading and saving. For this demo this array will be of length 10.</p>
<pre><code>    //Open file for reading in binary
    SDL_RWops* file = SDL_RWFromFile( &quot;33_file_reading_and_writing/nums.bin&quot;, &quot;r+b&quot; );
</code></pre><p>In our media loading function we&#39;re opening the save file for reading using <a href="http://wiki.libsdl.org/SDL_RWFromFile">SDL_RWFromFile</a>. The first argument is the path to the file and the second argument defines how we will be opening it. &quot;r+b&quot; means it is being opened for reading in binary.</p>
<pre><code>    //File does not exist
    if( file == NULL )
    {
        printf( &quot;Warning: Unable to open file! SDL Error: %s\n&quot;, SDL_GetError() );

        //Create file for writing
        file = SDL_RWFromFile( &quot;33_file_reading_and_writing/nums.bin&quot;, &quot;w+b&quot; );
</code></pre><p>Now if the file does not exist that doesn&#39;t exactly mean an error. It could mean this is the first time the program has run and the file has not been created yet. If the file does not exist we prompt a warning and create a file by opening a file with &quot;w+b&quot;. This will open a new file for writing in binary.</p>
<pre><code>        if( file != NULL )
        {
            printf( &quot;New file created!\n&quot; );

            //Initialize data
            for( int i = 0; i &lt; TOTAL_DATA; ++i )
            {
                gData[ i ] = 0;    
                SDL_RWwrite( file, &amp;gData[ i ], sizeof(Sint32), 1 );
            }

            //Close file handler
            SDL_RWclose( file );
        }
        else
        {
            printf( &quot;Error: Unable to create file! SDL Error: %s\n&quot;, SDL_GetError() );
            success = false;
        }
    }
</code></pre><p>If a new file was created successfully we then start writing the initialized data to it using <a href="http://wiki.libsdl.org/SDL_RWwrite">SDL_RWwrite</a>. The first argument is the file we&#39;re writing to, the second argument is the address of the objects in memory we&#39;re writing, the third argument is the number of bytes per object we&#39;re writing, and the last one is the number of objects we&#39;re writing. After we&#39;re done writing out all the objects, we close the file for writing using <a href="http://wiki.libsdl.org/SDL_RWclose">SDL_RWclose</a>.</p>
<p>If the file was never created in the first place, we report an error to the console and set the success flag to false.</p>
<pre><code>    //File exists
    else
    {
        //Load data
        printf( &quot;Reading file...!\n&quot; );
        for( int i = 0; i &lt; TOTAL_DATA; ++i )
        {
            SDL_RWread( file, &amp;gData[ i ], sizeof(Sint32), 1 );
        }

        //Close file handler
        SDL_RWclose( file );
    }
</code></pre><p>Now if our file loaded successfully on the first try, all we have to do is reading in the data using <a href="http://wiki.libsdl.org/SDL_RWread">SDL_RWread</a>, which basically functions like SDL_RWwrite but in reverse.</p>
<pre><code>    //Initialize data textures
    gDataTextures[ 0 ].loadFromRenderedText( std::to_string( gData[ 0 ] ), highlightColor );
    for( int i = 1; i &lt; TOTAL_DATA; ++i )
    {
        gDataTextures[ i ].loadFromRenderedText( std::to_string( gData[ i ] ), textColor );
    }
</code></pre><p>After the file is loaded we render the text textures that correspond with each of our data numbers. Our <a href="#true-type-fonts">loadFromRenderedText</a> function only accepts strings so we have to convert the integers to strings.</p>
<pre><code>void close()
{
    //Open data for writing
    SDL_RWops* file = SDL_RWFromFile( &quot;33_file_reading_and_writing/nums.bin&quot;, &quot;w+b&quot; );
    if( file != NULL )
    {
        //Save data
        for( int i = 0; i &lt; TOTAL_DATA; ++i )
        {
            SDL_RWwrite( file, &amp;gData[ i ], sizeof(Sint32), 1 );
        }

        //Close file handler
        SDL_RWclose( file );
    }
    else
    {
        printf( &quot;Error: Unable to save file! %s\n&quot;, SDL_GetError() );
    }
</code></pre><p>When we close the program, we open up the file again for writing and write out all the data.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Text rendering color
            SDL_Color textColor = { 0, 0, 0, 0xFF };
            SDL_Color highlightColor = { 0xFF, 0, 0, 0xFF };

            //Current input point
            int currentData = 0;
</code></pre><p>Before we go into the main loop we declare currentData to keep track of which of our data integers we&#39;re altering. We also declare a plain text color and a highlight color for rendering text.</p>
<pre><code>                    else if( e.type == SDL_KEYDOWN )
                    {
                        switch( e.key.keysym.sym )
                        {
                            //Previous data entry
                            case SDLK_UP:
                            //Rerender previous entry input point
                            gDataTextures[ currentData ].loadFromRenderedText( std::to_string( gData[ currentData ] ), textColor );
                            --currentData;
                            if( currentData &lt; 0 )
                            {
                                currentData = TOTAL_DATA - 1;
                            }

                            //Rerender current entry input point
                            gDataTextures[ currentData ].loadFromRenderedText( std::to_string( gData[ currentData ] ), highlightColor );
                            break;

                            //Next data entry
                            case SDLK_DOWN:
                            //Rerender previous entry input point
                            gDataTextures[ currentData ].loadFromRenderedText( std::to_string( gData[ currentData ] ), textColor );
                            ++currentData;
                            if( currentData == TOTAL_DATA )
                            {
                                currentData = 0;
                            }

                            //Rerender current entry input point
                            gDataTextures[ currentData ].loadFromRenderedText( std::to_string( gData[ currentData ] ), highlightColor );
                            break;
</code></pre><p>When we press up or down we want to rerender the the old current data in plain color, move to the next data point (with some bounds checking), and rerender the new current data in the highlight color.</p>
<pre><code>                            //Decrement input point
                            case SDLK_LEFT:
                            --gData[ currentData ];
                            gDataTextures[ currentData ].loadFromRenderedText( std::to_string( gData[ currentData ] ), highlightColor );
                            break;

                            //Increment input point
                            case SDLK_RIGHT:
                            ++gData[ currentData ];
                            gDataTextures[ currentData ].loadFromRenderedText( std::to_string( gData[ currentData ] ), highlightColor );
                            break;
                        }
                    }
</code></pre><p>When we press left or right we decrement or increment the current data and rerender the texture associated with it.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render text textures
                gPromptTextTexture.render( ( SCREEN_WIDTH - gPromptTextTexture.getWidth() ) / 2, 0 );
                for( int i = 0; i &lt; TOTAL_DATA; ++i )
                {
                    gDataTextures[ i ].render( ( SCREEN_WIDTH - gDataTextures[ i ].getWidth() ) / 2, gPromptTextTexture.getHeight() + gDataTextures[ 0 ].getHeight() * i );
                }

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>At the end of the main loop we render all the textures to the screen.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/33_file_reading_and_writing/33_file_reading_and_writing.zip">here</a>.</p>
<h2 id="audio-recording">Audio Recording</h2>
<p><img src="./res/34_preview.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>There&#39;s more than you can do with audio than just hit play. This tutorial will cover some of the basics audio programming recording and playback.</p>
<p>Also, <strong>make sure you&#39;re using the latest version of SDL</strong>. I had to upgrade to SDL 2.0.8 to get audio recording to work properly.<br>To understand how audio recording works, it helps to understand how audio data works.</p>
<p>This is a song:<br><img src="./res/34_song.png" alt=""></p>
<p>Now, let&#39;s zoom in on it:<br><img src="./res/34_song_zoomed.png" alt=""></p>
<p>As you can see, sound is a wave. A wave can be represented by a sequence of values (or in the case of this stereo song, two sequences with one for each sound wave). Playing audio is just sending a sequence of values to the audio driver and recording audio is copying a sequence of values from the audio driver.</p>
<pre><code>//Maximum number of supported recording devices
const int MAX_RECORDING_DEVICES = 10;

//Maximum recording time
const int MAX_RECORDING_SECONDS = 5;

//Maximum recording time plus padding
const int RECORDING_BUFFER_SECONDS = MAX_RECORDING_SECONDS + 1;

//The various recording actions we can take
enum RecordingState
{
    SELECTING_DEVICE,
    STOPPED,
    RECORDING,
    RECORDED,
    PLAYBACK,
    ERROR
};
</code></pre><p>Here are a couple constants we&#39;ll be using.</p>
<p>First there&#39;s constant defining that we&#39;ll only support up to 10 recording devices to choose from (we only need one for this program to work). Then we have the maximum time we allow for recording and the maximum time we can store in the buffer. We&#39;ll be recording for 5 seconds, but we allow for 6 seconds of recording for the sake of padding in case the application records 5.1 seconds or so.</p>
<p>Lastly we have a set of enumerations for the different states in the program. First the user can select a recording device. Then after the user selects a device, the user is stopped waiting to start the recording. Then the user starts the recording for 5 seconds. After the user has finished recording, the can either playback or record again. If anything results in an error, it will go in an error state.</p>
<p>Typically in these tutorials we go down the source code explaining what everything means along the way, but in this tutorial we are going to jump around more by flow of execution. It makes things easier to understand than just going the source files. So don&#39;t get lost as we jump around in the source file.</p>
<pre><code>//Recording/playback callbacks
void audioRecordingCallback( void* userdata, Uint8* stream, int len );
void audioPlaybackCallback( void* userdata, Uint8* stream, int len );
</code></pre><p>These two callbacks are going to be doing the actual recording to and playing from our audio buffer. We&#39;ll get into details on how these work later.</p>
<pre><code>//Prompt texture
LTexture gPromptTexture;

//The text textures that specify recording device names
LTexture gDeviceTextures[ MAX_RECORDING_DEVICES ];

//Number of available devices
int gRecordingDeviceCount = 0;

//Recieved audio spec
SDL_AudioSpec gReceivedRecordingSpec;
SDL_AudioSpec gReceivedPlaybackSpec;
</code></pre><p>Here we have some textures. One to prompt the user to let them know what&#39;s going on and another array of textures to store the names of the recording devices. We also have an integer to keep track of how many devices we have available.</p>
<p>We also have two <a href="https://wiki.libsdl.org/SDL_AudioSpec">SDL_AudioSpec</a> variables. An SDL_AudioSpec is an audio specification which basically defines how audio is recorded or played back. When we open an audio device for recording or playing, we request a specification but we may not get what we requested back because the audio driver does not support it. This is why we are going to store the specification we get back from the driver for recording and playback.</p>
<pre><code>//Recording data buffer
Uint8* gRecordingBuffer = NULL;

//Size of data buffer
Uint32 gBufferByteSize = 0;

//Position in data buffer
Uint32 gBufferBytePosition = 0;

//Maximum position in data buffer for recording
Uint32 gBufferByteMaxPosition = 0;
</code></pre><p>The &quot;gRecordingBuffer&quot; is a buffer of unsigned bytes that&#39;ll store our audio data. &quot;gBufferByteSize&quot; will store how many bytes the buffer will hold. &quot;gBufferBytePosition&quot; controls where we are in the buffer during recording or playback. &quot;gBufferByteMaxPosition&quot; controls the maximum piece of the buffer we will be using.</p>
<p>If that&#39;s confusing, remember that &quot;gBufferByteSize&quot; is 6 seconds of bytes (5 seconds + 1 second of padding) and &quot;gBufferByteMaxPosition&quot; is 5 seconds of bytes we&#39;ll be using.</p>
<pre><code>    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO | SDL_INIT_AUDIO ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
</code></pre><p>Make sure to remember to <strong>initialize audio before recording or playback</strong>. It&#39;s an easy thing to forget.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Open the font
    gFont = TTF_OpenFont( &quot;34_audio_recording/lazy.ttf&quot;, 28 );
    if( gFont == NULL )
    {
        printf( &quot;Failed to load lazy font! SDL_ttf Error: %s\n&quot;, TTF_GetError() );
        success = false;
    }
    else
    {
        //Set starting prompt 
        gPromptTexture.loadFromRenderedText( &quot;Select your recording device:&quot;, gTextColor );

        //Get capture device count
        gRecordingDeviceCount = SDL_GetNumAudioDevices( SDL_TRUE );

        //No recording devices
        if( gRecordingDeviceCount &lt; 1 )
        {
            printf( &quot;Unable to get audio capture device! SDL Error: %s\n&quot;, SDL_GetError() );
            success = false;
        }
</code></pre><p>After loading the font and rendering the initial prompt message we get the number of available recording devices using <a href="https://wiki.libsdl.org/SDL_GetNumAudioDevices">SDL_GetNumAudioDevices</a>. When you pass in a SDL_TRUE argument it will give us the number of recording devices. With SDL_FALSE, it will give us playback devices.</p>
<p>If there isn&#39;t at least one recording devices connected, we error out of the function.</p>
<pre><code>        //At least one device connected
        else
        {
            //Cap recording device count
            if( gRecordingDeviceCount &gt; MAX_RECORDING_DEVICES )
            {
                gRecordingDeviceCount = MAX_RECORDING_DEVICES;
            }

            //Render device names
            std::stringstream promptText;
            for( int i = 0; i &lt; gRecordingDeviceCount; ++i )
            {
                //Get capture device name
                promptText.str( &quot;&quot; );
                promptText &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; SDL_GetAudioDeviceName( i, SDL_TRUE );

                //Set texture from name
                gDeviceTextures[ i ].loadFromRenderedText( promptText.str().c_str(), gTextColor );
            }
        }
    }

    return success;
}
</code></pre><p>If there are recording devices connected, we cap the number we use to 10 (which may dissapoint those with 11 microphones hooked up to their PC) and then go through the devices rendering their names to a texture. We get the device name using <a href="https://wiki.libsdl.org/SDL_GetAudioDeviceName">SDL_GetAudioDeviceName</a> and passing in the fact that we want recording device names with SDL_TRUE and the index of the recording device.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Set the default recording state
            RecordingState currentState = SELECTING_DEVICE;

            //Audio device IDs
            SDL_AudioDeviceID recordingDeviceId = 0;
            SDL_AudioDeviceID playbackDeviceId = 0;
</code></pre><p>In the main function after initializing and loading we set the initial recording state and declare two audio device IDs which are just integers to represent the recording and playback devices.</p>
<pre><code>                    //Do current state event handling
                    switch( currentState )
                    {
                        //User is selecting recording device
                        case SELECTING_DEVICE:

                            //On key press
                            if( e.type == SDL_KEYDOWN )
                            {
                                //Handle key press from 0 to 9 
                                if( e.key.keysym.sym &gt;= SDLK_0 &amp;&amp; e.key.keysym.sym &lt;= SDLK_9 )
                                {
                                    //Get selection index
                                    int index = e.key.keysym.sym - SDLK_0;
</code></pre><p>In the event handling loop we have a switch statement that handles the different states. When the user presses 0-9, we convert it to an index which is easy because the SDLK constants are sequential and can be converted by subtracting the keysym by SDLK_0.</p>
<pre><code>                                    //Index is valid
                                    if( index &lt; gRecordingDeviceCount )
                                    {
                                        //Default audio spec
                                        SDL_AudioSpec desiredRecordingSpec;
                                        SDL_zero(desiredRecordingSpec);
                                        desiredRecordingSpec.freq = 44100;
                                        desiredRecordingSpec.format = AUDIO_F32;
                                        desiredRecordingSpec.channels = 2;
                                        desiredRecordingSpec.samples = 4096;
                                        desiredRecordingSpec.callback = audioRecordingCallback;

                                        //Open recording device
                                        recordingDeviceId = SDL_OpenAudioDevice( SDL_GetAudioDeviceName( index, SDL_TRUE ), SDL_TRUE, &amp;desiredRecordingSpec, &amp;gReceivedRecordingSpec, SDL_AUDIO_ALLOW_FORMAT_CHANGE );
</code></pre><p>If the user pressed a valid index key, we then specify the recording audio spec.</p>
<p>First we initialize the audio spec with SDL_zero. Always initialize memory before using it. Ask the SREs that had to deal with the heartbleed bug what happens when you don&#39;t.</p>
<p>We set the frequency to 44.1 khz which is CD quality. We&#39;re using 32bit floating point format for the data. We have 2 channels since we want stereo. Samples are set to 4096 because that&#39;s a pretty standard size. Lastly we give it the audio recording callback.</p>
<p>With the spec set, we call <a href="https://wiki.libsdl.org/SDL_OpenAudioDevice">SDL_OpenAudioDevice</a> and pass in the recording device name, the fact that we want a recording device with SDL_TRUE, the spec we want to have, a pointer the the spec we get back from the driver, and lastly a flag that says we&#39;re ok with SDL_OpenAudioDevice giving us a different format than we requested.</p>
<pre><code>                                        //Device failed to open
                                        if( recordingDeviceId == 0 )
                                        {
                                            //Report error
                                            printf( &quot;Failed to open recording device! SDL Error: %s&quot;, SDL_GetError() );
                                            gPromptTexture.loadFromRenderedText( &quot;Failed to open recording device!&quot;, gTextColor );
                                            currentState = ERROR;
                                        }
                                        //Device opened successfully
                                        else
                                        {
                                            //Default audio spec
                                            SDL_AudioSpec desiredPlaybackSpec;
                                            SDL_zero(desiredPlaybackSpec);
                                            desiredPlaybackSpec.freq = 44100;
                                            desiredPlaybackSpec.format = AUDIO_F32;
                                            desiredPlaybackSpec.channels = 2;
                                            desiredPlaybackSpec.samples = 4096;
                                            desiredPlaybackSpec.callback = audioPlaybackCallback;

                                            //Open playback device
                                            playbackDeviceId = SDL_OpenAudioDevice( NULL, SDL_FALSE, &amp;desiredPlaybackSpec, &amp;gReceivedPlaybackSpec, SDL_AUDIO_ALLOW_FORMAT_CHANGE );
</code></pre><p>If we get no device ID, we go to an error state. If the device opened successfully, we create a playback spec that&#39;s mostly the same as the recording spec. The major difference is that it uses the playback callback instead of the recording callback.</p>
<p>Opening the playback device is also mostly the same. For this tutorial, we don&#39;t care which playback device we get so we pass in NULL to grab the first available one. Secondly, we pass in SDL_FALSE for the second argument to open up a playback device instead of a recording device.</p>
<pre><code>                                            //Device failed to open
                                            if( playbackDeviceId == 0 )
                                            {
                                                //Report error
                                                printf( &quot;Failed to open playback device! SDL Error: %s&quot;, SDL_GetError() );
                                                gPromptTexture.loadFromRenderedText( &quot;Failed to open playback device!&quot;, gTextColor );
                                                currentState = ERROR;
                                            }
                                            //Device opened successfully
                                            else
                                            {
                                                //Calculate per sample bytes
                                                int bytesPerSample = gReceivedRecordingSpec.channels * ( SDL_AUDIO_BITSIZE( gReceivedRecordingSpec.format ) / 8 );

                                                //Calculate bytes per second
                                                int bytesPerSecond = gReceivedRecordingSpec.freq * bytesPerSample;

                                                //Calculate buffer size
                                                gBufferByteSize = RECORDING_BUFFER_SECONDS * bytesPerSecond;

                                                //Calculate max buffer use
                                                gBufferByteMaxPosition = MAX_RECORDING_SECONDS * bytesPerSecond;

                                                //Allocate and initialize byte buffer
                                                gRecordingBuffer = new Uint8[ gBufferByteSize ];
                                                memset( gRecordingBuffer, 0, gBufferByteSize );

                                                //Go on to next state
                                                gPromptTexture.loadFromRenderedText(&quot;Press 1 to record for 5 seconds.&quot;, gTextColor);
                                                currentState = STOPPED;
                                            }
                                        }
                                    }
                                }
                            }
                            break;
</code></pre><p>If we get no playback device ID, we go to an error state. If the device opened successfully, we create a byte buffer to to hold the audio data we&#39;ll be recording and playing back.</p>
<p>To calculate how much space we need first we need to calculate the bytes per sample. If we have 2 channels and 32 bits per channel sample (which we can get using <a href="https://wiki.libsdl.org/SDL_AudioFormat">SDL_AUDIO_BITSIZE</a> on the audio format), we&#39;ll get 2 channels * ( 32 bits / 8 bits per byte ) which is 8 bytes per sample.</p>
<p>To get the bytes per second, we multiply the bytes per sample times the frequency which is the number sample per second. 8 bytes per sample * 44100 samples per seconds get us 705600 bytes per second.</p>
<p>We want to have 6 seconds of buffer (5 seconds + 1 second of padding) so we set the buffer size to be 4233600 bytes. That seems like a lot, but it&#39;s a litle more than 4 megabytes. Remember, because of the max position, we only use 5 seconds of the 6 second buffer.</p>
<p>After calculating the buffer size, we allocate the buffer and initialize it with memset. Finally, we set the prompt texture and move on to the next state.</p>
<pre><code>                        //User getting ready to record
                        case STOPPED:

                            //On key press
                            if( e.type == SDL_KEYDOWN )
                            {
                                //Start recording
                                if( e.key.keysym.sym == SDLK_1 )
                                {
                                    //Go back to beginning of buffer
                                    gBufferBytePosition = 0;

                                    //Start recording
                                    SDL_PauseAudioDevice( recordingDeviceId, SDL_FALSE );

                                    //Go on to next state
                                    gPromptTexture.loadFromRenderedText( &quot;Recording...&quot;, gTextColor );
                                    currentState = RECORDING;
                                }
                            }
                            break;
</code></pre><p>After we&#39;ve allocated the buffer, we&#39;re ready to start recording. If the user presses 1, we set the buffer position back to 0 and unpause the audio device using <a href="https://wiki.libsdl.org/SDL_PauseAudioDevice">SDL_PauseAudioDevice</a>. The first argument is the device we want to pause/unpause and the second argument determines whether we want to pause or unpause. Passing SDL_FALSE will unpause a device.</p>
<p><strong>Audio devices are paused be default</strong> meaning they will not record or play until you unpause them. If you&#39;re wondering why your callback isn&#39;t doing anything, this may be why.</p>
<pre><code>void audioRecordingCallback( void* userdata, Uint8* stream, int len )
{
    //Copy audio from stream
    memcpy( &amp;gRecordingBuffer[ gBufferBytePosition ], stream, len );

    //Move along buffer
    gBufferBytePosition += len;
}
</code></pre><p>When the recording device is unpaused it will start calling the recording callback we gave it at regular intervals.</p>
<p>As you can see it doesn&#39;t do much. All it does is copy bytes from the device stream into the current position in our recording buffer and then move the position in the buffer. That is all recording is, just grabbing chunks of audio data. Just remember that &quot;len&quot; is the size of the chunk from the stream in bytes.</p>
<pre><code>                //Updating recording
                if( currentState == RECORDING )
                {
                    //Lock callback
                    SDL_LockAudioDevice( recordingDeviceId );

                    //Finished recording
                    if( gBufferBytePosition &gt; gBufferByteMaxPosition )
                    {
                        //Stop recording audio
                        SDL_PauseAudioDevice( recordingDeviceId, SDL_TRUE );

                        //Go on to next state
                        gPromptTexture.loadFromRenderedText( &quot;Press 1 to play back. Press 2 to record again.&quot;, gTextColor );
                        currentState = RECORDED;
                    }

                    //Unlock callback
                    SDL_UnlockAudioDevice( recordingDeviceId );
                }
</code></pre><p>Here we&#39;re jumping to the update part of the main loop. When we&#39;re recording, we need to check whether we&#39;ve filled the 5 seconds of buffer. Before we can check the buffer position we have to call <a href="https://wiki.libsdl.org/SDL_LockAudioDevice">SDL_LockAudioDevice</a>. The thing is, the callback is being run in another thread and we don&#39;t want to have two threads accessing the same variable at the same time. SDL_LockAudioDevice stops the callback from being called while we need to access the buffer position which the callback also manipulates.</p>
<p>Once the recording device is locked, we check if the buffer position is past 5 seconds of data. If it is, we pause the recording device to halt recording and we move on to the next state. Lastly, we call <a href="https://wiki.libsdl.org/SDL_UnlockAudioDevice">SDL_UnlockAudioDevice</a> so if there&#39;s still data to record the recording device can continue.</p>
<p>This is a very simple example of multithreading. If you would like to know more on the subject you can check tutorials on <a href="#multithreading">multithreading</a>, <a href="#semaphores">semaphores</a>, and <a href="#mutexes-and-conditions">mutexes</a>.</p>
<pre><code>                        //User has finished recording
                        case RECORDED:

                            //On key press
                            if( e.type == SDL_KEYDOWN )
                            {
                                //Start playback
                                if( e.key.keysym.sym == SDLK_1 )
                                {
                                    //Go back to beginning of buffer
                                    gBufferBytePosition = 0;

                                    //Start playback
                                    SDL_PauseAudioDevice( playbackDeviceId, SDL_FALSE );

                                    //Go on to next state
                                    gPromptTexture.loadFromRenderedText( &quot;Playing...&quot;, gTextColor );
                                    currentState = PLAYBACK;
                                }
</code></pre><p>Here we&#39;re jumping back to event handling for after we recorded 5 seconds.</p>
<p>As you can see, it&#39;s similar to when we started recording. We set the buffer position back to the beginning, unpause the playback device, and set the next state.</p>
<pre><code>void audioPlaybackCallback( void* userdata, Uint8* stream, int len )
{
    //Copy audio to stream
    memcpy( stream, &amp;gRecordingBuffer[ gBufferBytePosition ], len );

    //Move along buffer
    gBufferBytePosition += len;
}
</code></pre><p>The playback callback is also similar to the recording callback. The key difference here is that instead of copying from the device to the buffer, we&#39;re taking the data we recorded in the buffer and copying it back to the device.</p>
<pre><code>                //Updating playback
                else if( currentState == PLAYBACK )
                {
                    //Lock callback
                    SDL_LockAudioDevice( playbackDeviceId );

                    //Finished playback
                    if( gBufferBytePosition &gt; gBufferByteMaxPosition )
                    {
                        //Stop playing audio
                        SDL_PauseAudioDevice( playbackDeviceId, SDL_TRUE );

                        //Go on to next state
                        gPromptTexture.loadFromRenderedText( &quot;Press 1 to play back. Press 2 to record again.&quot;, gTextColor );
                        currentState = RECORDED;
                    }

                    //Unlock callback
                    SDL_UnlockAudioDevice( playbackDeviceId );
                }
</code></pre><p>Updating playback is again similar to recording. We lock the playback device, check the playback position, stop playback if the buffer position is past the end point, and unlock the playback device.</p>
<pre><code>                                //Record again
                                if( e.key.keysym.sym == SDLK_2 )
                                {
                                    //Reset the buffer
                                    gBufferBytePosition = 0;
                                    memset( gRecordingBuffer, 0, gBufferByteSize );

                                    //Start recording
                                    SDL_PauseAudioDevice( recordingDeviceId, SDL_FALSE );

                                    //Go on to next state
                                    gPromptTexture.loadFromRenderedText( &quot;Recording...&quot;, gTextColor );
                                    currentState = RECORDING;
                                }
                            }
                            break;
                    }
</code></pre><p>Jumping back to event handling for after the user has recorded, we allow for the user to rerecord. When we want to record again, we just jump the buffer position back to the beginning, initialize the buffer, and unpause the recording device.</p>
<pre><code>void close()
{
    //Free textures
    gPromptTexture.free();
    for( int i = 0; i &lt; MAX_RECORDING_DEVICES; ++i )
    {
        gDeviceTextures[ i ].free();
    }

    //Free global font
    TTF_CloseFont( gFont );
    gFont = NULL;

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Free playback audio
    if( gRecordingBuffer != NULL )
    {
        delete[] gRecordingBuffer;
        gRecordingBuffer = NULL;
    }

    //Quit SDL subsystems
    TTF_Quit();
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>As always, don&#39;t forget to deallocate the buffer after using it to prevent memory leaks.</p>
<p>Now, audio programming is a very large field which I am by no means an expert in. However, now that you know how to handle raw audio data, you can look into using audio libraries and frameworks to do more complicated things like audio compression and voice chat.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/34_audio_recording/34_audio_recording.zip">here</a>.</p>
<h2 id="window-events">Window Events</h2>
<p><img src="./res/35_preview.png" alt=""></p>
<p><strong>Last Updated 4/28/14</strong></p>
<p>SDL also supports resizable windows. When you have resizable windows there are additional events to handle, which is what we&#39;ll be doing here.</p>
<pre><code>class LWindow
{
    public:
        //Intializes internals
        LWindow();

        //Creates window
        bool init();

        //Creates renderer from internal window
        SDL_Renderer* createRenderer();

        //Handles window events
        void handleEvent( SDL_Event&amp; e );

        //Deallocates internals
        void free();

        //Window dimensions
        int getWidth();
        int getHeight();

        //Window focii
        bool hasMouseFocus();
        bool hasKeyboardFocus();
        bool isMinimized();

    private:
        //Window data
        SDL_Window* mWindow;

        //Window dimensions
        int mWidth;
        int mHeight;

        //Window focus
        bool mMouseFocus;
        bool mKeyboardFocus;
        bool mFullScreen;
        bool mMinimized;
};
</code></pre><p>Here is our window class we&#39;ll be using as a wrapper for the SDL_Window. It has a constructor, a initializer that creates the window, a function to create renderer from the window, an event handler, a deallocator, and some accessor functions to get various attributes from the window.</p>
<p>In terms of data members, we have the window we&#39;re wrapping, the dimensions of the window, and flags for the types of focus the windows has. We&#39;ll go into more detail further in the program.</p>
<pre><code>//Our custom window
LWindow gWindow;

//The window renderer
SDL_Renderer* gRenderer = NULL;

//Scene textures
LTexture gSceneTexture;
</code></pre><p>We&#39;ll be using our window as a global object.</p>
<pre><code>LWindow::LWindow()
{
    //Initialize non-existant window
    mWindow = NULL;
    mMouseFocus = false;
    mKeyboardFocus = false;
    mFullScreen = false;
    mMinimized = false;
    mWidth = 0;
    mHeight = 0;
}
</code></pre><p>In the constructor we initialize all our variables.</p>
<pre><code>bool LWindow::init()
{
    //Create window
    mWindow = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE );
    if( mWindow != NULL )
    {
        mMouseFocus = true;
        mKeyboardFocus = true;
        mWidth = SCREEN_WIDTH;
        mHeight = SCREEN_HEIGHT;
    }

    return mWindow != NULL;
}
</code></pre><p>Our initialization function creates the window with the <a href="http://wiki.libsdl.org/SDL_WindowFlags">SDL_WINDOW_RESIZABLE</a> flag which allows for our window to be resizable. If the function succeeds we set the corresponding flags and dimensions. Then we return whether the window is null or not.</p>
<pre><code>SDL_Renderer* LWindow::createRenderer()
{
    return SDL_CreateRenderer( mWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC );
}
</code></pre><p>Here we&#39;re handling the creation of a renderer from the member window. We&#39;re returning the created renderer because rendering will be handled outside of the class.</p>
<pre><code>void LWindow::handleEvent( SDL_Event&amp; e )
{
    //Window event occured
    if( e.type == SDL_WINDOWEVENT )
    {
        //Caption update flag
        bool updateCaption = false;
</code></pre><p>In our window&#39;s event handler we&#39;ll be looking for events of type <a href="http://wiki.libsdl.org/SDL_WindowEvent">SDL_WINDOWEVENT</a>. SDL_WindowEvents are actually a family of events. Depending on the event we may have to update the caption of the window, so we have a flag that keeps track of that.</p>
<pre><code>        switch( e.window.event )
        {
            //Get new dimensions and repaint on window size change
            case SDL_WINDOWEVENT_SIZE_CHANGED:
            mWidth = e.window.data1;
            mHeight = e.window.data2;
            SDL_RenderPresent( gRenderer );
            break;

            //Repaint on exposure
            case SDL_WINDOWEVENT_EXPOSED:
            SDL_RenderPresent( gRenderer );
            break;
</code></pre><p>When we have a window event we then want to check the <a href="http://wiki.libsdl.org/SDL_WindowEventID">SDL_WindowEventID</a> to see what type of event it is. An SDL_WINDOWEVENT_SIZE_CHANGED is a resize event, so we get the new dimensions and refresh the image on the screen.</p>
<p>An SDL_WINDOWEVENT_EXPOSED just means that window was obscured in some way and now is not obscured so we want to repaint the window.</p>
<pre><code>            //Mouse entered window
            case SDL_WINDOWEVENT_ENTER:
            mMouseFocus = true;
            updateCaption = true;
            break;

            //Mouse left window
            case SDL_WINDOWEVENT_LEAVE:
            mMouseFocus = false;
            updateCaption = true;
            break;

            //Window has keyboard focus
            case SDL_WINDOWEVENT_FOCUS_GAINED:
            mKeyboardFocus = true;
            updateCaption = true;
            break;

            //Window lost keyboard focus
            case SDL_WINDOWEVENT_FOCUS_LOST:
            mKeyboardFocus = false;
            updateCaption = true;
            break;
</code></pre><p>SDL_WINDOWEVENT_ENTER/SDL_WINDOWEVENT_LEAVE handles when the mouse moves into and out of the window. SDL_WINDOWEVENT_FOCUS_GAINED/SDL_WINDOWEVENT_FOCUS_LOST have to do when the window is getting input from the keyboard. Since our caption keeps track of mouse/keyboard focus, we set the update caption flag when any of these events happen.</p>
<pre><code>            //Window minimized
            case SDL_WINDOWEVENT_MINIMIZED:
            mMinimized = true;
            break;

            //Window maxized
            case SDL_WINDOWEVENT_MAXIMIZED:
            mMinimized = false;
            break;

            //Window restored
            case SDL_WINDOWEVENT_RESTORED:
            mMinimized = false;
            break;
        }
</code></pre><p>Finally here we handle when the window was minimized, maximized, or restored from being minimized.</p>
<pre><code>        //Update window caption with new data
        if( updateCaption )
        {
            std::stringstream caption;
            caption &lt;&lt; &quot;SDL Tutorial - MouseFocus:&quot; &lt;&lt; ( ( mMouseFocus ) ? &quot;On&quot; : &quot;Off&quot; ) &lt;&lt; &quot; KeyboardFocus:&quot; &lt;&lt; ( ( mKeyboardFocus ) ? &quot;On&quot; : &quot;Off&quot; );
            SDL_SetWindowTitle( mWindow, caption.str().c_str() );
        }
    }
</code></pre><p>If the caption needs to be updated, we load a string stream with the updated data and update the caption with <a href="http://wiki.libsdl.org/SDL_SetWindowTitle">SDL_SetWindowTitle</a>.</p>
<pre><code>    //Enter exit full screen on return key
    else if( e.type == SDL_KEYDOWN &amp;&amp; e.key.keysym.sym == SDLK_RETURN )
    {
        if( mFullScreen )
        {
            SDL_SetWindowFullscreen( mWindow, SDL_FALSE );
            mFullScreen = false;
        }
        else
        {
            SDL_SetWindowFullscreen( mWindow, SDL_TRUE );
            mFullScreen = true;
            mMinimized = false;
        }
    }
}
</code></pre><p>For this demo we&#39;ll be toggling fullscreen with the return key. We can set fullscreen mode using <a href="http://wiki.libsdl.org/SDL_SetWindowFullscreen">SDL_SetWindowFullscreen</a>.</p>
<pre><code>int LWindow::getWidth()
{
    return mWidth;
}

int LWindow::getHeight()
{
    return mHeight;
}

bool LWindow::hasMouseFocus()
{
    return mMouseFocus;
}

bool LWindow::hasKeyboardFocus()
{
    return mKeyboardFocus;
}

bool LWindow::isMinimized()
{
    return mMinimized;
}
</code></pre><p>Here is a quick rundown of the accessors we use.</p>
<pre><code>        //Create window
        if( !gWindow.init() )
        {
            printf( &quot;Window could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
            success = false;
        }
        else
        {
            //Create renderer for window
            gRenderer = gWindow.createRenderer();
            if( gRenderer == NULL )
            {
                printf( &quot;Renderer could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
                success = false;
            }
</code></pre><p>In our initialization function we create our window and renderer only this time with our window wrapper.</p>
<pre><code>void close()
{
    //Free loaded images
    gSceneTexture.free();

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    gWindow.free();

    //Quit SDL subsystems
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>In our clean up function we still deallocate our window and renderer.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }

                    //Handle window events
                    gWindow.handleEvent( e );
                }

                //Only draw when not minimized
                if( !gWindow.isMinimized() )
                {
                    //Clear screen
                    SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                    SDL_RenderClear( gRenderer );

                    //Render text textures
                    gSceneTexture.render( ( gWindow.getWidth() - gSceneTexture.getWidth() ) / 2, ( gWindow.getHeight() - gSceneTexture.getHeight() ) / 2 );

                    //Update screen
                    SDL_RenderPresent( gRenderer );
                }
            }
</code></pre><p>In the main loop we make sure to pass events to the window wrapper to handle resize events and in the rendering part of our code we make sure to only render when the window is not minimized because this can cause some bugs when we try to render to a minimized window.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/35_window_events/35_window_events.zip">here</a>.</p>
<h2 id="multiple-windows">Multiple Windows</h2>
<p><img src="./res/36_preview.png" alt=""></p>
<p><strong>Last Updated 4/29/14</strong></p>
<p>One of the new features SDL 2 has is being able to handle multiple windows at once. In this tutorial we&#39;ll be moving around 3 resizable windows.</p>
<pre><code>//Total windows
const int TOTAL_WINDOWS = 3;

class LWindow
{
    public:
        //Intializes internals
        LWindow();

        //Creates window
        bool init();

        //Handles window events
        void handleEvent( SDL_Event&amp; e );

        //Focuses on window
        void focus();

        //Shows windows contents
        void render();

        //Deallocates internals
        void free();

        //Window dimensions
        int getWidth();
        int getHeight();

        //Window focii
        bool hasMouseFocus();
        bool hasKeyboardFocus();
        bool isMinimized();
        bool isShown();

    private:
        //Window data
        SDL_Window* mWindow;
        SDL_Renderer* mRenderer;
        int mWindowID;

        //Window dimensions
        int mWidth;
        int mHeight;

        //Window focus
        bool mMouseFocus;
        bool mKeyboardFocus;
        bool mFullScreen;
        bool mMinimized;
        bool mShown;
};
</code></pre><p>Here is our <a href="#window-events">window wrapper from before</a> with a few adjustments. We want to be able to grab focus and we want to tell if the window is shown so we add functions to do that.</p>
<p>Each window is going to have their own renderer so we add a member variable for that. We also keep track of the window ID to tell which events belong to which window and we also added a flag to keep track of whether the window is shown.</p>
<pre><code>//Our custom windows
LWindow gWindows[ TOTAL_WINDOWS ];
</code></pre><p>For this program we&#39;ll have 3 globally allocated windows.</p>
<pre><code>bool LWindow::init()
{
    //Create window
    mWindow = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE );
    if( mWindow != NULL )
    {
        mMouseFocus = true;
        mKeyboardFocus = true;
        mWidth = SCREEN_WIDTH;
        mHeight = SCREEN_HEIGHT;

        //Create renderer for window
        mRenderer = SDL_CreateRenderer( mWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC );
        if( mRenderer == NULL )
        {
            printf( &quot;Renderer could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
            SDL_DestroyWindow( mWindow );
            mWindow = NULL;
        }
        else
        {
            //Initialize renderer color
            SDL_SetRenderDrawColor( mRenderer, 0xFF, 0xFF, 0xFF, 0xFF );

            //Grab window identifier
            mWindowID = SDL_GetWindowID( mWindow );

            //Flag as opened
            mShown = true;
        }
    }
    else
    {
        printf( &quot;Window could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
    }

    return mWindow != NULL &amp;&amp; mRenderer != NULL;
}
</code></pre><p>Here is our window and renderer creation code. It is pretty much the same as we have always done it, only now it&#39;s happening inside our wrapper class. We do have to make sure to grab the window ID after creating the window as we&#39;ll need the ID for event handling.</p>
<pre><code>void LWindow::handleEvent( SDL_Event&amp; e )
{
    //If an event was detected for this window
    if( e.type == SDL_WINDOWEVENT &amp;&amp; e.window.windowID == mWindowID )
    {
        //Caption update flag
        bool updateCaption = false;
</code></pre><p>All events from all windows go onto the same event queue, so to know which events belong to which window we check that the event&#39;s window ID matches ours.</p>
<pre><code>        switch( e.window.event )
        {
            //Window appeared
            case SDL_WINDOWEVENT_SHOWN:
            mShown = true;
            break;

            //Window disappeared
            case SDL_WINDOWEVENT_HIDDEN:
            mShown = false;
            break;

            //Get new dimensions and repaint
            case SDL_WINDOWEVENT_SIZE_CHANGED:
            mWidth = e.window.data1;
            mHeight = e.window.data2;
            SDL_RenderPresent( mRenderer );
            break;

            //Repaint on expose
            case SDL_WINDOWEVENT_EXPOSED:
            SDL_RenderPresent( mRenderer );
            break;

            //Mouse enter
            case SDL_WINDOWEVENT_ENTER:
            mMouseFocus = true;
            updateCaption = true;
            break;

            //Mouse exit
            case SDL_WINDOWEVENT_LEAVE:
            mMouseFocus = false;
            updateCaption = true;
            break;

            //Keyboard focus gained
            case SDL_WINDOWEVENT_FOCUS_GAINED:
            mKeyboardFocus = true;
            updateCaption = true;
            break;

            //Keyboard focus lost
            case SDL_WINDOWEVENT_FOCUS_LOST:
            mKeyboardFocus = false;
            updateCaption = true;
            break;

            //Window minimized
            case SDL_WINDOWEVENT_MINIMIZED:
            mMinimized = true;
            break;

            //Window maxized
            case SDL_WINDOWEVENT_MAXIMIZED:
            mMinimized = false;
            break;

            //Window restored
            case SDL_WINDOWEVENT_RESTORED:
            mMinimized = false;
            break;
</code></pre><p>When you have multiple windows, Xing out the window doesn&#39;t necessarily mean we&#39;re quitting the program. What we&#39;re going to do instead is have each window hide when Xed out. So we&#39;ll need keep track of when the window is hidden/shown by checking for SDL_WINDOWEVENT_SHOWN/SDL_WINDOWEVENT_HIDDEN events.</p>
<pre><code>            //Hide on close
            case SDL_WINDOWEVENT_CLOSE:
            SDL_HideWindow( mWindow );
            break;
        }

        //Update window caption with new data
        if( updateCaption )
        {
            std::stringstream caption;
            caption &lt;&lt; &quot;SDL Tutorial - ID: &quot; &lt;&lt; mWindowID &lt;&lt; &quot; MouseFocus:&quot; &lt;&lt; ( ( mMouseFocus ) ? &quot;On&quot; : &quot;Off&quot; ) &lt;&lt; &quot; KeyboardFocus:&quot; &lt;&lt; ( ( mKeyboardFocus ) ? &quot;On&quot; : &quot;Off&quot; );
            SDL_SetWindowTitle( mWindow, caption.str().c_str() );
        }
    }
}
</code></pre><p>When you have multiple windows, Xing out the window gets interpreted as SDL_WINDOWEVENT_CLOSE window events. When we get these events we&#39;re going to hide the window using <a href="http://wiki.libsdl.org/SDL_HideWindow">SDL_HideWindow</a>.</p>
<pre><code>void LWindow::focus()
{
    //Restore window if needed
    if( !mShown )
    {
        SDL_ShowWindow( mWindow );
    }

    //Move window forward
    SDL_RaiseWindow( mWindow );
}
</code></pre><p>Here is our function for grabbing focus to a window. First we check if our window is even being shown and then show it with <a href="http://wiki.libsdl.org/SDL_ShowWindow">SDL_ShowWindow</a> if it isn&#39;t being shown. Next we call <a href="http://wiki.libsdl.org/SDL_RaiseWindow">SDL_RaiseWindow</a> to focus the window.</p>
<pre><code>void LWindow::render()
{
    if( !mMinimized )
    {    
        //Clear screen
        SDL_SetRenderDrawColor( mRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
        SDL_RenderClear( mRenderer );

        //Update screen
        SDL_RenderPresent( mRenderer );
    }
}
</code></pre><p>Like before, we only want to render if the window is not minimized.</p>
<pre><code>bool init()
{
    //Initialization flag
    bool success = true;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
    else
    {
        //Set texture filtering to linear
        if( !SDL_SetHint( SDL_HINT_RENDER_SCALE_QUALITY, &quot;1&quot; ) )
        {
            printf( &quot;Warning: Linear texture filtering not enabled!&quot; );
        }

        //Create window
        if( !gWindows[ 0 ].init() )
        {
            printf( &quot;Window 0 could not be created!\n&quot; );
            success = false;
        }
    }

    return success;
}
</code></pre><p>In the initialization function we open up a single window to check if window creation is functioning properly.</p>
<pre><code>void close()
{
    //Destroy windows
    for( int i = 0; i &lt; TOTAL_WINDOWS; ++i )
    {
        gWindows[ i ].free();
    }

    //Quit SDL subsystems
    SDL_Quit();
}
</code></pre><p>In the clean up function we close out any windows that might be open.</p>
<pre><code>        //Initialize the rest of the windows
        for( int i = 1; i &lt; TOTAL_WINDOWS; ++i )
        {
            gWindows[ i ].init();
        }

        //Main loop flag
        bool quit = false;

        //Event handler
        SDL_Event e;
</code></pre><p>Before we enter the main loop we open up the rest of the windows we have.</p>
<pre><code>        //While application is running
        while( !quit )
        {
            //Handle events on queue
            while( SDL_PollEvent( &amp;e ) != 0 )
            {
                //User requests quit
                if( e.type == SDL_QUIT )
                {
                    quit = true;
                }

                //Handle window events
                for( int i = 0; i &lt; TOTAL_WINDOWS; ++i )
                {
                    gWindows[ i ].handleEvent( e );
                }

                //Pull up window
                if( e.type == SDL_KEYDOWN )
                {
                    switch( e.key.keysym.sym )
                    {
                        case SDLK_1:
                        gWindows[ 0 ].focus();
                        break;

                        case SDLK_2:
                        gWindows[ 1 ].focus();
                        break;

                        case SDLK_3:
                        gWindows[ 2 ].focus();
                        break;
                    }
                }
            }
</code></pre><p>In the main loop after we handle the events for all the windows, we handle some special key presses. For this demo, when we press 1, 2, or 3 it will bring the corresponding window to focus.</p>
<pre><code>            //Update all windows
            for( int i = 0; i &lt; TOTAL_WINDOWS; ++i )
            {
                gWindows[ i ].render();
            }

            //Check all windows
            bool allWindowsClosed = true;
            for( int i = 0; i &lt; TOTAL_WINDOWS; ++i )
            {
                if( gWindows[ i ].isShown() )
                {
                    allWindowsClosed = false;
                    break;
                }
            }

            //Application closed all windows
            if( allWindowsClosed )
            {
                quit = true;
            }
        }
</code></pre><p>Next we render all the windows and then go through all the windows to check if any of them are shown. If all of them have been closed out we set the quit flag to true to end the program.</p>
<p>Now in this demo we did not actually render anything inside of the windows. This would involve having to manage renderers and windows and having them share resources. There is no right way to do this and the best way depends entirely on what type of application you&#39;re building. I recommend reading through the SDL documentation to understand how renderers work and then experimenting to figure out the best way for you to manage your resources.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/36_multiple_windows/36_multiple_windows.zip">here</a>.</p>
<h2 id="multiple-displays">Multiple Displays</h2>
<table>
<thead>
<tr>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/37_preview1.png" alt=""></td>
<td><img src="./res/37_preview2.png" alt=""></td>
</tr>
</tbody>
</table>
<p><strong>Last Updated 6/11/19</strong></p>
<p>Another neat new feature with SDL 2 is the ability to handle multiple displays. Here we&#39;ll be making our window jump from display to display.</p>
<pre><code>class LWindow
{
    public:
        //Intializes internals
        LWindow();

        //Creates window
        bool init();

        //Handles window events
        void handleEvent( SDL_Event&amp; e );

        //Focuses on window
        void focus();

        //Shows windows contents
        void render();

        //Deallocates internals
        void free();

        //Window dimensions
        int getWidth();
        int getHeight();

        //Window focii
        bool hasMouseFocus();
        bool hasKeyboardFocus();
        bool isMinimized();
        bool isShown();

    private:
        //Window data
        SDL_Window* mWindow;
        SDL_Renderer* mRenderer;
        int mWindowID;
        int mWindowDisplayID;

        //Window dimensions
        int mWidth;
        int mHeight;

        //Window focus
        bool mMouseFocus;
        bool mKeyboardFocus;
        bool mFullScreen;
        bool mMinimized;
        bool mShown;
};
</code></pre><p>Here is our window from previous tutorials with a window display ID to keep track of which display the window is on.</p>
<pre><code>//Our custom window
LWindow gWindow;

//Display data
int gTotalDisplays = 0;
SDL_Rect* gDisplayBounds = NULL;
</code></pre><p>Our displays all have an integer ID and a rectangle associated with them so we know the position and dimensions of each display on our desktop.</p>
<pre><code>bool LWindow::init()
{
    //Create window
    mWindow = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE );
    if( mWindow != NULL )
    {
        mMouseFocus = true;
        mKeyboardFocus = true;
        mWidth = SCREEN_WIDTH;
        mHeight = SCREEN_HEIGHT;

        //Create renderer for window
        mRenderer = SDL_CreateRenderer( mWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC );
        if( mRenderer == NULL )
        {
            printf( &quot;Renderer could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
            SDL_DestroyWindow( mWindow );
            mWindow = NULL;
        }
        else
        {
            //Initialize renderer color
            SDL_SetRenderDrawColor( mRenderer, 0xFF, 0xFF, 0xFF, 0xFF );

            //Grab window identifiers
            mWindowID = SDL_GetWindowID( mWindow );
            mWindowDisplayID = SDL_GetWindowDisplayIndex( mWindow );

            //Flag as opened
            mShown = true;
        }
    }
    else
    {
        printf( &quot;Window could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
    }

    return mWindow != NULL &amp;&amp; mRenderer != NULL;
}
</code></pre><p>Our window creation code is pretty much the same as before only now we made a call to SDL_GetWindowDisplayIndex so we know which display the window was created on.</p>
<pre><code>void LWindow::handleEvent( SDL_Event&amp; e )
{
    //Caption update flag
    bool updateCaption = false;

    //If an event was detected for this window
    if( e.type == SDL_WINDOWEVENT &amp;&amp; e.window.windowID == mWindowID )
    {
        switch( e.window.event )
        {
            //Window moved
            case SDL_WINDOWEVENT_MOVED:
            mWindowDisplayID = SDL_GetWindowDisplayIndex( mWindow );
            updateCaption = true;
            break;

            //Window appeared
            case SDL_WINDOWEVENT_SHOWN:
            mShown = true;
            break;

            //Window disappeared
            case SDL_WINDOWEVENT_HIDDEN:
            mShown = false;
            break;

            //Get new dimensions and repaint
            case SDL_WINDOWEVENT_SIZE_CHANGED:
            mWidth = e.window.data1;
            mHeight = e.window.data2;
            SDL_RenderPresent( mRenderer );
            break;

            //Repaint on expose
            case SDL_WINDOWEVENT_EXPOSED:
            SDL_RenderPresent( mRenderer );
            break;

            //Mouse enter
            case SDL_WINDOWEVENT_ENTER:
            mMouseFocus = true;
            updateCaption = true;
            break;

            //Mouse exit
            case SDL_WINDOWEVENT_LEAVE:
            mMouseFocus = false;
            updateCaption = true;
            break;

            //Keyboard focus gained
            case SDL_WINDOWEVENT_FOCUS_GAINED:
            mKeyboardFocus = true;
            updateCaption = true;
            break;

            //Keyboard focus lost
            case SDL_WINDOWEVENT_FOCUS_LOST:
            mKeyboardFocus = false;
            updateCaption = true;
            break;

            //Window minimized
            case SDL_WINDOWEVENT_MINIMIZED:
            mMinimized = true;
            break;

            //Window maxized
            case SDL_WINDOWEVENT_MAXIMIZED:
            mMinimized = false;
            break;

            //Window restored
            case SDL_WINDOWEVENT_RESTORED:
            mMinimized = false;
            break;

            //Hide on close
            case SDL_WINDOWEVENT_CLOSE:
            SDL_HideWindow( mWindow );
            break;
        }
    }
</code></pre><p>Here in our window&#39;s event handler we handle a SDL_WINDOWEVENT_MOVED event so we can update the display the window is on using SDL_GetWindowDisplayIndex.</p>
<pre><code>    else if( e.type == SDL_KEYDOWN )
    {
        //Display change flag
        bool switchDisplay = false;

        //Cycle through displays on up/down
        switch( e.key.keysym.sym )
        {
            case SDLK_UP:
            ++mWindowDisplayID;
            switchDisplay = true;
            break;

            case SDLK_DOWN:
            --mWindowDisplayID;
            switchDisplay = true;
            break;
        }
</code></pre><p>When we press up or down we change the display index to move to the next display.</p>
<pre><code>        //Display needs to be updated
        if( switchDisplay )
        {
            //Bound display index
            if( mWindowDisplayID &lt; 0 )
            {
                mWindowDisplayID = gTotalDisplays - 1;
            }
            else if( mWindowDisplayID &gt;= gTotalDisplays )
            {
                mWindowDisplayID = 0;
            }

            //Move window to center of next display
            SDL_SetWindowPosition( mWindow, gDisplayBounds[ mWindowDisplayID ].x + ( gDisplayBounds[ mWindowDisplayID ].w - mWidth ) / 2, gDisplayBounds[ mWindowDisplayID ].y + ( gDisplayBounds[ mWindowDisplayID ].h - mHeight ) / 2 );
            updateCaption = true;
        }
    }

    //Update window caption with new data
    if( updateCaption )
    {
        std::stringstream caption;
        caption &lt;&lt; &quot;SDL Tutorial - ID: &quot; &lt;&lt; mWindowID &lt;&lt; &quot; Display: &quot; &lt;&lt; mWindowDisplayID &lt;&lt; &quot; MouseFocus:&quot; &lt;&lt; ( ( mMouseFocus ) ? &quot;On&quot; : &quot;Off&quot; ) &lt;&lt; &quot; KeyboardFocus:&quot; &lt;&lt; ( ( mKeyboardFocus ) ? &quot;On&quot; : &quot;Off&quot; );
        SDL_SetWindowTitle( mWindow, caption.str().c_str() );
    }
}
</code></pre><p>If we need to move to the next display, we first make sure the display is a valid index by bounding it. We then update the position of the window with SDL_SetWindowPosition. This call here will center the window in the next display.</p>
<pre><code>bool init()
{
    //Initialization flag
    bool success = true;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
    else
    {
        //Set texture filtering to linear
        if( !SDL_SetHint( SDL_HINT_RENDER_SCALE_QUALITY, &quot;1&quot; ) )
        {
            printf( &quot;Warning: Linear texture filtering not enabled!&quot; );
        }

        //Get number of displays
        gTotalDisplays = SDL_GetNumVideoDisplays();
        if( gTotalDisplays &lt; 2 )
        {
            printf( &quot;Warning: Only one display connected!&quot; );
        }
</code></pre><p>In our initialization function we find out how many displays are connected to the computer using SDL_GetNumVideoDisplays. If there&#39;s only 1 display we output a warning.</p>
<pre><code>        //Get bounds of each display
        gDisplayBounds = new SDL_Rect[ gTotalDisplays ];
        for( int i = 0; i &lt; gTotalDisplays; ++i )
        {
            SDL_GetDisplayBounds( i, &amp;gDisplayBounds[ i ] );
        }

        //Create window
        if( !gWindow.init() )
        {
            printf( &quot;Window could not be created!\n&quot; );
            success = false;
        }
    }

    return success;
}
</code></pre><p>Now that we know how many displays are connected, we allocate rectangles for each of them and get the bounds for each one using SDL_GetDisplayBounds. After this we initialize our window.</p>
<pre><code>        //Main loop flag
        bool quit = false;

        //Event handler
        SDL_Event e;

        //While application is running
        while( !quit )
        {
            //Handle events on queue
            while( SDL_PollEvent( &amp;e ) != 0 )
            {
                //User requests quit
                if( e.type == SDL_QUIT )
                {
                    quit = true;
                }

                //Handle window events
                gWindow.handleEvent( e );
            }

            //Update window
            gWindow.render();
        }
</code></pre><p>Since our code is well encapsulated the main loop hasn&#39;t changed since all the changes have happened under the hood.<br>Download the media and source code for this tutorial here.</p>
<h2 id="particle-engines">Particle Engines</h2>
<p><img src="./res/38_preview.png" alt=""></p>
<p><strong>Last Updated 5/04/14</strong></p>
<p>Particles are just mini-animations. What we&#39;re going to do is take these animations:</p>
<p>and spawn them around a dot to create a trail of colored shimmering particles.</p>
<pre><code>//Particle count
const int TOTAL_PARTICLES = 20;

class Particle
{
    public:
        //Initialize position and animation
        Particle( int x, int y );

        //Shows the particle
        void render();

        //Checks if particle is dead
        bool isDead();

    private:
        //Offsets
        int mPosX, mPosY;

        //Current frame of animation
        int mFrame;

        //Type of particle
        LTexture *mTexture;
};
</code></pre><p>Here is a simple particle class. We have a constructor to set the position, a function to render it, and a function to tell if the particle is dead. In terms of data members we have a position, a frame of animation, and a texture we&#39;ll render with.</p>
<pre><code>//The dot that will move around on the screen
class Dot
{
    public:
        //The dimensions of the dot
        static const int DOT_WIDTH = 20;
        static const int DOT_HEIGHT = 20;

        //Maximum axis velocity of the dot
        static const int DOT_VEL = 10;

        //Initializes the variables and allocates particles
        Dot();

        //Deallocates particles
        ~Dot();

        //Takes key presses and adjusts the dot&#39;s velocity
        void handleEvent( SDL_Event&amp; e );

        //Moves the dot
        void move();

        //Shows the dot on the screen
        void render();

    private:
        //The particles
        Particle* particles[ TOTAL_PARTICLES ];

        //Shows the particles
        void renderParticles();

        //The X and Y offsets of the dot
        int mPosX, mPosY;

        //The velocity of the dot
        int mVelX, mVelY;
};
</code></pre><p>Here is our dot with an array of particles and a function to render the particles on the dot.</p>
<pre><code>Particle::Particle( int x, int y )
{
    //Set offsets
    mPosX = x - 5 + ( rand() % 25 );
    mPosY = y - 5 + ( rand() % 25 );

    //Initialize animation
    mFrame = rand() % 5;

    //Set type
    switch( rand() % 3 )
    {
        case 0: mTexture = &amp;gRedTexture; break;
        case 1: mTexture = &amp;gGreenTexture; break;
        case 2: mTexture = &amp;gBlueTexture; break;
    }
}
</code></pre><p>For our particle constructor we initialize the position around the given position with some randomness to it. We then initialize the frame of animation with some randomness so the particles will have varying life. Finally we pick the type of texture we&#39;ll use for the particle also at random.</p>
<pre><code>void Particle::render()
{
    //Show image
    mTexture-&gt;render( mPosX, mPosY );

    //Show shimmer
    if( mFrame % 2 == 0 )
    {
        gShimmerTexture.render( mPosX, mPosY );
    }

    //Animate
    mFrame++;
}
</code></pre><p>In the rendering function we render our texture selected in the constructor and then every other frame we render a semitransparent shimmer texture over it to make it look like the particle is shining. We then update the frame of animation.</p>
<pre><code>bool Particle::isDead()
{
    return mFrame &gt; 10;
}
</code></pre><p>Once the particle has rendered for a max of 10 frames, we mark it as dead.</p>
<pre><code>Dot::Dot()
{
    //Initialize the offsets
    mPosX = 0;
    mPosY = 0;

    //Initialize the velocity
    mVelX = 0;
    mVelY = 0;

    //Initialize particles
    for( int i = 0; i &lt; TOTAL_PARTICLES; ++i )
    {
        particles[ i ] = new Particle( mPosX, mPosY );
    }
}

Dot::~Dot()
{
    //Delete particles
    for( int i = 0; i &lt; TOTAL_PARTICLES; ++i )
    {
        delete particles[ i ];
    }
}
</code></pre><p>The constructor/destructor now have to allocate/deallocate the particles we render over the dot.</p>
<pre><code>void Dot::render()
{
    //Show the dot
    gDotTexture.render( mPosX, mPosY );

    //Show particles on top of dot
    renderParticles();
}

void Dot::renderParticles()
{
    //Go through particles
    for( int i = 0; i &lt; TOTAL_PARTICLES; ++i )
    {
        //Delete and replace dead particles
        if( particles[ i ]-&gt;isDead() )
        {
            delete particles[ i ];
            particles[ i ] = new Particle( mPosX, mPosY );
        }
    }

    //Show particles
    for( int i = 0; i &lt; TOTAL_PARTICLES; ++i )
    {
        particles[ i ]-&gt;render();
    }
}
</code></pre><p>Our dot&#39;s rendering function now calls our particle rendering function. The particle rendering function checks if there are any particles that are dead and replaces them. After the dead particles are replaced we render all the current particles to the screen.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load dot texture
    if( !gDotTexture.loadFromFile( &quot;38_particle_engines/dot.bmp&quot; ) )
    {
        printf( &quot;Failed to load dot texture!\n&quot; );
        success = false;
    }

    //Load red texture
    if( !gRedTexture.loadFromFile( &quot;38_particle_engines/red.bmp&quot; ) )
    {
        printf( &quot;Failed to load red texture!\n&quot; );
        success = false;
    }

    //Load green texture
    if( !gGreenTexture.loadFromFile( &quot;38_particle_engines/green.bmp&quot; ) )
    {
        printf( &quot;Failed to load green texture!\n&quot; );
        success = false;
    }

    //Load blue texture
    if( !gBlueTexture.loadFromFile( &quot;38_particle_engines/blue.bmp&quot; ) )
    {
        printf( &quot;Failed to load blue texture!\n&quot; );
        success = false;
    }

    //Load shimmer texture
    if( !gShimmerTexture.loadFromFile( &quot;38_particle_engines/shimmer.bmp&quot; ) )
    {
        printf( &quot;Failed to load shimmer texture!\n&quot; );
        success = false;
    }

    //Set texture transparency
    gRedTexture.setAlpha( 192 );
    gGreenTexture.setAlpha( 192 );
    gBlueTexture.setAlpha( 192 );
    gShimmerTexture.setAlpha( 192 );

    return success;
}
</code></pre><p>To give our particles a semi transparent look we set their alpha to 192.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //The dot that will be moving around on the screen
            Dot dot;

            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }

                    //Handle input for the dot
                    dot.handleEvent( e );
                }

                //Move the dot
                dot.move();

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render objects
                dot.render();

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>Again, since our code is well encapsulated the code in the main loop hardly changes.</p>
<p>Now like most of the tutorials this is a super simplified example. In larger program there would be particles controlled by a particle emitter that&#39;s its own class, but for the sake of simplicity we&#39;re having the Dot class function as a particle emitter.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/38_particle_engines/38_particle_engines.zip">here</a>.</p>
<h2 id="tiling">Tiling</h2>
<p><img src="./res/39_preview.png" alt=""></p>
<p><strong>Last Updated 6/24/19</strong></p>
<p>Tiling is a way of making levels out of uniformly sized reusable pieces. In this tutorial we&#39;ll be making a 1280x960 sized level of out only a 160x120 sized tile set.<br>Say if we want to make a level like this:<br><img src="./res/39_level.jpg" alt=""></p>
<p>We could make one huge level or we could create a tile set of 12 pieces:<br><img src="./res/39_tiles.jpg" alt=""></p>
<p>And then create a level out of those pieces allowing us to save memory and save time by reusing pieces. This is why back in the early days of gaming tiling engines were so popular on low resource systems and are still used today in some games.</p>
<pre><code>//Using SDL, SDL_image, standard IO, strings, and file streams
#include &lt;SDL.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
</code></pre><p>In our previous tutorials we did our <a href="#file-reading-and-writing">file reading and writing with SDL RWOps</a>. Here we&#39;ll be using fstream which is part of the standard C++ library and is relatively easy to use with text files.</p>
<pre><code>//Screen dimension constants
const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;

//The dimensions of the level
const int LEVEL_WIDTH = 1280;
const int LEVEL_HEIGHT = 960;

//Tile constants
const int TILE_WIDTH = 80;
const int TILE_HEIGHT = 80;
const int TOTAL_TILES = 192;
const int TOTAL_TILE_SPRITES = 12;

//The different tile sprites
const int TILE_RED = 0;
const int TILE_GREEN = 1;
const int TILE_BLUE = 2;
const int TILE_CENTER = 3;
const int TILE_TOP = 4;
const int TILE_TOPRIGHT = 5;
const int TILE_RIGHT = 6;
const int TILE_BOTTOMRIGHT = 7;
const int TILE_BOTTOM = 8;
const int TILE_BOTTOMLEFT = 9;
const int TILE_LEFT = 10;
const int TILE_TOPLEFT = 11;
</code></pre><p>Here we&#39;re defining some constants. We&#39;ll be using <a href="#scrolling">scrolling</a> so we have constants for both the screen and the level. We&#39;ll also have constants to define the tiles and the tile types.</p>
<pre><code>//The tile
class Tile
{
    public:
        //Initializes position and type
        Tile( int x, int y, int tileType );

        //Shows the tile
        void render( SDL_Rect&amp; camera );

        //Get the tile type
        int getType();

        //Get the collision box
        SDL_Rect getBox();

    private:
        //The attributes of the tile
        SDL_Rect mBox;

        //The tile type
        int mType;
};
</code></pre><p>Here is our tile class with a constructor that defines position and type, a renderer that uses a camera, and some accessors to get the tile&#39;s type and collision box. In terms of data members we have a collision box and type indicator.</p>
<p>Normally it&#39;s a good idea to have <a href="#collision-detection">position and collider separate when doing collision detection</a>, but for the sake of simplicity we&#39;re using the collider to hold position.</p>
<pre><code>//The dot that will move around on the screen
class Dot
{
    public:
        //The dimensions of the dot
        static const int DOT_WIDTH = 20;
        static const int DOT_HEIGHT = 20;

        //Maximum axis velocity of the dot
        static const int DOT_VEL = 10;

        //Initializes the variables
        Dot();

        //Takes key presses and adjusts the dot&#39;s velocity
        void handleEvent( SDL_Event&amp; e );

        //Moves the dot and check collision against tiles
        void move( Tile *tiles[] );

        //Centers the camera over the dot
        void setCamera( SDL_Rect&amp; camera );

        //Shows the dot on the screen
        void render( SDL_Rect&amp; camera );

    private:
        //Collision box of the dot
        SDL_Rect mBox;

        //The velocity of the dot
        int mVelX, mVelY;
};
</code></pre><p>Here is the dot class yet again, now with the ability to check for collision against the tiles when moving.</p>
<pre><code>//Starts up SDL and creates window
bool init();

//Loads media
bool loadMedia( Tile* tiles[] );

//Frees media and shuts down SDL
void close( Tile* tiles[] );

//Box collision detector
bool checkCollision( SDL_Rect a, SDL_Rect b );

//Checks collision box against set of tiles
bool touchesWall( SDL_Rect box, Tile* tiles[] );

//Sets tiles from tile map
bool setTiles( Tile *tiles[] );
</code></pre><p>Our media loading function will also be initializing tiles so it needs to take them in as an argument.</p>
<p>We also have the touchesWall function that checks a collision box against every wall in a tile set which will be used when we need to check the dot against the whole tile set. Finally the setTiles function loads and sets the tiles.</p>
<pre><code>Tile::Tile( int x, int y, int tileType )
{
    //Get the offsets
    mBox.x = x;
    mBox.y = y;

    //Set the collision box
    mBox.w = TILE_WIDTH;
    mBox.h = TILE_HEIGHT;

    //Get the tile type
    mType = tileType;
}
</code></pre><p>The tile constructor initializes position, dimensions, and type.</p>
<pre><code>void Tile::render( SDL_Rect&amp; camera )
{
    //If the tile is on screen
    if( checkCollision( camera, mBox ) )
    {
        //Show the tile
        gTileTexture.render( mBox.x - camera.x, mBox.y - camera.y, &amp;gTileClips[ mType ] );
    }
}
</code></pre><p>When we render we only want to show tiles that are in the camera&#39;s sight:<br><img src="./res/39_shown.jpg" alt=""></p>
<p>So we check if the tile collides with the camera before rendering it. Notice also that we render the tile relative to the camera.</p>
<pre><code>int Tile::getType()
{
    return mType;
}

SDL_Rect Tile::getBox()
{
    return mBox;
}
</code></pre><p>And here are the accessors to get the tile&#39;s type and collision box.</p>
<pre><code>void Dot::move( Tile *tiles[] )
{
    //Move the dot left or right
    mBox.x += mVelX;

    //If the dot went too far to the left or right or touched a wall
    if( ( mBox.x &lt; 0 ) || ( mBox.x + DOT_WIDTH &gt; LEVEL_WIDTH ) || touchesWall( mBox, tiles ) )
    {
        //move back
        mBox.x -= mVelX;
    }

    //Move the dot up or down
    mBox.y += mVelY;

    //If the dot went too far up or down or touched a wall
    if( ( mBox.y &lt; 0 ) || ( mBox.y + DOT_HEIGHT &gt; LEVEL_HEIGHT ) || touchesWall( mBox, tiles ) )
    {
        //move back
        mBox.y -= mVelY;
    }
}
</code></pre><p>When we move the dot we check if it goes off the level or hits a wall tile. If it does we correct it.</p>
<pre><code>void Dot::setCamera( SDL_Rect&amp; camera )
{
    //Center the camera over the dot
    camera.x = ( mBox.x + DOT_WIDTH / 2 ) - SCREEN_WIDTH / 2;
    camera.y = ( mBox.y + DOT_HEIGHT / 2 ) - SCREEN_HEIGHT / 2;

    //Keep the camera in bounds
    if( camera.x &lt; 0 )
    { 
        camera.x = 0;
    }
    if( camera.y &lt; 0 )
    {
        camera.y = 0;
    }
    if( camera.x &gt; LEVEL_WIDTH - camera.w )
    {
        camera.x = LEVEL_WIDTH - camera.w;
    }
    if( camera.y &gt; LEVEL_HEIGHT - camera.h )
    {
        camera.y = LEVEL_HEIGHT - camera.h;
    }
}

void Dot::render( SDL_Rect&amp; camera )
{
    //Show the dot
    gDotTexture.render( mBox.x - camera.x, mBox.y - camera.y );
}
</code></pre><p>Here is the rendering code largely lifted from the scrolling/camera tutorial.</p>
<pre><code>bool loadMedia( Tile* tiles[] )
{
    //Loading success flag
    bool success = true;

    //Load dot texture
    if( !gDotTexture.loadFromFile( &quot;39_tiling/dot.bmp&quot; ) )
    {
        printf( &quot;Failed to load dot texture!\n&quot; );
        success = false;
    }

    //Load tile texture
    if( !gTileTexture.loadFromFile( &quot;39_tiling/tiles.png&quot; ) )
    {
        printf( &quot;Failed to load tile set texture!\n&quot; );
        success = false;
    }

    //Load tile map
    if( !setTiles( tiles ) )
    {
        printf( &quot;Failed to load tile set!\n&quot; );
        success = false;
    }

    return success;
}
</code></pre><p>In our loading function we not only load the textures but also the tile set.</p>
<pre><code>bool setTiles( Tile* tiles[] )
{
    //Success flag
    bool tilesLoaded = true;

    //The tile offsets
    int x = 0, y = 0;

    //Open the map
    std::ifstream map( &quot;39_tiling/lazy.map&quot; );

    //If the map couldn&#39;t be loaded
    if( map.fail() )
    {
        printf( &quot;Unable to load map file!\n&quot; );
        tilesLoaded = false;
    }
</code></pre><p>Near the top of the setTiles function we declare x/y offsets that define where we&#39;ll be placing the tiles. As we load in more tiles we&#39;ll be shifting the x/y position left to right and top to bottom.</p>
<p>We then open the lazy.map file which is just a text file with the following contents:</p>
<p><strong>00 01 02 00 01 02 00 01 02 00 01 02 00 01 02 00<br>01 02 00 01 02 00 01 02 00 01 02 00 01 02 00 01<br>02 00 11 04 04 04 04 04 04 04 04 04 04 05 01 02<br>00 01 10 03 03 03 03 03 03 03 03 03 03 06 02 00<br>01 02 10 03 08 08 08 08 08 08 08 03 03 06 00 01<br>02 00 10 06 00 01 02 00 01 02 00 10 03 06 01 02<br>00 01 10 06 01 11 05 01 02 00 01 10 03 06 02 00<br>01 02 10 06 02 09 07 02 00 01 02 10 03 06 00 01<br>02 00 10 06 00 01 02 00 01 02 00 10 03 06 01 02<br>00 01 10 03 04 04 04 05 02 00 01 09 08 07 02 00<br>01 02 09 08 08 08 08 07 00 01 02 00 01 02 00 01<br>02 00 01 02 00 01 02 00 01 02 00 01 02 00 01 02</strong></p>
<p>Using fstream we can read text from a file much like we would read keyboard input with iostream. Before we can continue we have to check if the map loaded correctly. If it failed we abort and if not we continue loading the file.</p>
<pre><code>    else
    {
        //Initialize the tiles
        for( int i = 0; i &lt; TOTAL_TILES; ++i )
        {
            //Determines what kind of tile will be made
            int tileType = -1;

            //Read tile from map file
            map &gt;&gt; tileType;

            //If the was a problem in reading the map
            if( map.fail() )
            {
                //Stop loading map
                printf( &quot;Error loading map: Unexpected end of file!\n&quot; );
                tilesLoaded = false;
                break;
            }

            //If the number is a valid tile number
            if( ( tileType &gt;= 0 ) &amp;&amp; ( tileType &lt; TOTAL_TILE_SPRITES ) )
            {
                tiles[ i ] = new Tile( x, y, tileType );
            }
            //If we don&#39;t recognize the tile type
            else
            {
                //Stop loading map
                printf( &quot;Error loading map: Invalid tile type at %d!\n&quot;, i );
                tilesLoaded = false;
                break;
            }
</code></pre><p>If the file loaded successfully we have a for loop that reads in all the numbers from the text file. We read a number into the tileType variable and then check if the read failed. If the read failed, we abort.</p>
<p>If not we then check if the tile type number is valid. If it is valid we create a new tile of the given type, if not we print an error and stop loading tiles.</p>
<pre><code>            //Move to next tile spot
            x += TILE_WIDTH;

            //If we&#39;ve gone too far
            if( x &gt;= LEVEL_WIDTH )
            {
                //Move back
                x = 0;

                //Move to the next row
                y += TILE_HEIGHT;
            }
        }
</code></pre><p>After loading a tile we move to the text tile position to the right. If we reached the end of a line of tiles, we move down to the next row.</p>
<pre><code>        //Clip the sprite sheet
        if( tilesLoaded )
        {
            gTileClips[ TILE_RED ].x = 0;
            gTileClips[ TILE_RED ].y = 0;
            gTileClips[ TILE_RED ].w = TILE_WIDTH;
            gTileClips[ TILE_RED ].h = TILE_HEIGHT;

            gTileClips[ TILE_GREEN ].x = 0;
            gTileClips[ TILE_GREEN ].y = 80;
            gTileClips[ TILE_GREEN ].w = TILE_WIDTH;
            gTileClips[ TILE_GREEN ].h = TILE_HEIGHT;

            gTileClips[ TILE_BLUE ].x = 0;
            gTileClips[ TILE_BLUE ].y = 160;
            gTileClips[ TILE_BLUE ].w = TILE_WIDTH;
            gTileClips[ TILE_BLUE ].h = TILE_HEIGHT;

            gTileClips[ TILE_TOPLEFT ].x = 80;
            gTileClips[ TILE_TOPLEFT ].y = 0;
            gTileClips[ TILE_TOPLEFT ].w = TILE_WIDTH;
            gTileClips[ TILE_TOPLEFT ].h = TILE_HEIGHT;

            gTileClips[ TILE_LEFT ].x = 80;
            gTileClips[ TILE_LEFT ].y = 80;
            gTileClips[ TILE_LEFT ].w = TILE_WIDTH;
            gTileClips[ TILE_LEFT ].h = TILE_HEIGHT;

            gTileClips[ TILE_BOTTOMLEFT ].x = 80;
            gTileClips[ TILE_BOTTOMLEFT ].y = 160;
            gTileClips[ TILE_BOTTOMLEFT ].w = TILE_WIDTH;
            gTileClips[ TILE_BOTTOMLEFT ].h = TILE_HEIGHT;

            gTileClips[ TILE_TOP ].x = 160;
            gTileClips[ TILE_TOP ].y = 0;
            gTileClips[ TILE_TOP ].w = TILE_WIDTH;
            gTileClips[ TILE_TOP ].h = TILE_HEIGHT;

            gTileClips[ TILE_CENTER ].x = 160;
            gTileClips[ TILE_CENTER ].y = 80;
            gTileClips[ TILE_CENTER ].w = TILE_WIDTH;
            gTileClips[ TILE_CENTER ].h = TILE_HEIGHT;

            gTileClips[ TILE_BOTTOM ].x = 160;
            gTileClips[ TILE_BOTTOM ].y = 160;
            gTileClips[ TILE_BOTTOM ].w = TILE_WIDTH;
            gTileClips[ TILE_BOTTOM ].h = TILE_HEIGHT;

            gTileClips[ TILE_TOPRIGHT ].x = 240;
            gTileClips[ TILE_TOPRIGHT ].y = 0;
            gTileClips[ TILE_TOPRIGHT ].w = TILE_WIDTH;
            gTileClips[ TILE_TOPRIGHT ].h = TILE_HEIGHT;

            gTileClips[ TILE_RIGHT ].x = 240;
            gTileClips[ TILE_RIGHT ].y = 80;
            gTileClips[ TILE_RIGHT ].w = TILE_WIDTH;
            gTileClips[ TILE_RIGHT ].h = TILE_HEIGHT;

            gTileClips[ TILE_BOTTOMRIGHT ].x = 240;
            gTileClips[ TILE_BOTTOMRIGHT ].y = 160;
            gTileClips[ TILE_BOTTOMRIGHT ].w = TILE_WIDTH;
            gTileClips[ TILE_BOTTOMRIGHT ].h = TILE_HEIGHT;
        }
    }

    //Close the file
    map.close();

    //If the map was loaded fine
    return tilesLoaded;
}
</code></pre><p>After all the tiles are loaded we set the clip rectangles for the tile sprites. Finally we close the map file and return.</p>
<pre><code>bool touchesWall( SDL_Rect box, Tile* tiles[] )
{
    //Go through the tiles
    for( int i = 0; i &lt; TOTAL_TILES; ++i )
    {
        //If the tile is a wall type tile
        if( ( tiles[ i ]-&gt;getType() &gt;= TILE_CENTER ) &amp;&amp; ( tiles[ i ]-&gt;getType() &lt;= TILE_TOPLEFT ) )
        {
            //If the collision box touches the wall tile
            if( checkCollision( box, tiles[ i ]-&gt;getBox() ) )
            {
                return true;
            }
        }
    }

    //If no wall tiles were touched
    return false;
}
</code></pre><p>The touchesWall function checks a given collision box against tiles of type TILE_CENTER, TILE_TOP, TILE_TOPRIGHT, TILE_RIGHT, TILE_BOTTOMRIGHT, TILE_BOTTOM, TILE_BOTTOMLEFT, TILE_LEFT, and TILE_TOPLEFT which are all wall tiles. If you check back when we defined these constants, you&#39;ll see that these are numbered right next to each other so all we have to do is check if the type is between TILE_CENTER and TILE_TOPLEFT.</p>
<p>If the given collision box collides with any tile that is a wall this function returns true,</p>
<pre><code>        //The level tiles
        Tile* tileSet[ TOTAL_TILES ];

        //Load media
        if( !loadMedia( tileSet ) )
        {
            printf( &quot;Failed to load media!\n&quot; );
        }
</code></pre><p>In the main function right before we load the media we declare our array of tile pointers.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }

                    //Handle input for the dot
                    dot.handleEvent( e );
                }

                //Move the dot
                dot.move( tileSet );
                dot.setCamera( camera );

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render level
                for( int i = 0; i &lt; TOTAL_TILES; ++i )
                {
                    tileSet[ i ]-&gt;render( camera );
                }

                //Render dot
                dot.render( camera );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>Our main loop is pretty much the same with some adjustments. When we move the dot we pass in the tile set and then set the camera over the dot after it moved. We then render the tile set and finally render the dot over the level.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/39_tiling/39_tiling.zip">here</a>.</p>
<h2 id="texture-manipulation">Texture Manipulation</h2>
<p><img src="./res/40_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>To do graphics effects often requires pixel access. In this tutorial we&#39;ll be altering an image&#39;s pixels to white out the background.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        #if defined(_SDL_TTF_H) || defined(SDL_TTF_H)
        //Creates image from font string
        bool loadFromRenderedText( std::string textureText, SDL_Color textColor );
        #endif

        //Deallocates texture
        void free();

        //Set color modulation
        void setColor( Uint8 red, Uint8 green, Uint8 blue );

        //Set blending
        void setBlendMode( SDL_BlendMode blending );

        //Set alpha modulation
        void setAlpha( Uint8 alpha );

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL, double angle = 0.0, SDL_Point* center = NULL, SDL_RendererFlip flip = SDL_FLIP_NONE );

        //Gets image dimensions
        int getWidth();
        int getHeight();

        //Pixel manipulators
        bool lockTexture();
        bool unlockTexture();
        void* getPixels();
        int getPitch();

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;
        void* mPixels;
        int mPitch;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>Here we&#39;re adding new functionality to the texture class. We have functions to lock/unlock the texture because in order to access a texture&#39;s pixels we have to lock it and once we&#39;re done messing with the pixels we have to unlock it.</p>
<p>We have a function to get the raw pixels and a function to get the pitch. The pitch is basically the width of the texture in memory. On some older and mobile hardware, there are limitations of what size texture you can have. If you create a texture with a width of 100 pixels, it may get padded to 128 pixels wide (the next power of two). Using the pitch, we know how the image is in memory.</p>
<p>In terms of data members we have a pointer to the pixels after we lock the texture and the pitch.</p>
<pre><code>bool LTexture::loadFromFile( std::string path )
{
    //Get rid of preexisting texture
    free();

    //The final texture
    SDL_Texture* newTexture = NULL;

    //Load image at specified path
    SDL_Surface* loadedSurface = IMG_Load( path.c_str() );
    if( loadedSurface == NULL )
    {
        printf( &quot;Unable to load image %s! SDL_image Error: %s\n&quot;, path.c_str(), IMG_GetError() );
    }
    else
    {
        //Convert surface to display format
        SDL_Surface* formattedSurface = SDL_ConvertSurfaceFormat( loadedSurface, SDL_GetWindowPixelFormat( gWindow ), 0 );
        if( formattedSurface == NULL )
        {
            printf( &quot;Unable to convert loaded surface to display format! SDL Error: %s\n&quot;, SDL_GetError() );
        }
        else
        {
            //Create blank streamable texture
            newTexture = SDL_CreateTexture( gRenderer, SDL_GetWindowPixelFormat( gWindow ), SDL_TEXTUREACCESS_STREAMING, formattedSurface-&gt;w, formattedSurface-&gt;h );
            if( newTexture == NULL )
            {
                printf( &quot;Unable to create blank texture! SDL Error: %s\n&quot;, SDL_GetError() );
            }
</code></pre><p>To allow ourselves the ability to edit the texture, we have to load our textures differently. When we created textures from surfaces before, they had the default <a href="http://wiki.libsdl.org/SDL_TextureAccess">SDL_TextureAccess</a> of SDL_TEXTUREACCESS_STATIC, which means we can&#39;t change it after it is created. In order to be able to edit the texture&#39;s pixels we have to create the texture with SDL_TEXTUREACCESS_STREAMING.</p>
<p>First we have the load the image as a surface like before. We then have to convert the surface to the same pixel format as the window using <a href="http://wiki.libsdl.org/SDL_ConvertSurfaceFormat">SDL_ConvertSurfaceFormat</a> because we can&#39;t mix texture rendering and surface rendering calls. We then create a blank texture with <a href="http://wiki.libsdl.org/SDL_CreateTexture">SDL_CreateTexture</a>.</p>
<pre><code>            else
            {
                //Lock texture for manipulation
                SDL_LockTexture( newTexture, NULL, &amp;mPixels, &amp;mPitch );

                //Copy loaded/formatted surface pixels
                memcpy( mPixels, formattedSurface-&gt;pixels, formattedSurface-&gt;pitch * formattedSurface-&gt;h );

                //Unlock texture to update
                SDL_UnlockTexture( newTexture );
                mPixels = NULL;

                //Get image dimensions
                mWidth = formattedSurface-&gt;w;
                mHeight = formattedSurface-&gt;h;
            }

            //Get rid of old formatted surface
            SDL_FreeSurface( formattedSurface );
        }    

        //Get rid of old loaded surface
        SDL_FreeSurface( loadedSurface );
    }

    //Return success
    mTexture = newTexture;
    return mTexture != NULL;
}
</code></pre><p>After the texture is created we have to manually copy the pixels from the surface to the texture. To grab the pixels from the texture we use <a href="http://wiki.libsdl.org/SDL_LockTexture">SDL_LockTexture</a>. The first argument is the texture we&#39;ll be grabbing pixels from. The second argument is the region we want to grab pixels from and since we&#39;re getting the pixels from the whole texture we set this argument to NULL. The third argument is the pointer that will be set to the address of the pixels and the last argument will be set to the texture&#39;s pitch.</p>
<p>After we have the texture&#39;s pixels, we copy the pixels from the surface to the texture using memcpy. The first argument is the destination, the second argument is the source, and the third argument is the number of bytes we&#39;ll be copying. Fortunately, the pitch SDL gives us is the number of bytes per row of pixels so all we have to do is multiply by the height of the surface to copy in all the pixels from the image.</p>
<p>After we&#39;re done copying the pixels from the surface to the texture, we unlock the texture to update it with the new pixels using <a href="http://wiki.libsdl.org/SDL_UnlockTexture">SDL_UnlockTexture</a>. After the texture is unlocked the pixel pointer is invalid so we set it to NULL.</p>
<p>With the pixels from the surface copied into the texture, we then get rid of the old surfaces and return true if the texture loaded successfully.</p>
<pre><code>bool LTexture::lockTexture()
{
    bool success = true;

    //Texture is already locked
    if( mPixels != NULL )
    {
        printf( &quot;Texture is already locked!\n&quot; );
        success = false;
    }
    //Lock texture
    else
    {
        if( SDL_LockTexture( mTexture, NULL, &amp;mPixels, &amp;mPitch ) != 0 )
        {
            printf( &quot;Unable to lock texture! %s\n&quot;, SDL_GetError() );
            success = false;
        }
    }

    return success;
}

bool LTexture::unlockTexture()
{
    bool success = true;

    //Texture is not locked
    if( mPixels == NULL )
    {
        printf( &quot;Texture is not locked!\n&quot; );
        success = false;
    }
    //Unlock texture
    else
    {
        SDL_UnlockTexture( mTexture );
        mPixels = NULL;
        mPitch = 0;
    }

    return success;
}
</code></pre><p>Here are our functions to lock/unlock the texture after loading the image.</p>
<pre><code>void* LTexture::getPixels()
{
    return mPixels;
}

int LTexture::getPitch()
{
    return mPitch;
}
</code></pre><p>Finally here are the accessors to get the pixels and pitch while the texture is locked. Now that we can create a streamable texture and lock/unlock it, it is time to do some texture pixel processing.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load foo&#39; texture
    if( !gFooTexture.loadFromFile( &quot;40_texture_manipulation/foo.png&quot; ) )
    {
        printf( &quot;Failed to load corner texture!\n&quot; );
        success = false;
    }
    else
    {
        //Lock texture
        if( !gFooTexture.lockTexture() )
        {
            printf( &quot;Unable to lock Foo&#39; texture!\n&quot; );
        }
</code></pre><p>In our media loading function after we load the texture we lock it so we can alter its pixels.</p>
<pre><code>        //Manual color key
        else
        {            
            //Allocate format from window
            Uint32 format = SDL_GetWindowPixelFormat( gWindow );
            SDL_PixelFormat* mappingFormat = SDL_AllocFormat( format );

            //Get pixel data
            Uint32* pixels = (Uint32*)gFooTexture.getPixels();
            int pixelCount = ( gFooTexture.getPitch() / 4 ) * gFooTexture.getHeight();
</code></pre><p>After the texture is locked, we&#39;re going to go through the pixels and make all the background pixels transparent. What we&#39;re doing is essentially manually color keying the image.</p>
<p>First we allocate a pixel format using SDL_GetWindowPixelFormat and <a href="http://wiki.libsdl.org/SDL_AllocFormat">SDL_AllocFormat</a>. We then need to grab the pixels. Our pixel accessor returns a void pointer and we want 32bit pixels so we type cast it to a 32bit unsigned integer.</p>
<p>Next we want to get the number of pixels. We get the pitch which is the width in bytes. We need the width in pixels and since there are 4 bytes per pixel all we need to do is divide by 4 to get the pitch in pixels. Then we multiply the pitch width by the height to get the total number of pixels.</p>
<pre><code>            //Map colors
            Uint32 colorKey = SDL_MapRGB( mappingFormat, 0, 0xFF, 0xFF );
            Uint32 transparent = SDL_MapRGBA( mappingFormat, 0xFF, 0xFF, 0xFF, 0x00 );

            //Color key pixels
            for( int i = 0; i &lt; pixelCount; ++i )
            {
                if( pixels[ i ] == colorKey )
                {
                    pixels[ i ] = transparent;
                }
            }

            //Unlock texture
            gFooTexture.unlockTexture();

            //Free format
            SDL_FreeFormat( mappingFormat );
        }
    }

    return success;
}
</code></pre><p>What we&#39;re going to do is find all the pixels that are the color key color and then replace them with transparent pixels. First we map the color key color and the transparent color using the window&#39;s pixel format. Then we go through all the pixels and check if any of the pixels match the color key. If it does, we give it the value of a transparent pixel.</p>
<p>After we&#39;re done going through the pixels we unlock the texture to update it with the new pixels. Lastly we can&#39;t forget to call <a href="http://wiki.libsdl.org/SDL_FreeFormat">SDL_FreeFormat</a> to deallocate the pixel format we created.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/40_texture_manipulation/40_texture_manipulation.zip">here</a>.</p>
<h2 id="bitmap-fonts">Bitmap Fonts</h2>
<p><img src="./res/41_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Some times TTF fonts are flexible enough. Since rendering text is just rendering images of characters, we can use bitmap fonts to render text.<br>If you think of each character in a string as a sprite, you can think of font rendering as arranging a bunch of sprites:<br><img src="./res/41_sprites.jpg" alt=""></p>
<p>Bitmap fonts work by taking a sprite sheet of glyphs (character images) and rendering them in order to form strings on the screen.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        #if defined(_SDL_TTF_H) || defined(SDL_TTF_H)
        //Creates image from font string
        bool loadFromRenderedText( std::string textureText, SDL_Color textColor );
        #endif

        //Deallocates texture
        void free();

        //Set color modulation
        void setColor( Uint8 red, Uint8 green, Uint8 blue );

        //Set blending
        void setBlendMode( SDL_BlendMode blending );

        //Set alpha modulation
        void setAlpha( Uint8 alpha );

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL, double angle = 0.0, SDL_Point* center = NULL, SDL_RendererFlip flip = SDL_FLIP_NONE );

        //Gets image dimensions
        int getWidth();
        int getHeight();

        //Pixel manipulators
        bool lockTexture();
        bool unlockTexture();
        void* getPixels();
        int getPitch();
        Uint32 getPixel32( unsigned int x, unsigned int y );

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;
        void* mPixels;
        int mPitch;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>In previous tutorials when we did <a href="#texture-manipulation">texture pixel manipulation</a>, we didn&#39;t care which pixel we got since we wanted to grab all the pixels. Here we need to get pixels at exact x/y coordinates which is why we&#39;re adding a getPixel32 function. This function works specifically for 32bit pixels.</p>
<pre><code>//Our bitmap font
class LBitmapFont
{
    public:
        //The default constructor
        LBitmapFont();

        //Generates the font
        bool buildFont( LTexture *bitmap );

        //Shows the text
        void renderText( int x, int y, std::string text );

    private:
        //The font texture
        LTexture* mBitmap;

        //The individual characters in the surface
        SDL_Rect mChars[ 256 ];

        //Spacing Variables
        int mNewLine, mSpace;
};
</code></pre><p>Here is our bitmap font which functions as a wrapper for a sprite sheet of glyphs. It has a constructor to initialize internal variables, a function to build the font, and a function to render the text.</p>
<p>When the bitmap font is built we go through the texture and find all the character sprites for the 256 characters (that are stored in the mChars array) and calculate the distance for a new line and a space.</p>
<pre><code>bool LTexture::loadFromFile( std::string path )
{
    //Get rid of preexisting texture
    free();

    //The final texture
    SDL_Texture* newTexture = NULL;

    //Load image at specified path
    SDL_Surface* loadedSurface = IMG_Load( path.c_str() );
    if( loadedSurface == NULL )
    {
        printf( &quot;Unable to load image %s! SDL_image Error: %s\n&quot;, path.c_str(), IMG_GetError() );
    }
    else
    {
        //Convert surface to display format
        SDL_Surface* formattedSurface = SDL_ConvertSurfaceFormat( loadedSurface, SDL_PIXELFORMAT_RGBA8888, 0 );
        if( formattedSurface == NULL )
        {
            printf( &quot;Unable to convert loaded surface to display format! %s\n&quot;, SDL_GetError() );
        }
        else
        {
            //Create blank streamable texture
            newTexture = SDL_CreateTexture( gRenderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STREAMING, formattedSurface-&gt;w, formattedSurface-&gt;h );
            if( newTexture == NULL )
            {
                printf( &quot;Unable to create blank texture! SDL Error: %s\n&quot;, SDL_GetError() );
            }
            else
            {
                //Enable blending on texture
                SDL_SetTextureBlendMode( newTexture, SDL_BLENDMODE_BLEND );

                //Lock texture for manipulation
                SDL_LockTexture( newTexture, &amp;formattedSurface-&gt;clip_rect, &amp;mPixels, &amp;mPitch );

                //Copy loaded/formatted surface pixels
                memcpy( mPixels, formattedSurface-&gt;pixels, formattedSurface-&gt;pitch * formattedSurface-&gt;h );

                //Get image dimensions
                mWidth = formattedSurface-&gt;w;
                mHeight = formattedSurface-&gt;h;

                //Get pixel data in editable format
                Uint32* pixels = (Uint32*)mPixels;
                int pixelCount = ( mPitch / 4 ) * mHeight;

                //Map colors                
                Uint32 colorKey = SDL_MapRGB( formattedSurface-&gt;format, 0, 0xFF, 0xFF );
                Uint32 transparent = SDL_MapRGBA( formattedSurface-&gt;format, 0x00, 0xFF, 0xFF, 0x00 );

                //Color key pixels
                for( int i = 0; i &lt; pixelCount; ++i )
                {
                    if( pixels[ i ] == colorKey )
                    {
                        pixels[ i ] = transparent;
                    }
                }

                //Unlock texture to update
                SDL_UnlockTexture( newTexture );
                mPixels = NULL;
            }

            //Get rid of old formatted surface
            SDL_FreeSurface( formattedSurface );
        }    

        //Get rid of old loaded surface
        SDL_FreeSurface( loadedSurface );
    }

    //Return success
    mTexture = newTexture;
    return mTexture != NULL;
}
</code></pre><p>Here is our texture loading from the previous tutorial with some more tweaks. We did the color keying externally in the previous tutorial, and here we&#39;re doing it internally in the texture loading function.</p>
<p>Secondly, we&#39;re specifying the texture pixel format as SDL_PIXELFORMAT_RGBA8888 so we know we&#39;ll get 32bit RGBA pixels.</p>
<pre><code>Uint32 LTexture::getPixel32( unsigned int x, unsigned int y )
{
    //Convert the pixels to 32 bit
    Uint32 *pixels = (Uint32*)mPixels;

    //Get the pixel requested
    return pixels[ ( y * ( mPitch / 4 ) ) + x ];
}
</code></pre><p>Here is our function to get a pixel at a specific offset.</p>
<p>The important thing to know is that even though we have a 2 dimensional texture image like this:<br><img src="./res/41_2d.jpg" alt=""></p>
<p>Pixels are stored in one dimension like this:<br><img src="./res/41_1d.jpg" alt=""></p>
<p>So if you wanted to get the blue pixel in row 1, column 1 (the first row/column is row/column 0), you would have to calculate the offset like this:<br><strong>Y Offset * Pitch + X Offset</strong></p>
<p>Which comes out to:<br><strong>1 * 5 + 1 = 6</strong></p>
<p>And as you can see, the pixel at index 6 on the 1 dimensional pixels is the same as the one on row 1 column 1 on the 2 dimensional pixels.</p>
<p>And if you&#39;re wondering why we divide the pitch by 4, remember that the pitch is in bytes. Since we need the pitch in pixels and there&#39;s 4 bytes per pixel, we divide the pitch by 4.</p>
<pre><code>LBitmapFont::LBitmapFont()
{
    //Initialize variables
    mBitmap = NULL;
    mNewLine = 0;
    mSpace = 0;
}
</code></pre><p>Here in the constructor we initialize the internals.</p>
<pre><code>bool LBitmapFont::buildFont( LTexture* bitmap )
{
    bool success = true;

    //Lock pixels for access
    if( !bitmap-&gt;lockTexture() )
    {
        printf( &quot;Unable to lock bitmap font texture!\n&quot; );
        success = false;
    }
</code></pre><p>Now we&#39;re entering the function that&#39;s going to go through the bitmap font and define all the clip rectanges for all the sprites. To do that we&#39;ll have to lock the texture to access its pixels.</p>
<pre><code>    else
    {
        //Set the background color
        Uint32 bgColor = bitmap-&gt;getPixel32( 0, 0 );

        //Set the cell dimensions
        int cellW = bitmap-&gt;getWidth() / 16;
        int cellH = bitmap-&gt;getHeight() / 16;

        //New line variables
        int top = cellH;
        int baseA = cellH;

        //The current character we&#39;re setting
        int currentChar = 0;
</code></pre><p>In order for this bitmap font loading to work, the character glyphs need to be arranged in cells:<br><img src="./res/41_cells.jpg" alt=""></p>
<p>The cells all need to all have the same width and height, arranged in 16 columns and 16 rows, and need to be in ASCII order. The bitmap font loader is going to go through each of the cells, find the sides of the glyph sprites and set the clip rectangle for the sprite.</p>
<p>First we get the background color which we&#39;ll need to find the edges of the glyph sprites. Then we calculate the cell width and height. We have the variable called top which we will keep track of the top of the tallest glyph in the sprite sheet. The variable baseA will keep track of the offset of the bottom of the capital A glyph which will use as a base line for rendering characters.</p>
<p>Lastly we have the currentChar which keeps track of the current character glyph we&#39;re looking for.</p>
<pre><code>        //Go through the cell rows
        for( int rows = 0; rows &lt; 16; ++rows )
        {
            //Go through the cell columns
            for( int cols = 0; cols &lt; 16; ++cols )
            {
                //Set the character offset
                mChars[ currentChar ].x = cellW * cols;
                mChars[ currentChar ].y = cellH * rows;

                //Set the dimensions of the character
                mChars[ currentChar ].w = cellW;
                mChars[ currentChar ].h = cellH;
</code></pre><p>These two nested for loops are for going through the cell rows/columns.</p>
<p>At the top of per cell loop, we initialize the glyph sprite positon at the top of the cell and the sprite dimensions to be the cell dimensions. This means by default the glyph sprite is the full cell.</p>
<pre><code>                //Find Left Side
                //Go through pixel columns
                for( int pCol = 0; pCol &lt; cellW; ++pCol )
                {
                    //Go through pixel rows
                    for( int pRow = 0; pRow &lt; cellH; ++pRow )
                    {
                        //Get the pixel offsets
                        int pX = ( cellW * cols ) + pCol;
                        int pY = ( cellH * rows ) + pRow;

                        //If a non colorkey pixel is found
                        if( bitmap-&gt;getPixel32( pX, pY ) != bgColor )
                        {
                            //Set the x offset
                            mChars[ currentChar ].x = pX;

                            //Break the loops
                            pCol = cellW;
                            pRow = cellH;
                        }
                    }
                }
</code></pre><p>For each cell we need to go through all the pixels in the cell to find the edge of the glyph sprite. In this loop we go through each column from top to bottom and look for the first pixel that is not the background color. Once we find a pixel that is not the background color it means we found the left edge of the sprite:<br><img src="./res/41_fishing.gif" alt=""></p>
<p>When we find the left side of the glyph we set it as x position of the sprite and then break the loops.</p>
<pre><code>                //Find Right Side
                //Go through pixel columns
                for( int pColW = cellW - 1; pColW &gt;= 0; --pColW )
                {
                    //Go through pixel rows
                    for( int pRowW = 0; pRowW &lt; cellH; ++pRowW )
                    {
                        //Get the pixel offsets
                        int pX = ( cellW * cols ) + pColW;
                        int pY = ( cellH * rows ) + pRowW;

                        //If a non colorkey pixel is found
                        if( bitmap-&gt;getPixel32( pX, pY ) != bgColor )
                        {
                            //Set the width
                            mChars[ currentChar ].w = ( pX - mChars[ currentChar ].x ) + 1;

                            //Break the loops
                            pColW = -1;
                            pRowW = cellH;
                        }
                    }
                }
</code></pre><p>Here we&#39;re looking for the pixel on the right side. It works pretty much the same as finding the left side, only now we&#39;re moving from right to left instead of left to right.</p>
<p>When we find the right pixel, we use it to set the width. Since the pixel array starts at 0, we need to add 1 to the width.</p>
<pre><code>                //Find Top
                //Go through pixel rows
                for( int pRow = 0; pRow &lt; cellH; ++pRow )
                {
                    //Go through pixel columns
                    for( int pCol = 0; pCol &lt; cellW; ++pCol )
                    {
                        //Get the pixel offsets
                        int pX = ( cellW * cols ) + pCol;
                        int pY = ( cellH * rows ) + pRow;

                        //If a non colorkey pixel is found
                        if( bitmap-&gt;getPixel32( pX, pY ) != bgColor )
                        {
                            //If new top is found
                            if( pRow &lt; top )
                            {
                                top = pRow;
                            }

                            //Break the loops
                            pCol = cellW;
                            pRow = cellH;
                        }
                    }
                }
</code></pre><p>Here is the code to find the top of the sprite. When we find a top that is higher than the current highest top, we set it as the new top.</p>
<p>Note that since the y axis is inverted, the highest top actually has the lowest y offset.</p>
<pre><code>                //Find Bottom of A
                if( currentChar == &#39;A&#39; )
                {
                    //Go through pixel rows
                    for( int pRow = cellH - 1; pRow &gt;= 0; --pRow )
                    {
                        //Go through pixel columns
                        for( int pCol = 0; pCol &lt; cellW; ++pCol )
                        {
                            //Get the pixel offsets
                            int pX = ( cellW * cols ) + pCol;
                            int pY = ( cellH * rows ) + pRow;

                            //If a non colorkey pixel is found
                            if( bitmap-&gt;getPixel32( pX, pY ) != bgColor )
                            {
                                //Bottom of a is found
                                baseA = pRow;

                                //Break the loops
                                pCol = cellW;
                                pRow = -1;
                            }
                        }
                    }
                }

                //Go to the next character
                ++currentChar;
            }
        }
</code></pre><p>In terms of looking for the bottom of the glyphs, the only one we care about is the capital A. For this bitmap font builder we&#39;re going to use the bottom of the A glyph sprite as the base line so characters like &quot;g&quot;, &quot;j&quot;, &quot;y&quot;, etc that hang below the baseline don&#39;t define the bottom. You don&#39;t have to do it this way, but it&#39;s given me good results before.</p>
<pre><code>        //Calculate space
        mSpace = cellW / 2;

        //Calculate new line
        mNewLine = baseA - top;

        //Lop off excess top pixels
        for( int i = 0; i &lt; 256; ++i )
        {
            mChars[ i ].y += top;
            mChars[ i ].h -= top;
        }

        bitmap-&gt;unlockTexture();
        mBitmap = bitmap;
    }

    return success;
}
</code></pre><p>After we&#39;re done defining all the sprites, we have some post processing to do. First we calculate how long a space is. Here we&#39;re defining it as half a cell width. We then calculate the height of a new line by using the baseline and the highest sprite top.</p>
<p>We then lop off the extra space at the top of each glyph to prevent there from being too much space between lines. Finally we unlock the texture and set the bitmap for the bitmap font.</p>
<p>Now the way we constructed the bitmap font isn&#39;t the only way to do it. You can define spaces, new lines, and base lines another way. You use an XML file to define the positions of the sprites instead of using cells. I decided to go with this method because it&#39;s a common one and it has worked for me.</p>
<pre><code>void LBitmapFont::renderText( int x, int y, std::string text )
{
    //If the font has been built
    if( mBitmap != NULL )
    {
        //Temp offsets
        int curX = x, curY = y;
</code></pre><p>Now that we have all the glyph sprites defined, it&#39;s time to render them to the screen. First we check that there is a bitmap to render with, then we declare x/y offsets that we&#39;ll be using to render the current glyph sprite.</p>
<pre><code>        //Go through the text
        for( int i = 0; i &lt; text.length(); ++i )
        {
            //If the current character is a space
            if( text[ i ] == &#39; &#39; )
            {
                //Move over
                curX += mSpace;
            }
            //If the current character is a newline
            else if( text[ i ] == &#39;\n&#39; )
            {
                //Move down
                curY += mNewLine;

                //Move back
                curX = x;
            }
</code></pre><p>Here is the for loop that goes through the string to render each glyph sprite. However there are two ASCII values we&#39;re not actually going to render anything for. When we have a space, all we have to do is move over the space width. When we have a new line we move down a new line and back to the base x offset.</p>
<pre><code>            else
            {
                //Get the ASCII value of the character
                int ascii = (unsigned char)text[ i ];

                //Show the character
                mBitmap-&gt;render( curX, curY, &amp;mChars[ ascii ] );

                //Move over the width of the character with one pixel of padding
                curX += mChars[ ascii ].w + 1;
            }
        }
    }
}
</code></pre><p>For nonspecial characters, we render the sprite. As you can see, it&#39;s as simple as getting the ASCII value, rendering the sprite associated with the ASCII value and then moving over the width of the sprite.</p>
<p>The for loop will then keep going through all the characters and rendering the sprite for each of them one after the other.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/41_bitmap_fonts/41_bitmap_fonts.zip">here</a>.</p>
<h2 id="texture-streaming">Texture Streaming</h2>
<p><img src="./res/42_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Sometimes we want to render pixel data from a source other than a bitmap like a web cam. Using texture stream we can render pixels from any source.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        #if defined(_SDL_TTF_H) || defined(SDL_TTF_H)
        //Creates image from font string
        bool loadFromRenderedText( std::string textureText, SDL_Color textColor );
        #endif

        //Creates blank texture
        bool createBlank( int width, int height );

        //Deallocates texture
        void free();

        //Set color modulation
        void setColor( Uint8 red, Uint8 green, Uint8 blue );

        //Set blending
        void setBlendMode( SDL_BlendMode blending );

        //Set alpha modulation
        void setAlpha( Uint8 alpha );

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL, double angle = 0.0, SDL_Point* center = NULL, SDL_RendererFlip flip = SDL_FLIP_NONE );

        //Gets image dimensions
        int getWidth();
        int getHeight();

        //Pixel manipulators
        bool lockTexture();
        bool unlockTexture();
        void* getPixels();
        void copyPixels( void* pixels );
        int getPitch();
        Uint32 getPixel32( unsigned int x, unsigned int y );

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;
        void* mPixels;
        int mPitch;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>Here we&#39;re adding more functionality to our texture class. The createBlank function allocates a blank texture that we can copy data to when streaming. The copyPixels function copies in the pixel data we want to stream.</p>
<pre><code>//A test animation stream
class DataStream
{
    public:
        //Initializes internals
        DataStream();

        //Loads initial data
        bool loadMedia();

        //Deallocator
        void free();

        //Gets current frame data
        void* getBuffer();

    private:
        //Internal data
        SDL_Surface* mImages[ 4 ];
        int mCurrentImage;
        int mDelayFrames;
};
</code></pre><p>Here is our data stream class. We won&#39;t go deep into how it works because we don&#39;t really care. When dealing with web cam, video decoding, etc APIs they typically don&#39;t go deep into how they work because all we care about is getting the video and audio data from them.</p>
<p>All we really care about is that getBuffer function which gets the current pixels from the data buffer.</p>
<pre><code>bool LTexture::createBlank( int width, int height )
{
    //Create uninitialized texture
    mTexture = SDL_CreateTexture( gRenderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STREAMING, width, height );
    if( mTexture == NULL )
    {
        printf( &quot;Unable to create blank texture! SDL Error: %s\n&quot;, SDL_GetError() );
    }
    else
    {
        mWidth = width;
        mHeight = height;
    }

    return mTexture != NULL;
}
</code></pre><p>As you can see, all this function does is create a 32bit RGBA texture with stream access. One thing you have to make sure of when creating your texture is that the format of the texture pixels matches the format of the pixels we&#39;re streaming.</p>
<pre><code>void LTexture::copyPixels( void* pixels )
{
    //Texture is locked
    if( mPixels != NULL )
    {
        //Copy to locked pixels
        memcpy( mPixels, pixels, mPitch * mHeight );
    }
}
</code></pre><p>Here is our function to copy in the pixels from the stream. The function assumes the texture is locked and that the pixels are from an image the same size as the texture.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Copy frame from buffer
                gStreamingTexture.lockTexture();
                gStreamingTexture.copyPixels( gDataStream.getBuffer() );
                gStreamingTexture.unlockTexture();

                //Render frame
                gStreamingTexture.render( ( SCREEN_WIDTH - gStreamingTexture.getWidth() ) / 2, ( SCREEN_HEIGHT - gStreamingTexture.getHeight() ) / 2 );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>In the main loop rendering we lock our stream texture, copy the pixels from the stream and then unlock the texture. With our texture holding the latest image from the stream, we render the image to the screen.</p>
<p>When dealing with decoding APIs things may get trickier where we have to convert from one format to another but ultimately all we need is a means to get the pixel data and copy it to the screen.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/42_texture_streaming/42_texture_streaming.zip">here</a>.</p>
<h2 id="render-to-texture">Render to Texture</h2>
<p><img src="./res/43_preview.png" alt=""></p>
<p><strong>Last Updated 6/06/19</strong></p>
<p>For some effects being able to render a scene to texture is needed. Here we&#39;ll be rendering a scene to a texture to achieve a spinning scene effect.</p>
<pre><code>//Texture wrapper class
class LTexture
{
    public:
        //Initializes variables
        LTexture();

        //Deallocates memory
        ~LTexture();

        //Loads image at specified path
        bool loadFromFile( std::string path );

        #if defined(_SDL_TTF_H) || defined(SDL_TTF_H)
        //Creates image from font string
        bool loadFromRenderedText( std::string textureText, SDL_Color textColor );
        #endif

        //Creates blank texture
        bool createBlank( int width, int height, SDL_TextureAccess = SDL_TEXTUREACCESS_STREAMING );

        //Deallocates texture
        void free();

        //Set color modulation
        void setColor( Uint8 red, Uint8 green, Uint8 blue );

        //Set blending
        void setBlendMode( SDL_BlendMode blending );

        //Set alpha modulation
        void setAlpha( Uint8 alpha );

        //Renders texture at given point
        void render( int x, int y, SDL_Rect* clip = NULL, double angle = 0.0, SDL_Point* center = NULL, SDL_RendererFlip flip = SDL_FLIP_NONE );

        //Set self as render target
        void setAsRenderTarget();

        //Gets image dimensions
        int getWidth();
        int getHeight();

        //Pixel manipulators
        bool lockTexture();
        bool unlockTexture();
        void* getPixels();
        void copyPixels( void* pixels );
        int getPitch();
        Uint32 getPixel32( unsigned int x, unsigned int y );

    private:
        //The actual hardware texture
        SDL_Texture* mTexture;
        void* mPixels;
        int mPitch;

        //Image dimensions
        int mWidth;
        int mHeight;
};
</code></pre><p>Here we are adding more functionality to the texture class. The createBlank function now takes in another argument that defines how it is accessed. We also have the setAsRenderTarget function which makes it so we can render to this texture.</p>
<pre><code>bool LTexture::createBlank( int width, int height, SDL_TextureAccess access )
{
    //Create uninitialized texture
    mTexture = SDL_CreateTexture( gRenderer, SDL_PIXELFORMAT_RGBA8888, access, width, height );
    if( mTexture == NULL )
    {
        printf( &quot;Unable to create blank texture! SDL Error: %s\n&quot;, SDL_GetError() );
    }
    else
    {
        mWidth = width;
        mHeight = height;
    }

    return mTexture != NULL;
}
</code></pre><p>When we want to render to a texture we need to set its texture access to <a href="http://wiki.libsdl.org/SDL_TextureAccess">SDL_TEXTUREACCESS_TARGET</a>, which is why this function takes an additional argument now.</p>
<pre><code>void LTexture::setAsRenderTarget()
{
    //Make self render target
    SDL_SetRenderTarget( gRenderer, mTexture );
}
</code></pre><p>To render to a texture we have to set it as the render target which is done here using a call to <a href="http://wiki.libsdl.org/SDL_SetRenderTarget">SDL_SetRenderTarget</a>.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load texture target
    if( !gTargetTexture.createBlank( SCREEN_WIDTH, SCREEN_HEIGHT, SDL_TEXTUREACCESS_TARGET ) )
    {
        printf( &quot;Failed to create target texture!\n&quot; );
        success = false;
    }

    return success;
}
</code></pre><p>We create our target texture in the media loading function.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Rotation variables
            double angle = 0;
            SDL_Point screenCenter = { SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 };
</code></pre><p>For this demo we&#39;ll render some geometry to a texture and spin that texture around the center of the screen. This is why we have variables for angle of rotation and center of screen.</p>
<pre><code>            //While application is running
            while( quit == false )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //rotate
                angle += 2;
                if( angle &gt; 360 )
                {
                    angle -= 360;
                }

                //Set self as render target
                gTargetTexture.setAsRenderTarget();

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render red filled quad
                SDL_Rect fillRect = { SCREEN_WIDTH / 4, SCREEN_HEIGHT / 4, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 };
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0x00, 0x00, 0xFF );        
                SDL_RenderFillRect( gRenderer, &amp;fillRect );

                //Render green outlined quad
                SDL_Rect outlineRect = { SCREEN_WIDTH / 6, SCREEN_HEIGHT / 6, SCREEN_WIDTH * 2 / 3, SCREEN_HEIGHT * 2 / 3 };
                SDL_SetRenderDrawColor( gRenderer, 0x00, 0xFF, 0x00, 0xFF );        
                SDL_RenderDrawRect( gRenderer, &amp;outlineRect );

                //Draw blue horizontal line
                SDL_SetRenderDrawColor( gRenderer, 0x00, 0x00, 0xFF, 0xFF );        
                SDL_RenderDrawLine( gRenderer, 0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2 );

                //Draw vertical line of yellow dots
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0x00, 0xFF );
                for( int i = 0; i &lt; SCREEN_HEIGHT; i += 4 )
                {
                    SDL_RenderDrawPoint( gRenderer, SCREEN_WIDTH / 2, i );
                }

                //Reset render target
                SDL_SetRenderTarget( gRenderer, NULL );

                //Show rendered to texture
                gTargetTexture.render( 0, 0, NULL, angle, &amp;screenCenter );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>In our main loop before we do any rendering we set the target texture as a target. We then render our scene full of geometry and once we&#39;re done rendering to a texture we call SDL_SetRenderTarget with a NULL texture so any rendering done afterward will be done to the screen.</p>
<p>With our scene rendered to a texture, we then render the target texture to the screen at a rotated angle.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/43_render_to_texture/43_render_to_texture.zip">here</a>.</p>
<h2 id="frame-independent-movement">Frame Independent Movement</h2>
<p><img src="./res/44_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Whether you want to be able to handle unstable frame rates or support multiple frame rates, you can set your movement based on time to make it independent of frame rate.</p>
<pre><code>//The dot that will move around on the screen
class Dot
{
    public:
        //The dimensions of the dot
        static const int DOT_WIDTH = 20;
        static const int DOT_HEIGHT = 20;

        //Maximum axis velocity of the dot
        static const int DOT_VEL = 640;

        //Initializes the variables
        Dot();

        //Takes key presses and adjusts the dot&#39;s velocity
        void handleEvent( SDL_Event&amp; e );

        //Moves the dot
        void move( float timeStep );

        //Shows the dot on the screen
        void render();

    private:
        float mPosX, mPosY;
        float mVelX, mVelY;
};
</code></pre><p>The dot class returns adapted for frame independent movement. Notice how the velocity is now 640. The way we did per frame velocity previously would have caused this to fly across the screen in a single frame. For this demo we&#39;re going to base things on time and the standard unit of time is 1 second. 640 pixels per second translates into little more than 10 pixels per frame in a 60 frames per second application.</p>
<p>In order to move based on frame time, the move function needs to know how much time is moving per frame. This is why the move function takes in a time step which is how much time has passed since the last update.</p>
<p>Also notice how the position and velocity are floats instead of integers. If we used integers the motion would be always truncated to the nearest integer which would cause greater inaccuracies.</p>
<pre><code>void Dot::move( float timeStep )
{
    //Move the dot left or right
    mPosX += mVelX * timeStep;

    //If the dot went too far to the left or right
    if( mPosX &lt; 0 )
    {
        mPosX = 0;
    }
    else if( mPosX &gt; SCREEN_WIDTH - DOT_WIDTH )
    {
        mPosX = SCREEN_WIDTH - DOT_WIDTH;
    }

    //Move the dot up or down
    mPosY += mVelY * timeStep;

    //If the dot went too far up or down
    if( mPosY &lt; 0 )
    {
        mPosY = 0;
    }
    else if( mPosY &gt; SCREEN_HEIGHT - DOT_HEIGHT )
    {
        mPosY = SCREEN_HEIGHT - DOT_HEIGHT;
    }
}
</code></pre><p>Here is the move function changed for time based movement as opposed to frame based movement.</p>
<p>We update the position by moving it over by velocity <em> time. Say if we had (for simplicity&#39;s sake) a velocity of 600 pixels per second and a time step of 1 60th of a second. This means we would move over by 600 </em> 1/60 pixels or 10 pixels.</p>
<p>Because of the non uniform movement we can&#39;t just move back when we go off screen, we have to correct the value to be something on screen.</p>
<pre><code>void Dot::render()
{
    //Show the dot
    gDotTexture.render( (int)mPosX, (int)mPosY );
}
</code></pre><p>To prevent the compiler from barking at us, we convert the positions to integers when rendering the dot.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //The dot that will be moving around on the screen
            Dot dot;

            //Keeps track of time between steps
            LTimer stepTimer;
</code></pre><p>For this demo we disabled vsync to show it can run regardless of the frame rate. In order to know how much time has passed between renders, we need a timer to keep track of the time step.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }

                    //Handle input for the dot
                    dot.handleEvent( e );
                }

                //Calculate time step
                float timeStep = stepTimer.getTicks() / 1000.f;

                //Move for time step
                dot.move( timeStep );

                //Restart step timer
                stepTimer.start();

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render dot
                dot.render();

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
</code></pre><p>When we move around the dot we first get the time from the step time so we know how much time has passed since the last time we moved. We turn it from milliseconds into seconds and pass it to the move function. After we&#39;re done moving we restart the step timer so we&#39;ll know how much time has passed for when we need to move again. Finally we render as we normally do.</p>
<p>For most of these tutorials, things are simplified to make things easier to digest. For most if not all applications we use time based movement as opposed to frame based movement. Even when we have a fixed frame rate, we just use a constant time step. The thing is when using time based movement you run into problems with floating point errors which require vector math to fix, and vector math is beyond the scope of this tutorial which is why frame based movement is used for most of the tutorials.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/44_frame_independent_movement/44_frame_independent_movement.zip">here</a>.</p>
<h2 id="timer-callbacks">Timer Callbacks</h2>
<p><img src="./res/45_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>We&#39;ve covered <a href="#advanced-timers">timers with SDL before</a>, but there are also timer callbacks which execute a function after a given amount of time. In this tutorial we&#39;ll make a simple program that prints to the console after a set time.</p>
<pre><code>//Our test callback function
Uint32 callback( Uint32 interval, void* param );
</code></pre><p>When creating a call back function, know that they have to be declared a certain way. You can&#39;t just create any type of function and use it as a callback.</p>
<p>The call back function needs to have a 32 bit integer as its first argument, a void pointer as its second argument, and it has to return a 32 bit integer.</p>
<pre><code>Uint32 callback( Uint32 interval, void* param )
{
    //Print callback message
    printf( &quot;Callback called back with message: %s\n&quot;, (char*)param );

    return 0;
}
</code></pre><p>Here is our simple call back function which prints a message to the console after a given amount of time. The interval argument isn&#39;t used here but is typically used for timer call backs that need to repeat themselves.</p>
<p>Since void pointers can point to anything, this function is going to take in a string and print it to the console.</p>
<pre><code>    //Initialize SDL
    if (SDL_Init( SDL_INIT_VIDEO | SDL_INIT_TIMER ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
</code></pre><p>Do make sure to initialize with SDL_INIT_TIMER to use timer callbacks.</p>
<pre><code>            //Set callback
            SDL_TimerID timerID = SDL_AddTimer( 3 * 1000, callback, &quot;3 seconds waited!&quot; );

            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render splash
                gSplashTexture.render( 0, 0 );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }

            //Remove timer in case the call back was not called
            SDL_RemoveTimer( timerID );
</code></pre><p>We kick off our timer callback using <a href="http://wiki.libsdl.org/SDL_AddTimer">SDL_AddTimer</a>. The first argument is how long the callback will take which in this case is set to 3000 milliseconds or 3 seconds. The second argument is the callback function and the last argument is the void data pointer we&#39;re sending it.</p>
<p>This application will kick off the call back and then run the main loop. While the main loop is running the callback may spit out the message to the console. In case the callback doesn&#39;t happen before the main loop ends, we remove the callback timer using <a href="http://wiki.libsdl.org/SDL_RemoveTimer">SDL_RemoveTimer</a>. Careful, the timer call back is asynchronous which means it can happen while we&#39;re doing something else. Don&#39;t have your call back mess with data while your main thread is messing with that same piece of data.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/45_timer_callbacks/45_timer_callbacks.zip">here</a>.</p>
<h2 id="multithreading">Multithreading</h2>
<p><img src="./res/46_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Multithreading can be used to make your program execute two things at once and take advantage of multithreaded architectures. Here we&#39;ll make a simple program that outputs to the console while the main thread runs.<br>There is a saying in computer science:<br><strong>Premature optimization is the root of all evil</strong><br>A major problem with newbie programmers is that they want to be like the professionals without paying their dues. They hear about a technology that the latest and greatest developers out there are using and they think if they use it too it will make them magically better.</p>
<p>One of these tools is multithreading. Since multicore processors launched at a consumer level in the early 00s, developers have been using this new tech to squeeze out as much performance as they can from their applications.</p>
<p><strong>Here&#39;s the important part</strong>: a poorly made multithreaded program can perform worse than a single threaded program. Much worse. The fact is that multithreading inherently adds more overhead because threads then have to be managed. If you do not know the costs of using different multithreading tools, you can end up with code that is much slower than its single threaded equivalent.</p>
<p>The general rule is if you don&#39;t know:</p>
<ul>
<li>What cache coherency is.</li><li>What cache alignment is.</li><li>How operating systems handle threads and processes.</li><li>How to use a profiler.</li></ul>
<p>You should not be trying to use multithreaded optimization. Play with fire and you will get burned. However doing something not for the sake of performance like asynchronous file loading isn&#39;t a bad idea for intermediate game developers.</p>
<pre><code>//Using SDL, SDL Threads, SDL_image, standard IO, and, strings
#include &lt;SDL.h&gt;
#include &lt;SDL_thread.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
</code></pre><p>When we want to use threads we need to make sure to include the SDL threads header.</p>
<pre><code>//Our test thread function
int threadFunction( void* data );
</code></pre><p>Just like with callback functions, thread functions need to declared a certain way. They need to take in a void pointer as an argument and return an integer.</p>
<pre><code>int threadFunction( void* data )
{
    //Print incoming data
    printf( &quot;Running thread with value = %d\n&quot;, (int)data );

    return 0;
}
</code></pre><p>Our thread function is fairly simple. All it does is take in the data as an integer and uses it to print a message to the console.</p>
<pre><code>            //Run the thread
            int data = 101;
            SDL_Thread* threadID = SDL_CreateThread( threadFunction, &quot;LazyThread&quot;, (void*)data );

            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render prompt
                gSplashTexture.render( 0, 0 );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }

            //Remove timer in case the call back was not called
            SDL_WaitThread( threadID, NULL );
</code></pre><p>Before we enter the main loop we run the thread function using <a href="http://wiki.libsdl.org/SDL_CreateThread">SDL_CreateThread</a>. This call will run the function in first argument, give it the name in the second argument (names are used to identify it for debugging purposes), and passes in the data from the third argument.</p>
<p>The thread will then execute while the main thread is still going. In case the main loop ends before the thread finishes, we make a call to <a href="http://wiki.libsdl.org/SDL_WaitThread">SDL_WaitThread</a> to make sure the thread finishes before the application closes.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/46_multithreading/46_multithreading.zip">here</a>.</p>
<h2 id="semaphores">Semaphores</h2>
<p><img src="./res/47_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>The only <a href="#multithreading">multithreading</a> we&#39;ve done had the main thread and a second thread each do their own thing. In most cases two threads will have to share data and with semaphores you can prevent two threads from accidentally accessing the same piece of data at once.</p>
<pre><code>//Our worker thread function
int worker( void* data );
</code></pre><p>Here is our worker thread function. We will spawn two threads that will each execute their copy of this code.</p>
<pre><code>//Data access semaphore
SDL_sem* gDataLock = NULL;

//The &quot;data buffer&quot;
int gData = -1;
</code></pre><p>The object gDataLock is our semaphore which will lock our gData buffer. A single integer is not much of a data buffer to protect, but since there are going to be two threads that are going to be reading and writing to it we need to make sure it is only being accessed by one thread at a time.</p>
<pre><code>bool loadMedia()
{
    //Initialize semaphore
    gDataLock = SDL_CreateSemaphore( 1 );

    //Loading success flag
    bool success = true;

    //Load splash texture
    if( !gSplashTexture.loadFromFile( &quot;47_semaphores/splash.png&quot; ) )
    {
        printf( &quot;Failed to load splash texture!\n&quot; );
        success = false;
    }

    return success;
}
</code></pre><p>To create a semaphore we call <a href="http://wiki.libsdl.org/SDL_CreateSemaphore">SDL_CreateSemaphore</a> with an initial value for the semaphore. The initial value controls how many times code can pass through a semaphore before it locks.</p>
<p>For example, say you only want 4 threads to run at a time because you&#39;re on hardware with 4 cores. You&#39;d give the semaphore a value of 4 to start with to make sure no more than 4 threads run at the same time. In this demo we only want 1 thread accessing the data buffer at once so the mutex starts with a value of one.</p>
<pre><code>void close()
{
    //Free loaded images
    gSplashTexture.free();

    //Free semaphore
    SDL_DestroySemaphore( gDataLock );
    gDataLock = NULL;

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>When we&#39;re done with a semaphore we call <a href="http://wiki.libsdl.org/SDL_DestroySemaphore">SDL_DestroySemaphore</a>.</p>
<pre><code>int worker( void* data )
{
    printf( &quot;%s starting...\n&quot;, data );

    //Pre thread random seeding
    srand( SDL_GetTicks() );
</code></pre><p>Here we are starting our worker thread. An important thing to know is that seeding your random value is done per thread, so make sure you seed your random values for each thread you run.</p>
<pre><code>    //Work 5 times
    for( int i = 0; i &lt; 5; ++i )
    {
        //Wait randomly
        SDL_Delay( 16 + rand() % 32 );

        //Lock
        SDL_SemWait( gDataLock );

        //Print pre work data
        printf( &quot;%s gets %d\n&quot;, data, gData );

        //&quot;Work&quot;
        gData = rand() % 256;

        //Print post work data
        printf( &quot;%s sets %d\n\n&quot;, data, gData );

        //Unlock
        SDL_SemPost( gDataLock );

        //Wait randomly
        SDL_Delay( 16 + rand() % 640 );
    }

    printf( &quot;%s finished!\n\n&quot;, data );

    return 0;
}
</code></pre><p>What each worker thread does is delay for a semi random amount, print the data that is there when it started working, assign a random number to it, print the number assigned to the data buffer, and delay for a bit more before working again. The reason we need to lock data is because we do not want two threads reading or writing our shared data at the same time.</p>
<p>Notice the calls to <a href="http://wiki.libsdl.org/SDL_SemWait">SDL_SemWait</a> and <a href="http://wiki.libsdl.org/SDL_SemPost">SDL_SemPost</a>. What&#39;s in between them is the critical section or the code we only want one thread to access at once. SDL_SemWait decrements the semaphore count and since the initial value is one, it will lock. After the critical section executes, we call SDL_SemPost to increment the semaphore and unlock it.</p>
<p>If we have a situation where thread A locks and then thread B tries to lock, thread B will wait until thread A finishes the critical section and unlocks the semaphore. With the critical section protected by a semaphore lock/unlock pair, only one thread can execute the critical section at once.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Run the threads
            srand( SDL_GetTicks() );
            SDL_Thread* threadA = SDL_CreateThread( worker, &quot;Thread A&quot;, (void*)&quot;Thread A&quot; );
            SDL_Delay( 16 + rand() % 32 );
            SDL_Thread* threadB = SDL_CreateThread( worker, &quot;Thread B&quot;, (void*)&quot;Thread B&quot; );
</code></pre><p>In the main function before we enter the main loop we launch two worker threads with a bit of random delay in between them. There no guarantee thread A or B will work first but since the data they share is protected, we know they won&#39;t try to execute the same piece of code at once.</p>
<pre><code>            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render splash
                gSplashTexture.render( 0, 0 );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }

            //Wait for threads to finish
            SDL_WaitThread( threadA, NULL );
            SDL_WaitThread( threadB, NULL );
</code></pre><p>Here the main thread runs while the threads to their work. If the main loop end before the threads finish working, we wait on them to finish with SDL_WaitThread.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/47_semaphores/47_semaphores.zip">here</a>.</p>
<h2 id="atomic-operations">Atomic Operations</h2>
<p><img src="./res/48_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p><a href="#semaphores">Semaphores</a> operate at an operating system level. Atomic operations are a way to lock data at an efficient CPU level. Here we&#39;ll be locking a critical section using CPU spinlocks.</p>
<pre><code>//Data access spin lock
SDL_SpinLock gDataLock = 0;

//The &quot;data buffer&quot;
int gData = -1;
</code></pre><p>Instead of a semaphore we&#39;ll be using a spinlock to protect our data buffer.</p>
<pre><code>bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load splash texture
    if( !gSplashTexture.loadFromFile( &quot;48_atomic_operations/splash.png&quot; ) )
    {
        printf( &quot;Failed to load splash texture!\n&quot; );
        success = false;
    }

    return success;
}

void close()
{
    //Free loaded images
    gSplashTexture.free();

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>Unlike semaphores, spin locks do not need to be allocated and deallocated.</p>
<pre><code>int worker( void* data )
{
    printf( &quot;%s starting...\n&quot;, data );

    //Pre thread random seeding
    srand( SDL_GetTicks() );

    //Work 5 times
    for( int i = 0; i &lt; 5; ++i )
    {
        //Wait randomly
        SDL_Delay( 16 + rand() % 32 );

        //Lock
        SDL_AtomicLock( &amp;gDataLock );

        //Print pre work data
        printf( &quot;%s gets %d\n&quot;, data, gData );

        //&quot;Work&quot;
        gData = rand() % 256;

        //Print post work data
        printf( &quot;%s sets %d\n\n&quot;, data, gData );

        //Unlock
        SDL_AtomicUnlock( &amp;gDataLock );

        //Wait randomly
        SDL_Delay( 16 + rand() % 640 );
    }

    printf( &quot;%s finished!\n\n&quot;, data );

    return 0;
}
</code></pre><p>Here our critical section is protected by <a href="http://wiki.libsdl.org/SDL_AtomicLock">SDL_AtomicLock</a> and <a href="http://wiki.libsdl.org/SDL_AtomicUnlock">SDL_AtomicUnlock</a>.</p>
<p>In this case it may seem like semaphores and atomic locks are the same, but remember that semaphores can allow access beyond a single thread. Atomic operations are for when you want a strict locked/unlocked state.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/48_atomic_operations/48_atomic_operations.zip">here</a>.</p>
<h2 id="mutexes-and-conditions">Mutexes and Conditions</h2>
<p><img src="./res/49_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>Not only can you lock <a href="#semaphores">critial sections</a> in threads, but with mutexes and conditions it is possible for threads to tell each other when to unlock.</p>
<pre><code>//Our worker functions
int producer( void* data );
int consumer( void* data );
void produce();
void consume();
</code></pre><p>For this demo we&#39;ll have two threads: a producer which fills a buffer and a consumer that empties a buffer. Not only can the two threads not use the same buffer at the same time, but a consumer can&#39;t read from an empty buffer and a producer can&#39;t fill a buffer that&#39;s already full.</p>
<p>We&#39;ll use a mutex (mutually exclusive) to prevent the two threads from grabbing the same piece of data and conditions to let the threads know when they can consume and can produce.</p>
<pre><code>//The protective mutex
SDL_mutex* gBufferLock = NULL;

//The conditions
SDL_cond* gCanProduce = NULL;
SDL_cond* gCanConsume = NULL;

//The &quot;data buffer&quot;
int gData = -1;
</code></pre><p>Here we&#39;re globally declaring the mutex and conditions that will be used by the threads.</p>
<pre><code>bool loadMedia()
{
    //Create the mutex
    gBufferLock = SDL_CreateMutex();

    //Create conditions
    gCanProduce = SDL_CreateCond();
    gCanConsume = SDL_CreateCond();

    //Loading success flag
    bool success = true;

    //Load splash texture
    if( !gSplashTexture.loadFromFile( &quot;49_mutexes_and_conditions/splash.png&quot; ) )
    {
        printf( &quot;Failed to load splash texture!\n&quot; );
        success = false;
    }

    return success;
}
</code></pre><p>To allocate mutexes and conditons we use <a href="http://wiki.libsdl.org/SDL_CreateMutex">SDL_CreateMutex</a> and <a href="http://wiki.libsdl.org/SDL_CreateCond">SDL_CreateCond</a> respectively.</p>
<pre><code>void close()
{
    //Free loaded images
    gSplashTexture.free();

    //Destroy the mutex
    SDL_DestroyMutex( gBufferLock );
    gBufferLock = NULL;

    //Destroy conditions
    SDL_DestroyCond( gCanProduce );
    SDL_DestroyCond( gCanConsume );
    gCanProduce = NULL;
    gCanConsume = NULL;

    //Destroy window    
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    IMG_Quit();
    SDL_Quit();
}
</code></pre><p>And to deallocate mutexes and conditions we use <a href="http://wiki.libsdl.org/SDL_DestroyMutex">SDL_DestroyMutex</a> and <a href="http://wiki.libsdl.org/SDL_DestroyCond">SDL_DestroyCond</a>.</p>
<pre><code>int producer( void *data )
{
    printf( &quot;\nProducer started...\n&quot; );

    //Seed thread random
    srand( SDL_GetTicks() );

    //Produce
    for( int i = 0; i &lt; 5; ++i )
    {
        //Wait
        SDL_Delay( rand() % 1000 );

        //Produce
        produce();
    }

    printf( &quot;\nProducer finished!\n&quot; );

    return 0;

}

int consumer( void *data )
{
    printf( &quot;\nConsumer started...\n&quot; );

    //Seed thread random
    srand( SDL_GetTicks() );

    for( int i = 0; i &lt; 5; ++i )
    {
        //Wait
        SDL_Delay( rand() % 1000 );

        //Consume
        consume();
    }

    printf( &quot;\nConsumer finished!\n&quot; );

    return 0;
}
</code></pre><p>So here are our two worker threads. The producer tries to produce 5 times and the consumer tries to consume 5 times.</p>
<pre><code>void produce()
{
    //Lock
    SDL_LockMutex( gBufferLock );

    //If the buffer is full
    if( gData != -1 )
    {
        //Wait for buffer to be cleared
        printf( &quot;\nProducer encountered full buffer, waiting for consumer to empty buffer...\n&quot; );
        SDL_CondWait( gCanProduce, gBufferLock );
    }

    //Fill and show buffer
    gData = rand() % 255;
    printf( &quot;\nProduced %d\n&quot;, gData );

    //Unlock
    SDL_UnlockMutex( gBufferLock );

    //Signal consumer
    SDL_CondSignal( gCanConsume );
}

void consume()
{
    //Lock
    SDL_LockMutex( gBufferLock );

    //If the buffer is empty
    if( gData == -1 )
    {
        //Wait for buffer to be filled
        printf( &quot;\nConsumer encountered empty buffer, waiting for producer to fill buffer...\n&quot; );
        SDL_CondWait( gCanConsume, gBufferLock );
    }

    //Show and empty buffer
    printf( &quot;\nConsumed %d\n&quot;, gData );
    gData = -1;

    //Unlock
    SDL_UnlockMutex( gBufferLock );

    //Signal producer
    SDL_CondSignal( gCanProduce );
}
</code></pre><p>Here are the functions that produce and consume. Producing a buffer means generating a random number and consuming a buffer means reseting the generated number. The best way to show how this works is go through an example.</p>
<p>Let&#39;s say the producer fires first and locks the mutex with <a href="http://wiki.libsdl.org/SDL_LockMutex">SDL_LockMutex</a> much like it would a semaphore with a value of one:<br><img src="./res/49_run_01.png" alt=""></p>
<p>The buffer is empty so it goes through and produces:<br><img src="./res/49_run_02.png" alt=""></p>
<p>It then exits the function to unlock the critical section with SDL_UnlockMutex so the consumer can consume:<br><img src="./res/49_run_03.png" alt=""></p>
<p>Ideally, we would want the consumer to consume, but imagine if the producer fired again:<br><img src="./res/49_run_01.png" alt=""></p>
<p>And after the producer locked the critical section the consumer tries to get it but the critical section is already locked to the producer:<br><img src="./res/49_run_05.png" alt=""></p>
<p>With just a binary semaphore, this would be a problem because the producer can&#39;t produce into a full buffer and the consumer is locked behind a mutex. However, mutexes have the ability to be used with conditions.</p>
<p>What the condition allows us to do is if the buffer is already full, we can wait on a condition with <a href="http://wiki.libsdl.org/SDL_CondWait">SDL_CondWait</a> and unlock the mutex for other threads:<br><img src="./res/49_run_06.png" alt=""></p>
<p>Now that the consumer is unlocked it can go through and consume:<br><img src="./res/49_run_07.png" alt=""></p>
<p>And once it&#39;s done it signals the producer with <a href="http://wiki.libsdl.org/SDL_CondSignal">SDL_CondSignal</a> to produce again:<br><img src="./res/49_run_08.png" alt=""></p>
<p>And then it can continue through:<br><img src="./res/49_run_09.png" alt=""></p>
<p>With the critical section protected by a mutex and the ability of the threads to talk to each other, the worker threads will work even though we do not know in which order they will execute.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/49_mutexes_and_conditions/49_mutexes_and_conditions.zip">here</a>.</p>
<h2 id="sdl-and-opengl-2">SDL and OpenGL 2</h2>
<p><img src="./res/50_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>One SDL&#39;s most powerful features is its ability to combine with OpenGL. Here we&#39;ll make a basic OpenGL demo using easier to use legacy OpenGL.</p>
<pre><code>//Using SDL, SDL OpenGL, standard IO, and, strings
#include &lt;SDL.h&gt;
#include &lt;SDL_opengl.h&gt;
#include &lt;GL\GLU.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
</code></pre><p>To use OpenGL with SDL, make sure to include the SDL OpenGL header. We&#39;ll also be using GLU (OpenGL Utilities) for this demo.</p>
<p>Also make sure to check the readme.txt file to check which libraries you need to link against.</p>
<pre><code>//Starts up SDL, creates window, and initializes OpenGL
bool init();

//Initializes matrices and clear color
bool initGL();

//Input handler
void handleKeys( unsigned char key, int x, int y );

//Per frame update
void update();

//Renders quad to the screen
void render();

//Frees media and shuts down SDL
void close();

//The window we&#39;ll be rendering to
SDL_Window* gWindow = NULL;

//OpenGL context
SDL_GLContext gContext;

//Render flag
bool gRenderQuad = true;
</code></pre><p>In terms of new functions, we have a dedicated OpenGL initialization function with initGL. We also have dedicated key handlers, updating, and rendering functions for the main loop.</p>
<p>We also have a GL Context. An OpenGL context is just something that handles OpenGL calls and you need to have one for any OpenGL rendering. Finally, we have a boolean flag that toggles rendering.</p>
<pre><code>bool init()
{
    //Initialization flag
    bool success = true;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO ) &lt; 0 )
    {
        printf( &quot;SDL could not initialize! SDL Error: %s\n&quot;, SDL_GetError() );
        success = false;
    }
    else
    {
        //Use OpenGL 2.1
        SDL_GL_SetAttribute( SDL_GL_CONTEXT_MAJOR_VERSION, 2 );
        SDL_GL_SetAttribute( SDL_GL_CONTEXT_MINOR_VERSION, 1 );

        //Create window
        gWindow = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN );
        if( gWindow == NULL )
        {
            printf( &quot;Window could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
            success = false;
        }
</code></pre><p>When creating an SDL OpenGL window, there are a few more steps we have to take.</p>
<p>Before creating the window we need to specify the version we want. We want OpenGL 2.1 so we call <a href="http://wiki.libsdl.org/SDL_GL_SetAttribute">SDL_GL_SetAttribute</a> to set the major version to 2 and the minor version to 1. After the version is set we can create an OpenGL window by passing the SDL_WINDOW_OPENGL flag to SDL_CreateWindow.</p>
<pre><code>        else
        {
            //Create context
            gContext = SDL_GL_CreateContext( gWindow );
            if( gContext == NULL )
            {
                printf( &quot;OpenGL context could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
                success = false;
            }
            else
            {
                //Use Vsync
                if( SDL_GL_SetSwapInterval( 1 ) &lt; 0 )
                {
                    printf( &quot;Warning: Unable to set VSync! SDL Error: %s\n&quot;, SDL_GetError() );
                }

                //Initialize OpenGL
                if( !initGL() )
                {
                    printf( &quot;Unable to initialize OpenGL!\n&quot; );
                    success = false;
                }
            }
        }
    }

    return success;
}
</code></pre><p>After the window has been created successfully we call <a href="http://wiki.libsdl.org/SDL_GL_CreateContext">SDL_GL_CreateContext</a> to create the OpenGL rendering context. If that was successful, we enable Vsync with <a href="http://wiki.libsdl.org/SDL_GL_SetSwapInterval">SDL_GL_SetSwapInterval</a>.</p>
<p>After the SDL OpenGL window is created, we then initialize OpenGL&#39;s internals with our own initGL function.</p>
<pre><code>bool initGL()
{
    bool success = true;
    GLenum error = GL_NO_ERROR;

    //Initialize Projection Matrix
    glMatrixMode( GL_PROJECTION );
    glLoadIdentity();

    //Check for error
    error = glGetError();
    if( error != GL_NO_ERROR )
    {
        printf( &quot;Error initializing OpenGL! %s\n&quot;, gluErrorString( error ) );
        success = false;
    }

    //Initialize Modelview Matrix
    glMatrixMode( GL_MODELVIEW );
    glLoadIdentity();

    //Check for error
    error = glGetError();
    if( error != GL_NO_ERROR )
    {
        printf( &quot;Error initializing OpenGL! %s\n&quot;, gluErrorString( error ) );
        success = false;
    }
</code></pre><p>Here is our first bit of actual OpenGL code. If you were hoping to know all of OpenGL by the end of this tutorial, that is not going to be possible. OpenGL is oceanic in size and complexity and there&#39;s no way we could cover it in a single tutorial. What we&#39;re doing in this demo is learning how to use OpenGL with SDL.</p>
<p>First we initialize the projection matrix which controls how perspective works in OpenGL. We initialize it here by setting it to the identity matrix. We check if there was an error and print it to the console. Then we do the same thing with the model view matrix which controls how your rendered objects are viewed and placed.</p>
<pre><code>    //Initialize clear color
    glClearColor( 0.f, 0.f, 0.f, 1.f );

    //Check for error
    error = glGetError();
    if( error != GL_NO_ERROR )
    {
        printf( &quot;Error initializing OpenGL! %s\n&quot;, gluErrorString( error ) );
        success = false;
    }

    return success;
}
</code></pre><p>Lastly, we set the clear color which is the color that the screen is wiped with when we call glClear.</p>
<p>We didn&#39;t go into much detail about how these functions work because our main concern is getting SDL working with OpenGL. If you want more detail you can look it up in the <a href="http://www.opengl.org/sdk/docs/man2/">OpenGL 2.1 documentation</a>.</p>
<pre><code>void handleKeys( unsigned char key, int x, int y )
{
    //Toggle quad
    if( key == &#39;q&#39; )
    {
        gRenderQuad = !gRenderQuad;
    }
}

void update()
{
    //No per frame update needed
}
</code></pre><p>Here are our key input and update handlers. The key input handler toggles the render flag and the update handler is just there for compatibility&#39;s sake.</p>
<pre><code>void render()
{
    //Clear color buffer
    glClear( GL_COLOR_BUFFER_BIT );

    //Render quad
    if( gRenderQuad )
    {
        glBegin( GL_QUADS );
            glVertex2f( -0.5f, -0.5f );
            glVertex2f( 0.5f, -0.5f );
            glVertex2f( 0.5f, 0.5f );
            glVertex2f( -0.5f, 0.5f );
        glEnd();
    }
}
</code></pre><p>Here in the renderer we&#39;re clearing the screen and then if rendering is enabled, we render a quad.</p>
<p>The important thing to know is that OpenGL uses normalized coordinates. This means they go from -1 to 1:<br><img src="./res/50_normal_coord.png" alt=""></p>
<p>This means our quad is wider than it is tall. In order to get a coordinate system like SDL&#39;s, you&#39;re going to have to set the project matrix to an orthographic perspective.</p>
<pre><code>        //Enable text input
        SDL_StartTextInput();

        //While application is running
        while( !quit )
        {
            //Handle events on queue
            while( SDL_PollEvent( &amp;e ) != 0 )
            {
                //User requests quit
                if( e.type == SDL_QUIT )
                {
                    quit = true;
                }
                //Handle keypress with current mouse position
                else if( e.type == SDL_TEXTINPUT )
                {
                    int x = 0, y = 0;
                    SDL_GetMouseState( &amp;x, &amp;y );
                    handleKeys( e.text.text[ 0 ], x, y );
                }
            }

            //Render quad
            render();

            //Update screen
            SDL_GL_SwapWindow( gWindow );
        }

        //Disable text input
        SDL_StopTextInput();
</code></pre><p>Here is our main loop with our main loop functions snapped in.</p>
<p>An important thing to know is that when you use OpenGL&#39;s rendering you cannot use SDL&#39;s rendering call for surfaces, texturing, and such. As you can see here we need <a href="http://wiki.libsdl.org/SDL_GL_SwapWindow">SDL_GL_SwapWindow</a> to update the screen.</p>
<p>We only flew over the details of OpenGL rendering, but if you want to go into more detail there&#39;s an <a href="http://lazyfoo.net/tutorials/OpenGL/index.php">OpenGL tutorial</a> for that. The tutorial uses FreeGLUT, but using this tutorial it should be easy to port it to SDL 2 for window and event handling. For most of the OpenGL tutorial version 2.1 is used which is old but easier to use. You may not want to use old OpenGL, but think of it this way: Many of the core graphics algorithms like phoung shading were developed in the 1970s. What&#39;s changed is that we have different tools to render them with, but the core concepts have not changed.</p>
<p>If you understand the core concepts, you realize that OpenGL 2, OpenGL 3, OpenGL 4, and even Direct3D are more similar than they are different. What&#39;s important is that you know how geometry based rendering systems work and getting your hands dirty by getting real experience.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/50_SDL_and_opengl_2/50_SDL_and_opengl_2.zip">here</a>.</p>
<h2 id="sdl-and-modern-opengl">SDL and Modern OpenGL</h2>
<p><img src="./res/51_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>With OpenGL 3 there was a massive overhaul that made everything shader based. In this tutorial we&#39;ll be rendering a quad using core modern OpenGL.</p>
<pre><code>//Using SDL, SDL OpenGL, GLEW, standard IO, and strings
#include &lt;SDL.h&gt;
#include &lt;gl\glew.h&gt;
#include &lt;SDL_opengl.h&gt;
#include &lt;gl\glu.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
</code></pre><p>For this tutorial we&#39;ll be using the <a href="http://glew.sourceforge.net/">OpenGL Extension Wrangler</a>. Certain operating systems like windows only support a limited amount of OpenGL by default. Using GLEW you can get the latest functionality. If you use GLEW, make sure to include the GLEW header before any OpenGL headers.</p>
<p>GLEW is an extension library and if you can set up any of the SDL extension libraries you can set up GLEW.</p>
<pre><code>//Shader loading utility programs
void printProgramLog( GLuint program );
void printShaderLog( GLuint shader );
</code></pre><p>Here are some custom functions we&#39;re making to report any errors when making our shader programs.</p>
<pre><code>//Graphics program
GLuint gProgramID = 0;
GLint gVertexPos2DLocation = -1;
GLuint gVBO = 0;
GLuint gIBO = 0;
</code></pre><p>The way modern OpenGL works is that we create shader programs (gProgramID) that process vertex attributes like positions (gVertexPos2DLocation). We put vertices in Vertex Buffer Objects (gVBO) and specify the order in which to draw them using Index Buffer Objects.</p>
<pre><code>        //Use OpenGL 3.1 core
        SDL_GL_SetAttribute( SDL_GL_CONTEXT_MAJOR_VERSION, 3 );
        SDL_GL_SetAttribute( SDL_GL_CONTEXT_MINOR_VERSION, 1 );
        SDL_GL_SetAttribute( SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE );
</code></pre><p>Here we&#39;re initializing for a version 3.1 core context. 3.1 core gets rid off al the old functionality. We specify the major and minor version like before and make it a core context by setting the profile mask to core.</p>
<pre><code>            //Create context
            gContext = SDL_GL_CreateContext( gWindow );
            if( gContext == NULL )
            {
                printf( &quot;OpenGL context could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
                success = false;
            }
            else
            {
                //Initialize GLEW
                glewExperimental = GL_TRUE; 
                GLenum glewError = glewInit();
                if( glewError != GLEW_OK )
                {
                    printf( &quot;Error initializing GLEW! %s\n&quot;, glewGetErrorString( glewError ) );
                }

                //Use Vsync
                if( SDL_GL_SetSwapInterval( 1 ) &lt; 0 )
                {
                    printf( &quot;Warning: Unable to set VSync! SDL Error: %s\n&quot;, SDL_GetError() );
                }

                //Initialize OpenGL
                if( !initGL() )
                {
                    printf( &quot;Unable to initialize OpenGL!\n&quot; );
                    success = false;
                }
            }
</code></pre><p>After we create our context we initialize GLEW. Since we want the latest features, we have to set glewExperimental to true. After that we call glewInit() to initialize GLEW.</p>
<pre><code>bool initGL()
{
    //Success flag
    bool success = true;

    //Generate program
    gProgramID = glCreateProgram();
</code></pre><p>In our initialization function we&#39;re going to create our shader program to render with along with the VBO and IBO data.</p>
<p>If you&#39;ve never worked with OpenGL shaders, this function is probably going to go over your head. It&#39;s OK because this tutorial is about how to use SDL&#39;s 3.0+ context controls, not so much the detail about how OpenGL 3.0+ works. Just try to get a general idea on how a shader works.</p>
<pre><code>    //Create vertex shader
    GLuint vertexShader = glCreateShader( GL_VERTEX_SHADER );

    //Get vertex source
    const GLchar* vertexShaderSource[] =
    {
        &quot;#version 140\nin vec2 LVertexPos2D; void main() { gl_Position = vec4( LVertexPos2D.x, LVertexPos2D.y, 0, 1 ); }&quot;
    };

    //Set vertex source
    glShaderSource( vertexShader, 1, vertexShaderSource, NULL );

    //Compile vertex source
    glCompileShader( vertexShader );

    //Check vertex shader for errors
    GLint vShaderCompiled = GL_FALSE;
    glGetShaderiv( vertexShader, GL_COMPILE_STATUS, &amp;vShaderCompiled );
    if( vShaderCompiled != GL_TRUE )
    {
        printf( &quot;Unable to compile vertex shader %d!\n&quot;, vertexShader );
        printShaderLog( vertexShader );
        success = false;
    }
</code></pre><p>Here we are loading a vertex shader from an in code source. If the vertex shader failed to load and compile we use our log printing function to spit out the error.</p>
<pre><code>    else
    {
        //Attach vertex shader to program
        glAttachShader( gProgramID, vertexShader );


        //Create fragment shader
        GLuint fragmentShader = glCreateShader( GL_FRAGMENT_SHADER );

        //Get fragment source
        const GLchar* fragmentShaderSource[] =
        {
            &quot;#version 140\nout vec4 LFragment; void main() { LFragment = vec4( 1.0, 1.0, 1.0, 1.0 ); }&quot;
        };

        //Set fragment source
        glShaderSource( fragmentShader, 1, fragmentShaderSource, NULL );

        //Compile fragment source
        glCompileShader( fragmentShader );

        //Check fragment shader for errors
        GLint fShaderCompiled = GL_FALSE;
        glGetShaderiv( fragmentShader, GL_COMPILE_STATUS, &amp;fShaderCompiled );
        if( fShaderCompiled != GL_TRUE )
        {
            printf( &quot;Unable to compile fragment shader %d!\n&quot;, fragmentShader );
            printShaderLog( fragmentShader );
            success = false;
        }
</code></pre><p>If the vertex shader loaded successfully we attach it to the program and then compile the fragment shader.</p>
<pre><code>        else
        {
            //Attach fragment shader to program
            glAttachShader( gProgramID, fragmentShader );


            //Link program
            glLinkProgram( gProgramID );

            //Check for errors
            GLint programSuccess = GL_TRUE;
            glGetProgramiv( gProgramID, GL_LINK_STATUS, &amp;programSuccess );
            if( programSuccess != GL_TRUE )
            {
                printf( &quot;Error linking program %d!\n&quot;, gProgramID );
                printProgramLog( gProgramID );
                success = false;
            }
</code></pre><p>If the fragment shader compiled, we attach it to the shader program and link it.</p>
<pre><code>            else
            {
                //Get vertex attribute location
                gVertexPos2DLocation = glGetAttribLocation( gProgramID, &quot;LVertexPos2D&quot; );
                if( gVertexPos2DLocation == -1 )
                {
                    printf( &quot;LVertexPos2D is not a valid glsl program variable!\n&quot; );
                    success = false;
                }
</code></pre><p>If the program linked successfully we then get the attribute from the shader program so we can send it vertex data.</p>
<pre><code>                else
                {
                    //Initialize clear color
                    glClearColor( 0.f, 0.f, 0.f, 1.f );

                    //VBO data
                    GLfloat vertexData[] =
                    {
                        -0.5f, -0.5f,
                         0.5f, -0.5f,
                         0.5f,  0.5f,
                        -0.5f,  0.5f
                    };

                    //IBO data
                    GLuint indexData[] = { 0, 1, 2, 3 };

                    //Create VBO
                    glGenBuffers( 1, &amp;gVBO );
                    glBindBuffer( GL_ARRAY_BUFFER, gVBO );
                    glBufferData( GL_ARRAY_BUFFER, 2 * 4 * sizeof(GLfloat), vertexData, GL_STATIC_DRAW );

                    //Create IBO
                    glGenBuffers( 1, &amp;gIBO );
                    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, gIBO );
                    glBufferData( GL_ELEMENT_ARRAY_BUFFER, 4 * sizeof(GLuint), indexData, GL_STATIC_DRAW );
                }
            }
        }
    }

    return success;
}
</code></pre><p>After we get the shader program working, we create the VBO and IBO. As you can see, the VBO has the same positions as the quad from the last tutorial.</p>
<pre><code>void printProgramLog( GLuint program )
{
    //Make sure name is shader
    if( glIsProgram( program ) )
    {
        //Program log length
        int infoLogLength = 0;
        int maxLength = infoLogLength;

        //Get info string length
        glGetProgramiv( program, GL_INFO_LOG_LENGTH, &amp;maxLength );

        //Allocate string
        char* infoLog = new char[ maxLength ];

        //Get info log
        glGetProgramInfoLog( program, maxLength, &amp;infoLogLength, infoLog );
        if( infoLogLength &gt; 0 )
        {
            //Print Log
            printf( &quot;%s\n&quot;, infoLog );
        }

        //Deallocate string
        delete[] infoLog;
    }
    else
    {
        printf( &quot;Name %d is not a program\n&quot;, program );
    }
}

void printShaderLog( GLuint shader )
{
    //Make sure name is shader
    if( glIsShader( shader ) )
    {
        //Shader log length
        int infoLogLength = 0;
        int maxLength = infoLogLength;

        //Get info string length
        glGetShaderiv( shader, GL_INFO_LOG_LENGTH, &amp;maxLength );

        //Allocate string
        char* infoLog = new char[ maxLength ];

        //Get info log
        glGetShaderInfoLog( shader, maxLength, &amp;infoLogLength, infoLog );
        if( infoLogLength &gt; 0 )
        {
            //Print Log
            printf( &quot;%s\n&quot;, infoLog );
        }

        //Deallocate string
        delete[] infoLog;
    }
    else
    {
        printf( &quot;Name %d is not a shader\n&quot;, shader );
    }
}
</code></pre><p>Here are our log printing functions. These grab the shader log from the given shader or program and spit it out to the console.</p>
<pre><code>void render()
{
    //Clear color buffer
    glClear( GL_COLOR_BUFFER_BIT );

    //Render quad
    if( gRenderQuad )
    {
        //Bind program
        glUseProgram( gProgramID );

        //Enable vertex position
        glEnableVertexAttribArray( gVertexPos2DLocation );

        //Set vertex data
        glBindBuffer( GL_ARRAY_BUFFER, gVBO );
        glVertexAttribPointer( gVertexPos2DLocation, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), NULL );

        //Set index data and render
        glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, gIBO );
        glDrawElements( GL_TRIANGLE_FAN, 4, GL_UNSIGNED_INT, NULL );

        //Disable vertex position
        glDisableVertexAttribArray( gVertexPos2DLocation );

        //Unbind program
        glUseProgram( NULL );
    }
}
</code></pre><p>In our rendering function, we bind our shader program, enable vertex positions, bind the VBO, set the data offset, bind the IBO, and draw the quad as a triangle fan. Once we&#39;re done we disable the vertex attribute and unbind the program.</p>
<p>Again this tutorial is more for people with some OpenGL experience that want to know how to switch over to core functionality. The fact is that this code will work with an OpenGL 2.1 context as well as a 3.0 context (Well, except for the shader code because OpenGL 2.1 only supports up to #version 120). Core OpenGL just removes OpenGL calls that don&#39;t reflect modern hardware.</p>
<p>If you want to learn more about modern opengl, I have <a href="http://lazyfoo.net/tutorials/OpenGL/index.php#Hello%20GLSL">OpenGL shader tutorials</a> too.</p>
<p>Also, I get e-mails of how this code is broken because if you set the version to 3.2+ it won&#39;t work because it doesn&#39;t use vertex array objects (or VAOs). The thing is this code works fine for version 3.1 core, which it is designed to be. However, OpenGL 3.2+ requires you create a VAO. Fortunately I cover VAOs in the OpenGL tutorial.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/51_SDL_and_modern_opengl/51_SDL_and_modern_opengl.zip">here</a>.</p>
<h2 id="hello-mobile">Hello Mobile</h2>
<p><img src="./res/52_preview.png" alt=""></p>
<p><strong>Last Updated 1/21/18</strong></p>
<p>So you learned the basics of SDL on your desktop computer and you want to make ports of your applications for phones and tablets. SDL 2 fortunately has Android and iOS ports that help make the process less painful.</p>
<p><strong>DO NOT GO THROUGH THESE TUTORIALS</strong> if you haven&#39;t gone through the previous ones. The mobile tutorials assume you already have experience with SDL 2. Go learn the tutorials before this one because mobile development is much, much more quirky than developing on desktop.</p>
<p>After you set up SDL, we&#39;ll cover <a href="#hello-mobile-your-first-mobile-sdl-2-app">how to make your first mobile SDL game</a>.</p>
<table>
<thead>
<tr>
<th>Select Your Mobile/Development Platform</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/52_logo1.png" alt=""></td>
<td><a href="#setting-up-sdl-2-on-windows-android-studio-3-0-1">Windows Android Studio 3.0.1</a></td>
</tr>
<tr>
<td><img src="./res/52_logo2.png" alt=""></td>
<td><a href="#setting-up-sdl-2-on-linux-android-studio-3-0-1">Linux Android Studio 3.0.1</a></td>
</tr>
<tr>
<td><img src="./res/52_logo3.png" alt=""></td>
<td><a href="#setting-up-sdl-2-on-mac-android-studio-3-0-1">Mac Android Studio 3.0.1</a></td>
</tr>
<tr>
<td><img src="./res/52_logo4.png" alt=""></td>
<td><a href="#setting-up-sdl-2-on-ios-with-xcode-9-2">iOS XCode 9.2</a></td>
</tr>
</tbody>
</table>
<h2 id="hello-mobile-your-first-mobile-sdl-2-app">Hello Mobile: Your First Mobile SDL 2 App</h2>
<p><img src="./res/52_preview2.png" alt=""></p>
<p><strong>Last Updated 5/11/15</strong></p>
<p>Now that you covered the hard part of getting the application to compile and run, let&#39;s go over the application code.</p>
<pre><code>//Screen dimensions
SDL_Rect gScreenRect = { 0, 0, 320, 240 };
</code></pre><p>Since mobile devices vary a lot in resolution, we&#39;re going to use variable screen dimensions instead of constant ones.</p>
<pre><code>        //Get device display mode
        SDL_DisplayMode displayMode;
        if( SDL_GetCurrentDisplayMode( 0, &amp;displayMode ) == 0 )
        {
            gScreenRect.w = displayMode.w;
            gScreenRect.h = displayMode.h;
        }

        //Create window
        gWindow = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, gScreenRect.w, gScreenRect.h, SDL_WINDOW_SHOWN );
        if( gWindow == NULL )
        {
            SDL_Log( &quot;Window could not be created! SDL Error: %s\n&quot;, SDL_GetError() );
            success = false;
        }
</code></pre><p>Here we call <a href="http://wiki.libsdl.org/SDL_GetCurrentDisplayMode">SDL_GetCurrentDisplayMode</a> to get the resolution of the mobile device. We then create a window using the device dimensions.</p>
<p>Notice how we&#39;re using <a href="http://wiki.libsdl.org/SDL_Log">SDL_Log</a> instead of printf. This is because Android/iOS have their own platform specific ways to print to the console and SDL gives us a nice wrapper to make our code cross platform.</p>
<pre><code>int main( int argc, char* args[] )
{
    //Start up SDL and create window
    if( !init() )
    {
        SDL_Log( &quot;Failed to initialize!\n&quot; );
    }
    else
    {
        //Load media
        if( !loadMedia() )
        {
            SDL_Log( &quot;Failed to load media!\n&quot; );
        }
        else
        {
            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //While application is running
            while( !quit )
            {
                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                }

                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render splash
                gSplashTexture.render( ( gScreenRect.w - gSplashTexture.getWidth() ) / 2, ( gScreenRect.h - gSplashTexture.getHeight() ) / 2 );

                //Update screen
                SDL_RenderPresent( gRenderer );
            }
        }
    }

    //Free resources and close SDL
    close();

    return 0;
}
</code></pre><p>Other than the fact that we&#39;re using SDL_Log, the code is pretty much the same as before.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/52_hello_mobile/52_hello_mobile.zip">here</a>.</p>
<h2 id="setting-up-sdl-2-on-windows-android-studio-3-0-1">Setting up SDL 2 on Windows Android Studio 3.0.1</h2>
<p><strong>Last Updated 6/10/19</strong></p>
<ol>
<li><p>Get ready to download. A lot. Like over a gigabyte of data. If you have a limited connection, I&#39;m sorry the android SDK is huge and it&#39;s just the way things are. I recommend having a movie or TV show to watch ready if a gigabyte takes a long time for you to download.</p>
<p> First, download the Java Development Kit (JDK) on <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">this page</a>. I am assuming you&#39;re running 64bit windows, so download the 64bit version:<br> <img src="./res/52_win_download_jdk.png" alt=""></p>
</li><li><p>Download Android Studio on <a href="https://developer.android.com/studio/index.html">this page</a>.<br><img src="./res/52_win_download_android_studio.png" alt=""></p>
</li><li><p>Download the SDL2 source. Not just the development libraries you use for desktop development, the full source. You can find the full source on <a href="https://www.libsdl.org/download-2.0.php">this page</a>.<br><img src="./res/52_win_download_sdl_source.png" alt=""></p>
</li><li><p>Install the JDK. This should be a simple next, next, next,... finish installation.</p>
</li><li><p>Install the Android Studio. It&#39;s mostly a next, next, and finish installation but make sure to change a couple things. In the configurations setting menu make sure to set the android sdk path to some place accessible. For this tutorial we are placing it at &quot;C:\androidsdk&quot;.<br><img src="./res/52_win_android_sdk_location.png" alt=""></p>
</li><li><p>Start Android Studio. The first time you start Android Studio it will run a set up wizard. Make sure to select the Custom Install.<br><img src="./res/52_win_custom_install_type.png" alt=""></p>
<p> In the SDK Components Setup, make sure it pointed to the sdk directory we set when installing (which was at &quot;C:\androidsdk&quot;).<br> <img src="./res/52_win_sdk_components_setup.png" alt=""></p>
<p> Keep going through the installation and hit finish so it can start downloading.</p>
</li><li><p>Starting Android Studio again, open up the sdk manager:<br> <img src="./res/52_configure_sdk_manager.png" alt=""></p>
<p> Check Show Package Details, select Android version 16, and hit Apply to install:<br> <img src="./res/52_win_install_android_16.png" alt=""></p>
</li><li><p>Click on SDK Tools and make sure to install:</p>
<ul>
<li>CMake</li><li>Google USB Driver</li><li><p>NDK</p>
<p><img src="./res/52_win_sdk_tools.png" alt=""></p>
</li></ul>
</li><li><p>Extract the SDL2 source code to some accessable directory that is ideally dedicated to containing Android libraries. For this tutorial we will put them in the directory &quot;C:\androidlib&quot;. After extracting the SDL2 source code you should have an Android makefile at &quot;C:\androidlib\SDL2-2.0.5\Android.mk&quot;. Depending on your version of SDL, it could be at &quot;C:\androidlib\SDL2-2.0.4\Android.mk&quot; or &quot;C:\androidlib\SDL2-2.0.6\Android.mk&quot; and so on.</p>
</li><li><p>Start up Android Studio again and import the android project from the SDL2 source code which should be at &quot;C:\androidlib\SDL2-2.0.5\android-project&quot;<br><img src="./res/52_win_import_project.png" alt=""></p>
</li><li><p>Set the destination to a new folder inside of some accessable directory that is ideally dedicated to containing Android projects. For this tutorial we will put the project in &quot;C:\androidprojects\SDL&quot;.<br><img src="./res/52_win_project_destination.png" alt=""></p>
<p>Select the directory and import the project with the default settings.</p>
</li><li><p>If you try to hit Build -&gt; Make Project you&#39;ll get the following error:</p>
<pre><code>Minimum supported Gradle version is 4.1. Current version is 2.14.1.
</code></pre><p>This means our project is set to use the wrong version of Gradle. To fix this, set the Project window to project mode, &quot;C:\androidprojects\SDL\gradle\wrapper\gradle-wrapper.properties&quot; and change</p>
<pre><code>distributionUrl=https\\://services.gradle.org/distributions/gradle-2.14.1-all.zip
</code></pre><p>to</p>
<pre><code>distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip
</code></pre><p>Make project again (it may take a while to download Gradle 4.1) and you&#39;ll get a new error:</p>
<pre><code>cannot find symbol class Objects
</code></pre></li><li><p>That error was due to the fact that Android Studio cannot find the Java Objects class. It can&#39;t find it because it is pointed at an old JDK. To make sure it compiles against the latest version of Java, go to File -&gt; Project Structure.<br><img src="./res/52_win_project_structure.png" alt=""></p>
<p>Select app under Modules and the set the Source/Target Compatibility to the latest version (currently 1.8):<br><img src="./res/52_win_compatibility.png" alt=""></p>
<p>Build again and you should get a new error.</p>
</li><li><p>The new error will say:</p>
<pre><code>Error:Execution failed for task &#39;:app:compileDebugNdk&#39;. &gt; Error: Your project contains C++ files but it is not using a supported native build system. Consider using CMake or ndk-build integration with the stable Android Gradle plugin: https://developer.android.com/studio/projects/add-native-code.html or use the experimental plugin: https://developer.android.com/studio/build/experimental-plugin.html.
</code></pre><p>This is complaining that the NDK setup is broken for our project.</p>
<p>Let&#39;s back up a bit and talk about how SDL 2 on Android works. Android development is mostly Java based and SDL is a C based library. The Native Development Kit that allows Java to interface with native C/C++ code using the Java Native Interface. With the NDK, we&#39;ll build SDL2 as a shared object that will interface with Java, and we&#39;ll build our game as another shared object that will interface with SDL 2.</p>
<p>What we need to do is tell gradle (the build tool used by Android Studio) to use the Android make file for our project. Open up the project window, right click on app and select &quot;Link C++ with Gradle&quot;.<br><img src="./res/52_win_link_cpp_with_gradle.png" alt=""></p>
<p>Set the Build System to ndk-build and set the project path to point to the Android make file which should be at &quot;C:\androidprojects\SDL\app\src\main\jni\Android.mk&quot;.<br><img src="./res/52_win_select_android_mk.png" alt=""></p>
<p>Hit Build -&gt; Make Project and you&#39;ll get a bunch of new errors saying something like</p>
<pre><code>Error:(688) Android NDK: Module main depends on undefined modules: SDL2
</code></pre></li><li><p>What the previous error was complaining about was that it can&#39;t find the SDL 2 module. What we need to do is set up a symbolic link to the SDL 2 source we extracted.</p>
<p>Next, go to the start menu and run cmd as administrator:<br><img src="./res/52_win_run_cmd_as_admin.png" alt=""></p>
<p>Go to the JNI directory inside the project using this command:</p>
<pre><code>cd &quot;C:\androidprojects\SDL\app\src\main\jni&quot;
</code></pre><p>And create a symbolic link directory to the SDL 2 source directory we extracted (<strong>REMEMBER: This path will vary depending on your version of SDL 2</strong>):</p>
<pre><code>mklink /D SDL2 C:\androidlib\SDL2-2.0.5
</code></pre><p>You should get the following message back</p>
<pre><code>symbolic link created for SDL2 &lt;&lt;===&gt;&gt; C:\androidlib\SDL2-2.0.5
</code></pre><p>Try to rebuild the project. You&#39;ll new a new error:</p>
<pre><code>Error:A problem occurred configuring project &#39;:app&#39;. &gt; executing external native build for ndkBuild C:\androidprojects\SDL\app\src\main\jni\Android.mk
</code></pre><p>but at least now you&#39;ll see symbolic link in the project:<br><img src="./res/52_win_symbolic_link_in_project.png" alt=""></p>
</li><li><p>That gradle error didn&#39;t tell us much so we&#39;ll have to open up the gradle console:<br><img src="./res/52_win_open_gradle_console.png" alt=""></p>
<p>Scroll up a bit and you&#39;ll see some errors from the ndk-build.</p>
<pre><code>`C:/androidprojects/SDL/app/src/main/jni/src/YourSourceHere.c&#39;, needed by `C:/androidprojects/SDL/app/build/intermediates/ndkBuild/debug/obj/local/armeabi/objs-debug/main/YourSourceHere.o&#39;. Stop.
</code></pre><p>In this case, the error &quot;No rule to make target&quot; actually means it can&#39;t find the file you&#39;re asking to compile. It&#39;s trying to compile &quot;C:/androidprojects/SDL/app/src/main/jni/src/YourSourceHere.c&quot; but can&#39;t find it which makes sense because it doesn&#39;t exist. YourSourceHere.c is a place holder for our application source file so we need to replace it with ours.</p>
<p>Download the <a href="http://lazyfoo.net/tutorials/SDL/52_hello_mobile/52_hello_mobile.zip">source for lesson 52</a> and place 52_hello_mobile.cpp at &quot;C:\androidprojects\SDL\app\src\main\jni\src\52_hello_mobile.cpp&quot;. Open up &quot;C:\androidprojects\SDL\app\src\main\jni\src\Android.mk&quot; and change &quot;YourSourceHere.c&quot; to &quot;52_hello_mobile.cpp&quot;. Build and you should get a new error in the gradle build menu.</p>
</li><li><p>The error</p>
<pre><code>Error:(7, 10) fatal error: &#39;string&#39; file not found
</code></pre><p>is due to the fact that the project is not set up to use the standard C++ library. To fix this, open up &quot;C:\androidprojects\SDL\app\src\main\jni\Application.mk&quot; and change</p>
<pre><code># APP_STL := stlport_static
</code></pre><p>to</p>
<pre><code>APP_STL := stlport_static
</code></pre><p>so it&#39;s no longer commmented out. Build again and you should get no errors.</p>
</li><li><p>Open &quot;C:\androidprojects\SDL\app\src\main\res\values\strings.xml&quot; and change</p>
<pre><code>&lt;string name=&quot;app_name&quot;&gt;SDL App&lt;/string&gt;
</code></pre><p>to</p>
<pre><code>&lt;string name=&quot;app_name&quot;&gt;SDL Tutorial&lt;/string&gt;
</code></pre><p>This will change the name under the App&#39;s icon from &quot;SDL App&quot; to &quot;SDL Tutorial&quot;.</p>
</li><li><p>At this point the app will run our code but it will fail because it can&#39;t load the media files for the tutorial. Media files go in the asset directory. Create a folder called &quot;assets&quot; at &quot;C:\androidprojects\SDL\app\src\main\assets&quot;. Copy the directory inside of the zip we downloaded and place it in the assets directory. If the application needs to open &quot;52_hello_mobile\hello.bmp&quot;, it needs to be at &quot;C:\androidprojects\SDL\app\src\main\assets\52_hello_mobile\hello.bmp&quot; when building.</p>
</li><li><p>Our SDL application is ready to build and run, but first we need to set up our device. You can use an Android emulator, but the emulator is can be really, really slow so I recommend getting an Android device if you can.</p>
<p>First you&#39;ll need to enable USB debugging on your device. That is version/device specific which is why I won&#39;t go over it here. Google search &quot;android enable usb debugging&quot; with your device name and they&#39;ll show you how to do it.</p>
<p>Make sure you have the device drivers installed on your Windows machine. The driver you downloaded from Android Studio should be located at &quot;C:\androidsdk\extras\google\usb_driver&quot; which may work with your device or your device may require a driver from the manufacturer. Either way, make sure to check in the Windows Device Manager that your device has its drivers installed. Without the drivers, ADB (Android Debug Bridge) won&#39;t connect and you won&#39;t be able to deploy and debug on your device.</p>
<p>After you set up your Android device, go to Run -&gt; run App.<br><img src="./res/52_win_run_app.png" alt=""></p>
<p>If you want to see the console output of the app, you can see it in the Android Monitor:<br><img src="./res/52_win_android_monitor.png" alt=""></p>
<p>The Android Monitor can also show you if there are any ADB errors.</p>
<p>Now that you have SDL 2 running on your device, it&#39;s time to go onto part 2 of the tutorial.</p>
</li></ol>
<h2 id="setting-up-sdl-2-on-linux-android-studio-3-0-1">Setting up SDL 2 on Linux Android Studio 3.0.1</h2>
<p><strong>Last Updated 12/26/17</strong></p>
<p>1) Get ready to download. A lot. Like over a gigabyte of data. If you have a limited connection, I&#39;m sorry the android SDK is huge and it&#39;s just the way things are. I recommend having a movie or TV show to watch ready if a gigabyte takes a long time for you to download.</p>
<p>First you need to install the Java Development Kit (JDK). Using apt-get you can install it using the following command:</p>
<pre><code>sudo apt-get install default-jdk
</code></pre><p>2) Download Android Studio on <a href="https://developer.android.com/studio/index.html">this page</a>.<br><img src="./res/52_nix_download_android_studio.png" alt=""></p>
<p>3) Download the SDL2 source. Not just the development libraries you use for desktop development, the full source. You can find the full source on <a href="https://www.libsdl.org/download-2.0.php">this page</a>.<br><img src="./res/52_nix_download_sdl_source.png" alt=""></p>
<p>4) To run on an Android device we&#39;re going to need the Android Debug Bridge (known as ADB). You can install it with apt-get using:</p>
<pre><code>sudo apt-get install android-tools-adb
</code></pre><p>5) Extract the android-studio folder from the Android Studio zip we downloaded earlier. Put it some place convenient. For this tutorial we will be putting it inside of the home directory.</p>
<p>After it&#39;s extracted, install and/or run Android Studio. Instructions on how to do so should be at ~/android-studio/Install-Linux-tar.txt</p>
<p>6) After starting Android Studio, go to Configure -&gt; SDK Manager<br><img src="./res/52_nix_configure_sdk_manager.png" alt=""></p>
<p>7) Under SDK Platforms, check Show Package Details and select Android SDK Platform 16 for installation and hit apply to install:<br><img src="./res/52_nix_sdk_platforms.png" alt=""></p>
<p>You may want to install the latest version of the Android SDK but unless you know what you&#39;re doing and you actually need the latest features I would recommend against it. Newer SDK means less stable SDK.</p>
<p>8) Click on SDK Tools and make sure to install:</p>
<ul>
<li>CMake</li><li>NDK<br><img src="./res/52_nix_sdk_tools.png" alt=""></li></ul>
<p>9) Extract the SDL2 source code to some accessible directory that is ideally dedicated to containing Android libraries. For this tutorial we will put them in the directory &quot;~/androidlib/&quot;. After extracting the SDL2 source code you should have an Android makefile at &quot;~/androidlib/SDL2-2.0.7/Android.mk&quot;. Depending on your version of SDL, it could be at &quot;~/androidlib/SDL2-2.0.5/Android.mk&quot; or &quot;~/androidlib/SDL2-2.0.4/Android.mk&quot; and so on.</p>
<p>10) Start up Android Studio again and import the android project from the SDL2 source code which should be at &quot;~/androidlib/SDL2-2.0.7/android-project&quot;<br><img src="./res/52_nix_import_project.png" alt=""></p>
<p>11) Set the destination to a new folder inside of some accessible directory that is ideally dedicated to containing Android projects. For this tutorial we will put the project in &quot;YOUR-HOME-DIRECTORY/androidprojects/SDL_Tutorial&quot;. Select the directory and import the project with the default settings.</p>
<p>12) Go to Build -&gt; Make Project:<br><img src="./res/52_nix_make_project.png" alt=""></p>
<p>You will get an error that says:</p>
<pre><code>Minimum supported Gradle version is 4.1. Current version is 2.14.1.
</code></pre><p>This means our project is set to use the wrong version of Gradle. To fix this, set the Project window to project mode, go to SDL_tutorial -&gt; gradle -&gt; wrapper -&gt; gradle-wrapper.properties and change</p>
<pre><code>distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
</code></pre><p>to</p>
<pre><code>distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
</code></pre><p><img src="./res/52_nix_upgrade_gradle.png" alt=""></p>
<p>Make project again (it may take a while to download Gradle 4.1) and you&#39;ll get a new error:</p>
<pre><code>cannot find symbol class Objects
</code></pre><p>13) That error was due to the fact that Android Studio cannot find the Java Objects class. It can&#39;t find it because it is pointed at an old JDK. To make sure it compiles against the latest version of Java, go to File -&gt; Project Structure.<br><img src="./res/52_nix_project_structure.png" alt=""></p>
<p>Select app under Modules and the set the Source/Target Compatibility to the latest version (currently 1.8):<br><img src="./res/52_nix_compatibility.png" alt=""></p>
<p>Build again and you should get a new error.</p>
<p>14) If you try to hit Build -&gt; Make Project you&#39;ll get the following error:</p>
<pre><code>Error:Execution failed for task &#39;:app:compileDebugNdk&#39;. &gt; Error: Your project contains C++ files but it is not using a supported native build system. Consider using CMake or ndk-build integration with the stable Android Gradle plugin: https://developer.android.com/studio/projects/add-native-code.html or use the experimental plugin: https://developer.android.com/studio/build/experimental-plugin.html.
</code></pre><p>This is complaining that the NDK setup is broken for our project.</p>
<p>Let&#39;s back up a bit and talk about how SDL 2 on Android works. Android development is mostly Java based and SDL is a C based library. The Native Development Kit that allows Java to interface with native C/C++ code using the Java Native Interface. With the NDK, we&#39;ll build SDL2 as a shared object that will interface with Java, and we&#39;ll build our game as another shared object that will interface with SDL 2.</p>
<p>What we need to do is tell Gradle (the build tool used by Android Studio) to use the Android make file for our project. Open up the project window, right click on app and select &quot;Link C++ with Gradle&quot;.<br><img src="./res/52_nix_link_cpp_with_gradle.png" alt=""></p>
<p>Set the Build System to ndk-build and set the project path to point to the Android make file which should be at &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/Android.mk&quot;.<br><img src="./res/52_nix_select_android_mk.png" alt=""></p>
<p>Hit Build -&gt; Make Project and you&#39;ll get a bunch of new errors saying something like<br>Android NDK: Module main depends on undefined modules: SDL2<br>15) What the previous error was complaining about was that it can&#39;t find the SDL 2 module. What we need to do is set up a symbolic link to the SDL 2 source we extracted.</p>
<p>Go to the JNI directory inside the project using this command:</p>
<pre><code>cd ~/androidprojects/SDL_Tutorial/app/src/main/jni
</code></pre><p>And create a symbolic link directory to the SDL 2 source directory we extracted (REMEMBER: This path will vary depending on your version of SDL 2):</p>
<pre><code>ln -s ~/androidlib/SDL2-2.0.7/ SDL2
</code></pre><p>Try to rebuild the project. You&#39;ll new a new error but at least now you&#39;ll see symbolic link in the project:<br><img src="./res/52_nix_symbolic_link_in_project.png" alt=""></p>
<p>16) That Gradle error didn&#39;t tell us much so we&#39;ll have to open up the Gradle console:<br><img src="./res/52_nix_open_gradle_console.png" alt=""></p>
<p>Scroll up a bit and you&#39;ll see some errors from the ndk-build. You&#39;ll probably see this error:</p>
<pre><code>make: *** No rule to make target `~/androidprojects/SDL_Tutorial/app/src/main/jni/src/YourSourceHere.c&#39;, needed by `~/androidprojects/SDL_Tutorial/app/build/intermediates/ndkBuild/debug/obj/local/armeabi-v7a/objs-debug/main/YourSourceHere.o&#39;. Stop. make: *** No rule to make target `~/androidprojects/SDL_Tutorial/app/src/main/jni/src/YourSourceHere.c&#39;, needed by `~/androidprojects/SDL_Tutorial/app/build/intermediates/ndkBuild/debug/obj/local/x86/objs-debug/main/YourSourceHere.o&#39;. Stop.
</code></pre><p>In this case, the error &quot;No rule to make target&quot; actually means it can&#39;t find the file you&#39;re asking to compile. It&#39;s trying to compile &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/YourSourceHere.c&quot; but can&#39;t find it which makes sense because it doesn&#39;t exist. YourSourceHere.c is a place holder for our application source file so we need to replace it with ours. Download the source for lesson 52 and place 52_hello_mobile.cpp at &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/52_hello_mobile.cpp&quot;. Open up &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/Android.mk&quot; and change &quot;YourSourceHere.c&quot; to &quot;52_hello_mobile.cpp&quot;. Build and you should get a new error in the Gradle build menu.</p>
<p>17) The error</p>
<pre><code>fatal error: &#39;string&#39; file not found
</code></pre><p>is due to the fact that the project is not set up to us the standard C++ library. To fix this, open up &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/Application.mk&quot; and change</p>
<pre><code># APP_STL := stlport_static
</code></pre><p>to</p>
<pre><code>APP_STL := stlport_static
</code></pre><p>so it&#39;s no longer commmented out. Build again and you should get no errors.</p>
<p>18) Open &quot;~/androidprojects/SDL_Tutorial/app/src/main/res/values/strings.xml&quot; and change</p>
<pre><code>&lt;string name=&quot;app_name&quot;&gt;SDL App&lt;/string&gt;
</code></pre><p>to</p>
<pre><code>&lt;string name=&quot;app_name&quot;&gt;SDL Tutorial&lt;/string&gt;
</code></pre><p>This will change the name under the App&#39;s icon from &quot;SDL App&quot; to &quot;SDL Tutorial&quot;.</p>
<p>19) At this point the app will run our code but it will fail because it can&#39;t load the media files for the tutorial. Media files go in the assets directory. Create a folder called &quot;assets&quot; at &quot;~/androidprojects/SDL_Tutorial/app/src/main/assets&quot;. Copy the directory inside of the zip we downloaded and place it in the assets directory. If the application needs to open &quot;52_hello_mobile/hello.bmp&quot;, it needs to be at &quot;~/androidprojects/SDL_Tutorial/app/src/main/assets/52_hello_mobile/hello.bmp&quot; when building.</p>
<p>20) Our SDL application is ready to build and run, but first we need to set up our device. You can use an Android emulator, but the emulator is can be really, really slow so I recommend getting an Android device if you can.</p>
<p>First you&#39;ll need to enable USB debugging on your device. That is version/device specific which is why I won&#39;t go over it here. Google search &quot;android enable usb debugging&quot; with your device name and they&#39;ll show you how to do it.</p>
<p>After you set up your Android device, go to Run -&gt; run App.<br><img src="./res/52_nix_run_app.png" alt=""></p>
<p>If you want to see the console output of the app, you can see it in the Android Monitor:<br><img src="./res/52_nix_android_monitor.png" alt=""></p>
<p>The Android Monitor can also show you if there are any ADB errors.</p>
<p>Now that you have SDL 2 running on your device, it&#39;s time to go onto part 2 of the tutorial.</p>
<h2 id="setting-up-sdl-2-on-mac-android-studio-3-0-1">Setting up SDL 2 on Mac Android Studio 3.0.1</h2>
<p><strong>Last Updated 12/29/17</strong></p>
<p>1) Get ready to download. A lot. Like over a gigabyte of data. If you have a limited connection, I&#39;m sorry the android SDK is huge and it&#39;s just the way things are. I recommend having a movie or TV show to watch ready if a gigabyte takes a long time for you to download.</p>
<p>First you need to install the Java Development Kit (JDK). You can download the JDK on <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">this page</a>.</p>
<p><img src="./res/52_mac_jdk_se.png" alt=""></p>
<p><img src="./res/52_mac_jdk_download.png" alt=""></p>
<p>2) Download Android Studio on <a href="https://developer.android.com/studio/index.html">this page</a>.<br><img src="./res/52_mac_download_android_studio.png" alt=""></p>
<p>3) Download the SDL2 source. Not just the development libraries you use for desktop development, the full source. You can find the full source on <a href="https://www.libsdl.org/download-2.0.php">this page</a>.<br><img src="./res/52_mac_download_sdl_source.png" alt=""></p>
<p>4) Install the JDK. Just follow the default installation.</p>
<p>5) Install Android Studio. Installing with default settings will work.</p>
<p>6) After starting Android Studio, go to Configure -&gt; SDK Manager<br><img src="./res/52_mac_configure_sdk_manager.png" alt=""></p>
<p>7) Under SDK Platforms, check Show Package Details and select Android SDK Platform 16 for installation and hit apply to install:<br><img src="./res/52_mac_sdk_platforms.png" alt=""></p>
<p>You may want to install the latest version of the Android SDK but unless you know what you&#39;re doing and you actually need the latest features I would recommend against it. Newer SDK means less stable SDK.</p>
<p>8) Click on SDK Tools and make sure to install:</p>
<ul>
<li>CMake</li><li>NDK</li></ul>
<p><img src="./res/52_mac_sdk_tools.png" alt=""></p>
<p>9) Extract the SDL2 source code to some accessible directory that is ideally dedicated to containing Android libraries. For this tutorial we will put them in the directory &quot;~/androidlib/&quot;. After extracting the SDL2 source code you should have an Android makefile at &quot;~/androidlib/SDL2-2.0.7/Android.mk&quot;. Depending on your version of SDL, it could be at &quot;~/androidlib/SDL2-2.0.5/Android.mk&quot; or &quot;~/androidlib/SDL2-2.0.4/Android.mk&quot; and so on.</p>
<p>10) Start up Android Studio again and import the android project from the SDL2 source code which should be at &quot;~/androidlib/SDL2-2.0.7/android-project&quot;<br><img src="./res/52_mac_import_project.png" alt=""></p>
<p>11) Set the destination to a new folder inside of some accessible directory that is ideally dedicated to containing Android projects. For this tutorial we will put the project in &quot;<strong>YOUR-HOME-DIRECTORY</strong>/androidprojects/SDL_Tutorial&quot;. Select the directory and import the project with the default settings.</p>
<p>12) Go to Build -&gt; Make Project:<br><img src="./res/52_mac_make_project.png" alt=""></p>
<p>You will get an error that says:</p>
<pre><code>Minimum supported Gradle version is 4.1. Current version is 2.14.1.
</code></pre><p>This means our project is set to use the wrong version of Gradle. To fix this, set the Project window to project mode, go to SDL_tutorial -&gt; gradle -&gt; wrapper -&gt; gradle-wrapper.properties and change</p>
<pre><code>distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
</code></pre><p>to</p>
<pre><code>distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
</code></pre><p><img src="./res/52_mac_upgrade_gradle.png" alt=""></p>
<p>Make project again (it may take a while to download Gradle 4.1) and you&#39;ll get a new error:</p>
<pre><code>cannot find symbol class Objects
</code></pre><p>13) That error was due to the fact that Android Studio cannot find the Java Objects class. It can&#39;t find it because it is pointed at an old JDK. To make sure it compiles against the latest version of Java, go to File -&gt; Project Structure.<br><img src="./res/52_mac_project_structure.png" alt=""></p>
<p>Select app under Modules and the set the Source/Target Compatibility to the latest version (currently 1.8):<br><img src="./res/52_mac_set_compatibility.png" alt=""></p>
<p>Build again and you should get a new error.</p>
<p>14) If you try to hit Build -&gt; Make Project you&#39;ll get the following error:</p>
<pre><code>Error:Execution failed for task &#39;:app:compileDebugNdk&#39;. &gt; Error: Your project contains C++ files but it is not using a supported native build system. Consider using CMake or ndk-build integration with the stable Android Gradle plugin: https://developer.android.com/studio/projects/add-native-code.html or use the experimental plugin: https://developer.android.com/studio/build/experimental-plugin.html.
</code></pre><p>This is complaining that the NDK setup is broken for our project.</p>
<p>Let&#39;s back up a bit and talk about how SDL 2 on Android works. Android development is mostly Java based and SDL is a C based library. The Native Development Kit that allows Java to interface with native C/C++ code using the Java Native Interface. With the NDK, we&#39;ll build SDL2 as a shared object that will interface with Java, and we&#39;ll build our game as another shared object that will interface with SDL 2.</p>
<p>What we need to do is tell Gradle (the build tool used by Android Studio) to use the Android make file for our project. Open up the project window, right click on app and select &quot;Link C++ with Gradle&quot;.<br><img src="./res/52_mac_link_cpp_with_gradle.png" alt=""></p>
<p>Set the Build System to ndk-build and set the project path to point to the Android make file which should be at &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/Android.mk&quot;.<br><img src="./res/52_mac_select_android_mk.png" alt=""></p>
<p>Hit Build -&gt; Make Project and you&#39;ll get a bunch of new errors saying something like</p>
<pre><code>Android NDK: Module main depends on undefined modules: SDL2
</code></pre><p>15) What the previous error was complaining about was that it can&#39;t find the SDL 2 module. What we need to do is set up a symbolic link to the SDL 2 source we extracted.</p>
<p>Go to the JNI directory inside the project using this command:</p>
<pre><code>cd ~/androidprojects/SDL_Tutorial/app/src/main/jni
</code></pre><p>And create a symbolic link directory to the SDL 2 source directory we extracted (<strong>REMEMBER: This path will vary depending on your version of SDL 2</strong>):</p>
<pre><code>ln -s ~/androidlib/SDL2-2.0.7/ SDL2
</code></pre><p>Try to rebuild the project. You&#39;ll new a new error but at least now you&#39;ll see symbolic link in the project:<br><img src="./res/52_mac_symbolic_link_in_project.png" alt=""></p>
<p>16) That Gradle error didn&#39;t tell us much so we&#39;ll have to open up the Gradle console:<br><img src="./res/52_mac_open_gradle_console.png" alt=""></p>
<p>Scroll up a bit and you&#39;ll see some errors from the ndk-build. You&#39;ll probably see this error:</p>
<pre><code>make: *** No rule to make target `~/androidprojects/SDL_Tutorial/app/src/main/jni/src/YourSourceHere.c&#39;, needed by `~/androidprojects/SDL_Tutorial/app/build/intermediates/ndkBuild/debug/obj/local/armeabi-v7a/objs-debug/main/YourSourceHere.o&#39;. Stop. make: *** No rule to make target `~/androidprojects/SDL_Tutorial/app/src/main/jni/src/YourSourceHere.c&#39;, needed by `~/androidprojects/SDL_Tutorial/app/build/intermediates/ndkBuild/debug/obj/local/x86/objs-debug/main/YourSourceHere.o&#39;. Stop.
</code></pre><p>In this case, the error &quot;No rule to make target&quot; actually means it can&#39;t find the file you&#39;re asking to compile. It&#39;s trying to compile &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/YourSourceHere.c&quot; but can&#39;t find it which makes sense because it doesn&#39;t exist. YourSourceHere.c is a place holder for our application source file so we need to replace it with ours.</p>
<p>Download the <a href="http://lazyfoo.net/tutorials/SDL/52_hello_mobile/52_hello_mobile.zip">source for lesson 52</a> and place 52_hello_mobile.cpp at &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/52_hello_mobile.cpp&quot;. Open up &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/Android.mk&quot; and change &quot;YourSourceHere.c&quot; to &quot;52_hello_mobile.cpp&quot;. Build and you should get a new error in the Gradle build menu.</p>
<p>17) The error</p>
<pre><code>fatal error: &#39;string&#39; file not found
</code></pre><p>is due to the fact that the project is not set up to us the standard C++ library. To fix this, open up &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/Application.mk&quot; and change</p>
<pre><code># APP_STL := stlport_static
</code></pre><p>to</p>
<pre><code>APP_STL := stlport_static
</code></pre><p>so it&#39;s no longer commmented out. Build again and you should get no errors.</p>
<p>18) Open &quot;~/androidprojects/SDL_Tutorial/app/src/main/res/values/strings.xml&quot; and change</p>
<pre><code>&lt;string name=&quot;app_name&quot;&gt;SDL App&lt;/string&gt;
</code></pre><p>to</p>
<pre><code>&lt;string name=&quot;app_name&quot;&gt;SDL Tutorial&lt;/string&gt;
</code></pre><p>This will change the name under the App&#39;s icon from &quot;SDL App&quot; to &quot;SDL Tutorial&quot;.</p>
<p>19) At this point the app will run our code but it will fail because it can&#39;t load the media files for the tutorial. Media files go in the assets directory. Create a folder called &quot;assets&quot; at &quot;~/androidprojects/SDL_Tutorial/app/src/main/assets&quot;. Copy the directory inside of the zip we downloaded and place it in the assets directory. If the application needs to open &quot;52_hello_mobile/hello.bmp&quot;, it needs to be at &quot;~/androidprojects/SDL_Tutorial/app/src/main/assets/52_hello_mobile/hello.bmp&quot; when building.</p>
<p>20) Our SDL application is ready to build and run, but first we need to set up our device. You can use an Android emulator, but the emulator can be really, really slow so I recommend getting an Android device if you can.</p>
<p>First you&#39;ll need to enable USB debugging on your device. That is version/device specific which is why I won&#39;t go over it here. Google search &quot;android enable usb debugging&quot; with your device name and they&#39;ll show you how to do it.</p>
<p>After you set up your Android device, go to Run -&gt; run App.<br><img src="./res/52_mac_run_app.png" alt=""></p>
<p>If you want to see the console output of the app, you can see it in the Android Monitor:<br><img src="./res/52_mac_android_monitor.png" alt=""></p>
<p>The Android Monitor can also show you if there are any ADB errors.</p>
<p>Now that you have SDL 2 running on your device, it&#39;s time to go onto part 2 of the tutorial.</p>
<h2 id="setting-up-sdl-2-on-ios-with-xcode-9-2">Setting up SDL 2 on iOS with XCode 9.2</h2>
<p><strong>Last Updated 1/21/18</strong></p>
<p>1) Download the SDL2 source. Not just the development libraries you use for desktop development, the full source. You can find the full source on <a href="https://www.libsdl.org/download-2.0.php">this page</a>.<br><img src="./res/52_ios_download_sdl_source.png" alt=""></p>
<p>2) Extract the folder inside of the archive we downloaded to an easily accessible directory that is ideally dedicated to iOS development. For this tutorial we will be putting everything in &quot;~/ioslib&quot;.</p>
<p>After extracting the SDL source you should have it at &quot;~/ioslib/SDL2-2.0.7/&quot; (path will vary depending on your SDL version). Copy the SDL iOS project template located at &quot;~/ioslib/SDL2-2.0.7/Xcode-iOS/Template/SDL iOS Application&quot; to &quot;~/ioslib/SDL2-2.0.7/SDL iOS Application&quot;</p>
<p>3) Open the template project inside of &quot;~/ioslib/SDL2-2.0.7/Xcode-iOS/Template/SDL iOS Application&quot;. Inside you&#39;ll see a broken reference to the SDL source project. Delete it:<br><img src="./res/52_ios_delete_old_reference.png" alt=""></p>
<p>And then add the SDL source project located at &quot;~/ioslib/SDL2-2.0.7/Xcode-iOS/SDL/SDL.xcodeproj&quot;<br><img src="./res/52_ios_add_new_reference.png" alt=""></p>
<p><img src="./res/52_ios_add_sdl_project.png" alt=""></p>
<p>Build the application (command+B) and you should get an error:</p>
<pre><code>entry point (_main) undefined
</code></pre><p>4) To fix the undefined main we need to link the project against SDL. Set the build target to libsdl and build<br><img src="./res/52_ios_compile_libsdl.png" alt=""></p>
<p>Then set the target back to the original project, select the original project, go to Build Phases, and go to Link With Libraries<br><img src="./res/52_ios_link_with_libraries.png" alt=""></p>
<p>And select the libSDL library we compiled<br><img src="./res/52_ios_link_libsdl.png" alt=""></p>
<p>Build again and you&#39;ll get some new errors.</p>
<p>5) We just got a bunch of undefined symbol errors regarding AVAudioSession. To fix that, link with the AVFoundation framework<br><img src="./res/52_ios_link_avfoundation.png" alt=""></p>
<p>6) The project should now build and run with the default source. We want to use our own source code so download the <a href="http://lazyfoo.net/tutorials/SDL/52_hello_mobile/52_hello_mobile.zip">source for lesson 52</a>. Extract the folder inside to your development folder and then delete the default source from the project and add the tutorial source to the project.<br><img src="./res/52_ios_add_tutorial_source.png" alt=""></p>
<p>7) If you try to build the compiler will complain that it can&#39;t find SDL.h. To fix this add the include folder from the SDL source (&quot;~/ioslib/SDL2-2.0.7/include&quot;) to the sources as a group.<br><img src="./res/52_ios_add_include.png" alt=""></p>
<p>And don&#39;t forget to change</p>
<pre><code>#include &lt;SDL.h&gt;
</code></pre><p>to</p>
<pre><code>#include &quot;SDL.h&quot;
</code></pre><p>Now the project should compile and run, but it will crash.</p>
<p>8) The reason this app will crash is because it can&#39;t find the resource files. To add them, add new files to the resources group and select the folder with our demo files. Make sure to add the folder as a folder reference and not a group!<br><img src="./res/52_nix_folder_references.png" alt=""></p>
<p>If your app is trying to load &quot;52_hello_mobile/hello.bmp&quot;, it needs to be in the resources folder in a &quot;52_hello_mobile&quot; folder reference:<br><img src="./res/52_nix_added_resource.png" alt=""></p>
<p>Now build and run your application. The simulator can take up to a minute to boot and run so give it time. With the application building and running, it&#39;s time to go over the source code.</p>
<h2 id="extensions-and-changing-orientation">Extensions and Changing Orientation</h2>
<p><img src="./res/53_preview.png" alt=""></p>
<p><strong>Last Updated 1/21/18</strong></p>
<p>So you learned how to set up the SDL2 library and you want to add SDL extension libraries. Fortunately, SDL_image/SDL_ttf/SDL_mixer are just another library you have to add on and if you already set up SDL2, you made it through the hard part.</p>
<p>After we set up SDL_image, we&#39;ll cover <a href="#extensions-and-changing-orientation-handling-orientation-changes">handling orientation change on Android/iOS</a>.</p>
<table>
<thead>
<tr>
<th>Select Your Mobile/Development Platform</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./res/53_logo1.png" alt=""></td>
<td><a href="#setting-up-sdl_image-on-windows-android-studio-3-0-1">Windows Android Studio 3.0.1</a></td>
</tr>
<tr>
<td><img src="./res/53_logo2.png" alt=""></td>
<td><a href="#setting-up-sdl_image-on-linux-android-studio-3-0-1">Linux Android Studio 3.0.1</a></td>
</tr>
<tr>
<td><img src="./res/53_logo3.png" alt=""></td>
<td><a href="#setting-up-sdl_image-on-mac-android-studio-3-0-1">Mac Android Studio 3.0.1</a></td>
</tr>
<tr>
<td><img src="./res/53_logo4.png" alt=""></td>
<td><a href="#setting-up-sdl_image-on-ios-with-xcode-9-2">iOS XCode 9.2</a></td>
</tr>
</tbody>
</table>
<h2 id="extensions-and-changing-orientation-handling-orientation-changes">Extensions and Changing Orientation: Handling Orientation Changes</h2>
<p><img src="./res/53_preview2.png" alt=""></p>
<p><strong>Last Updated 7/26/17</strong></p>
<p>Now that we got SDL_image loading PNGs, it&#39;s time to handle when our mobile device rotates.</p>
<pre><code>//Screen dimensions
SDL_Rect gScreenRect = { 0, 0, 320, 240 };

//Scene textures
LTexture gPortraitTexture;
LTexture gLandscapeTexture;
</code></pre><p>For this application we&#39;ll be having a different textures render depending on whether the device is in portrait or landscape mode.</p>
<pre><code>        //Create window
        gWindow = SDL_CreateWindow( &quot;SDL Tutorial&quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, gScreenRect.w, gScreenRect.h, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE );
</code></pre><p>When you rotate your device, the height/width of the window changes which means the window size changes. In order to support rotation, the window needs to be created as resizable.</p>
<pre><code>                //Handle events on queue
                while( SDL_PollEvent( &amp;e ) != 0 )
                {
                    //User requests quit
                    if( e.type == SDL_QUIT )
                    {
                        quit = true;
                    }
                    //Window event
                    else if( e.type == SDL_WINDOWEVENT )
                    {
                        //Window resize/orientation change
                        if( e.window.event == SDL_WINDOWEVENT_SIZE_CHANGED )
                        {
                            //Get screen dimensions
                            gScreenRect.w = e.window.data1;
                            gScreenRect.h = e.window.data2;

                            //Update screen
                            SDL_RenderPresent( gRenderer );
                        }
                    }
                }
</code></pre><p>SDL2 turns orientation change events into window change events. We check for window events and if the window event is a size change, we get the new dimensions, and update the screen.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render splash
                if( gScreenRect.h &gt;= gScreenRect.w )
                {
                    gPortraitTexture.render( ( gScreenRect.w - gPortraitTexture.getWidth() ) / 2, ( gScreenRect.h - gPortraitTexture.getHeight() ) / 2 );    
                }
                else
                {
                    gLandscapeTexture.render( ( gScreenRect.w - gLandscapeTexture.getWidth() ) / 2, ( gScreenRect.h - gLandscapeTexture.getHeight() ) / 2 );    
                }

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>How do we tell if the device is in portrait or landscape? Simple: if the height is greater width, it&#39;s in portrait. Otherwise, it&#39;s in landscape.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/53_extensions_and_changing_orientation/53_extensions_and_changing_orientation.zip">here</a>.</p>
<h2 id="setting-up-sdl_image-on-windows-android-studio-3-0-1">Setting up SDL_image on Windows Android Studio 3.0.1</h2>
<p><strong>Last Updated 1/06/18</strong></p>
<p>1) First, download the SDL_image source on <a href="https://www.libsdl.org/projects/SDL_image/">this page</a>.<br><img src="./res/53_win_download.png" alt=""></p>
<p>Extract the source code so it&#39;s at &quot;C:\androidlib\SDL2_image-2.0.2&quot;</p>
<p>2) Download the <a href="http://lazyfoo.net/tutorials/SDL/53_extensions_and_changing_orientation/53_extensions_and_changing_orientation.zip">demo source/assets</a>. Copy the directory inside to &quot;C:\androidprojects\SDL\app\src\main\assets\&quot;. Remember: if the application needs to load &quot;53_extensions_and_changing_orientation/portrait.png&quot; it needs to be at &quot;C:\androidprojects\SDL\app\src\main\assets\53_extensions_and_changing_orientation\portrait.png&quot; when building.</p>
<p>3) Copy demo source to &quot;C:\androidprojects\SDL\app\src\main\jni\src\53_extensions_and_changing_orientation.cpp&quot;. Open the game make file at &quot;C:\androidprojects\SDL\app\src\main\jni\src\Android.mk&quot; and change local source files to include the new demo source file:</p>
<pre><code>LOCAL_SRC_FILES := 53_extensions_and_changing_orientation.cpp
</code></pre><p>Open up Android Studio and try to build. You&#39;ll get an error:</p>
<pre><code>Error:(6, 10) fatal error: &#39;SDL_image.h&#39; file not found
</code></pre><p>This error means that our game source file can&#39;t find SDL_image.h which makes sense since we haven&#39;t set it up yet.</p>
<p>4) SDL_image is just another shared object library that needs to be built along SDL 2 and our C++ application. So that means we need to create a symbolic link to the SDL_image source code. Go to the start menu and run cmd as administrator:<br><img src="./res/53_win_run_cmd_as_admin.png" alt=""></p>
<p>Go to the JNI directory inside the project using this command:</p>
<pre><code>cd &quot;C:\androidprojects\SDL\app\src\main\jni&quot;
</code></pre><p>And create a hard symbolic link directory to the SDL2_image source directory we extracted (<strong>REMEMBER: This path will vary depending on your version of SDL_image</strong>):</p>
<pre><code>mklink /D SDL2_image C:\androidlib\SDL2_image-2.0.2
</code></pre><p>You should get the following message back</p>
<pre><code>symbolic link created for SDL2_image &lt;&lt;===&gt;&gt; C:\androidlib\SDL2_image-2.0.2
</code></pre><p>Build again, you&#39;ll get the same error but at least SDL2_image has a symbolic link in the project now.</p>
<p>5) There may be a symbolic link to SDL_image in the JNI folder but our demo application doesn&#39;t know where it is. To fix this error open up &quot;C:\androidprojects\SDL\app\src\main\jni\src\Android.mk&quot; and change</p>
<pre><code>LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include
</code></pre><p>to</p>
<pre><code>LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include $(LOCAL_PATH)/../SDL2_image/
</code></pre><p>So now our demo application can find the SDL_image headers. Build again and you&#39;ll get a new error:</p>
<pre><code>Error:(120) undefined reference to `IMG_Load&#39; Error:(432) undefined reference to `IMG_Init&#39; Error:(477) undefined reference to `IMG_Quit&#39;
</code></pre><p>6) Those last errors were linker errors. While SDL_image managed to compile and our game managed to compile, we didn&#39;t tell the NDK to link our game against SDL_image. In &quot;C:\androidprojects\SDL\app\src\main\jni\src\Android.mk&quot; change</p>
<pre><code>LOCAL_SHARED_LIBRARIES := SDL2
</code></pre><p>to</p>
<pre><code>LOCAL_SHARED_LIBRARIES := SDL2 SDL2_image
</code></pre><p>Build again. Hopefully you should get the application to build, but you may get an error.</p>
<p>7) You may have gotten a No rule to make target error for IMG_WIC.c. This is the webp library being a pain in the butt. We&#39;re just going to yank it out. Open up Open &quot;C:\androidlib\SDL2_image-2.0.2\Android.mk&quot; and change:</p>
<pre><code>SUPPORT_WEBP ?= true
</code></pre><p>to</p>
<pre><code>SUPPORT_WEBP ?= false
</code></pre><p>Delete the line that says</p>
<pre><code>IMG_WIC.c \
</code></pre><p>and just straight up delete the &quot;C:\androidlib\SDL2_image-2.0.2\external\libwebp-0.6.0&quot; directory. Build again and you should get no errors.</p>
<p>8) The application should now build but IT WILL NOT WORK. We need to get our Java activity load the SDL extension library. Open &quot;C:\androidprojects\SDL\app\src\main\java\org\libsdl\app\SDLActivity.java&quot; and look for this section:</p>
<pre><code>    protected String[] getLibraries() {
        return new String[] {
            &quot;SDL2&quot;,
            // &quot;SDL2_image&quot;,
            // &quot;SDL2_mixer&quot;,
            // &quot;SDL2_net&quot;,
            // &quot;SDL2_ttf&quot;,
            &quot;main&quot;
        };
    }
</code></pre><p>Uncomment the libraries you&#39;ll be using so they&#39;ll be loaded.</p>
<p>9) Build and run. The application should run and rotate. Now that the application built, it&#39;s time to go over the source code.</p>
<h2 id="setting-up-sdl_image-on-linux-android-studio-3-0-1">Setting up SDL_image on Linux Android Studio 3.0.1</h2>
<p><strong>Last Updated 12/26/17</strong></p>
<p>1) First, download the SDL_image source on <a href="https://www.libsdl.org/projects/SDL_image/">this page</a>.<br><img src="./res/53_nix_download.png" alt=""></p>
<p>Extract the source code so it&#39;s at &quot;~/androidlib/SDL2_image-2.0.2&quot;</p>
<p>2) Download the <a href="http://lazyfoo.net/tutorials/SDL/53_extensions_and_changing_orientation/53_extensions_and_changing_orientation.zip">demo source/assets</a>. Copy the directory inside to &quot;~/androidprojects/SDL_Tutorial/app/src/main/assets&quot;. Remember: if the application needs to load &quot;53_extensions_and_changing_orientation/portrait.png&quot; it needs to be at &quot;~/androidprojects/SDL_Tutorial/app/src/main/assets/53_extensions_and_changing_orientation/portrait.png&quot; when building.</p>
<p>3) Copy demo source to &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/53_extensions_and_changing_orientation.cpp&quot;. Open the game make file at &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/Android.mk&quot; and change local source files to include the new demo source file:</p>
<pre><code>LOCAL_SRC_FILES := $(SDL_PATH)/src/main/android/SDL_android_main.c \ 53_extensions_and_changing_orientation.cpp
</code></pre><p>Open up Android Studio and try to build. You&#39;ll get an error:</p>
<pre><code>fatal error: &#39;SDL_image.h&#39; file not found
</code></pre><p>This error means that our game source file can&#39;t find SDL_image.h which makes sense since we haven&#39;t set it up yet.</p>
<p>4) SDL_image is just another shared object library that needs to be built along SDL2 and our C++ application. So that means we need to create a symbolic link to the SDL_image source code. Go to the JNI directory inside the project using this command:</p>
<pre><code>cd ~/androidprojects/SDL_Tutorial/app/src/main/jni
</code></pre><p>And create a symbolic link directory to the SDL2_image source directory we extracted (<strong>REMEMBER: This path will vary depending on your version of SDL_image</strong>):</p>
<pre><code>ln -s ~/androidlib/SDL2_image-2.0.2 SDL2_image
</code></pre><p>Build again, you&#39;ll get the same error but at least SDL2_image has a symbolic link in the project now.</p>
<p>5) There may be a symbolic link to SDL_image in the JNI folder but our demo application doesn&#39;t know where it is. To fix this error open up &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/Android.mk&quot; and change</p>
<pre><code>LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include
</code></pre><p>to</p>
<pre><code>LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include $(LOCAL_PATH)/../SDL2_image/
</code></pre><p>So now our demo application can find the SDL_image headers. Build again and you&#39;ll get a new error:</p>
<pre><code>Error:(120) undefined reference to `IMG_Load&#39; Error:(432) undefined reference to `IMG_Init&#39; Error:(477) undefined reference to `IMG_Quit&#39;
</code></pre><p>6) Those last errors were linker errors. While SDL_image managed to compile and our game managed to compile, we didn&#39;t tell the NDK to link our game against SDL_image. In &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/Android.mk&quot; change</p>
<pre><code>LOCAL_SHARED_LIBRARIES := SDL2
</code></pre><p>to</p>
<pre><code>LOCAL_SHARED_LIBRARIES := SDL2 SDL2_image
</code></pre><p>Build again. Hopefully you should get the application to build, but you may get an error.</p>
<p>7) You may have gotten a No rule to make target error for IMG_WIC.c. This is the webp library being a pain in the butt. We&#39;re just going to yank it out. Open up Open &quot;~/androidlib/SDL2_image-2.0.2/Android.mk&quot; and change:</p>
<pre><code>SUPPORT_WEBP ?= true
</code></pre><p>to</p>
<pre><code>SUPPORT_WEBP ?= false
</code></pre><p>Delete the line that says</p>
<pre><code>IMG_WIC.c \
</code></pre><p>and just straight up delete the &quot;~/androidlib/SDL2_image-2.0.2/external/libwebp-0.6.0&quot; directory. Build again and you should get no errors.</p>
<p>8) The application should now build but <strong>IT WILL NOT WORK</strong>. We need to get our Java activity load the SDL extension library. Open &quot;~/androidprojects/SDL_Tutorial/app/src/main/java/org/libsdl/app/SDLActivity.java&quot; and look for this section:</p>
<pre><code>    protected String[] getLibraries() {
        return new String[] {
            &quot;SDL2&quot;,
            // &quot;SDL2_image&quot;,
            // &quot;SDL2_mixer&quot;,
            // &quot;SDL2_net&quot;,
            // &quot;SDL2_ttf&quot;,
            &quot;main&quot;
        };
    }
</code></pre><p>Uncomment the libraries you&#39;ll be using so they&#39;ll be loaded.</p>
<p>9) Build and run. The application should run and rotate. Now that the application built, it&#39;s time to go over the source code.</p>
<h2 id="setting-up-sdl_image-on-mac-android-studio-3-0-1">Setting up SDL_image on Mac Android Studio 3.0.1</h2>
<p><strong>Last Updated 9/29/17</strong></p>
<p>1) First, download the SDL_image source on <a href="https://www.libsdl.org/projects/SDL_image/">this page</a>.<br><img src="./res/53_mac_download.png" alt=""></p>
<p>Extract the source code so it&#39;s at &quot;~/androidlib/SDL2_image-2.0.2&quot;</p>
<p>2) Download the <a href="http://lazyfoo.net/tutorials/SDL/53_extensions_and_changing_orientation/53_extensions_and_changing_orientation.zip">demo source/assets</a>. Copy the directory inside to &quot;~/androidprojects/SDL_Tutorial/app/src/main/assets&quot;. Remember: if the application needs to load &quot;53_extensions_and_changing_orientation/portrait.png&quot; it needs to be at &quot;~/androidprojects/SDL_Tutorial/app/src/main/assets/53_extensions_and_changing_orientation/portrait.png&quot; when building.</p>
<p>3) Copy demo source to &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/53_extensions_and_changing_orientation.cpp&quot;. Open the game make file at &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/Android.mk&quot; and change local source files to include the new demo source file:</p>
<pre><code>LOCAL_SRC_FILES := $(SDL_PATH)/src/main/android/SDL_android_main.c \ 53_extensions_and_changing_orientation.cpp
</code></pre><p>Open up Android Studio and try to build. You&#39;ll get an error:</p>
<pre><code>fatal error: &#39;SDL_image.h&#39; file not found
</code></pre><p>This error means that our game source file can&#39;t find SDL_image.h which makes sense since we haven&#39;t set it up yet.</p>
<p>4) SDL_image is just another shared object library that needs to be built along SDL2 and our C++ application. So that means we need to create a symbolic link to the SDL_image source code. Go to the JNI directory inside the project using this command:</p>
<pre><code>cd ~/androidprojects/SDL_Tutorial/app/src/main/jni
</code></pre><p>And create a symbolic link directory to the SDL2_image source directory we extracted (<strong>REMEMBER: This path will vary depending on your version of SDL_image)</strong>:</p>
<pre><code>ln -s ~/androidlib/SDL2_image-2.0.2 SDL2_image
</code></pre><p>Build again, you&#39;ll get the same error but at least SDL2_image has a symbolic link in the project now.</p>
<p>5) There may be a symbolic link to SDL_image in the JNI folder but our demo application doesn&#39;t know where it is. To fix this error open up &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/Android.mk&quot; and change</p>
<pre><code>LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include
</code></pre><p>to</p>
<pre><code>LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include $(LOCAL_PATH)/../SDL2_image/
</code></pre><p>So now our demo application can find the SDL_image headers. Build again and you&#39;ll get a new error:</p>
<pre><code>Error:(120) undefined reference to `IMG_Load&#39; Error:(432) undefined reference to `IMG_Init&#39; Error:(477) undefined reference to `IMG_Quit&#39;
</code></pre><p>6) Those last errors were linker errors. While SDL_image managed to compile and our game managed to compile, we didn&#39;t tell the NDK to link our game against SDL_image. In &quot;~/androidprojects/SDL_Tutorial/app/src/main/jni/src/Android.mk&quot; change</p>
<pre><code>LOCAL_SHARED_LIBRARIES := SDL2
</code></pre><p>to</p>
<pre><code>LOCAL_SHARED_LIBRARIES := SDL2 SDL2_image
</code></pre><p>Build again. Hopefully you should get the application to build, but you may get an error.</p>
<p>7) You may have gotten a No rule to make target error for IMG_WIC.c. This is the webp library being a pain in the butt. We&#39;re just going to yank it out. Open up Open &quot;~/androidlib/SDL2_image-2.0.2/Android.mk&quot; and change:</p>
<pre><code>SUPPORT_WEBP ?= true
</code></pre><p>to</p>
<pre><code>SUPPORT_WEBP ?= false
</code></pre><p>Delete the line that says</p>
<pre><code>IMG_WIC.c \
</code></pre><p>and just straight up delete the &quot;~/androidlib/SDL2_image-2.0.2/external/libwebp-0.6.0&quot; directory. Build again and you should get no errors.</p>
<p>8) The application should now build but <strong>IT WILL NOT WORK</strong>. We need to get our Java activity load the SDL extension library. Open &quot;~/androidprojects/SDL_Tutorial/app/src/main/java/org/libsdl/app/SDLActivity.java&quot; and look for this section:</p>
<pre><code>    protected String[] getLibraries() {
        return new String[] {
            &quot;SDL2&quot;,
            // &quot;SDL2_image&quot;,
            // &quot;SDL2_mixer&quot;,
            // &quot;SDL2_net&quot;,
            // &quot;SDL2_ttf&quot;,
            &quot;main&quot;
        };
    }
</code></pre><p>Uncomment the libraries you&#39;ll be using so they&#39;ll be loaded.</p>
<p>9) Build and run. The application should run and rotate. Now that the application built, it&#39;s time to go over the source code.<br>Extensions and Changing Orientation Part 2: Handling Orientation Changes</p>
<h2 id="setting-up-sdl_image-on-ios-with-xcode-9-2">Setting up SDL_image on iOS with XCode 9.2</h2>
<p><strong>Last Updated 1/21/18</strong></p>
<p>1) First, download the SDL_image source on <a href="https://www.libsdl.org/projects/SDL_image/">this page</a>.<br><img src="./res/53_ios_download.png" alt=""></p>
<p>Extract the folder inside to a development directory. For this tutorial we&#39;ll be placing it at &quot;~/ioslib/SDL2_image-2.0.2&quot;.</p>
<p>2) Open up your SDL project. Add the SDL_image project which should be located at ~/ioslib/SDL2_image-2.0.2/Xcode-iOS/SDL_image.xcodeproj<br><img src="./res/53_ios_add_sdl_image_project.png" alt=""></p>
<p>3) Set the target to SDL_image<br><img src="./res/53_ios_target_sdl_image.png" alt=""></p>
<p>Build and you should get an error about missing SDL header files. To fix this add the SDL include folder (which should be located at &quot;~/ioslib/SDL2-2.0.7/include&quot;) to the SDL_image project as a group to the Public Headers:<br><img src="./res/53_ios_add_sdl_headers.png" alt=""></p>
<p>Now the SDL_image library should compile.</p>
<p>4) Download the <a href="http://lazyfoo.net/tutorials/SDL/53_extensions_and_changing_orientation/53_extensions_and_changing_orientation.zip">demo source/assets</a>. Extract source file and add it to the project. Change the target back to the main project and build. You&#39;ll get an error about missing header files. In 53_extensions_and_changing_orientation.cpp, change</p>
<pre><code>#include &lt;SDL.h&gt;
</code></pre><p>to</p>
<pre><code>#include &quot;SDL.h&quot;
#include &lt;SDL_image.h&gt;
</code></pre><p>to</p>
<pre><code>#include &quot;SDL_image.h&quot;
</code></pre><p>You&#39;ll still get an error about missing SDL_image.h files. Simply add SDL_image.h (which should be at &quot;~/ioslib/SDL2_image-2.0.2/SDL_image.h&quot;) to the project:<br><img src="./res/53_ios_add_sdl_image_header.png" alt=""></p>
<p>Build again and it should compile but you&#39;ll get undefined reference errors.</p>
<p>5) To fix the SDL_image linker errors, add the SDL_image library we compiled and ImageIO/MobileCoreServices<br><img src="./res/53_ios_linker.png" alt=""></p>
<p>6) The project will build and run at this point but it will crash because it can&#39;t find assets files. Make sure to add the asset folder <strong>as a reference</strong> so the app and load the image files:<br><img src="./res/53_ios_add_resources.png" alt=""></p>
<p>7) The project should now build and run. To enable orientation changes, select the project then go to General and under Deployment Info check the orientations you want to support.<br><img src="./res/53_ios_orientation.png" alt=""></p>
<p>Now that the application built, it&#39;s time to go over the source code.</p>
<h2 id="touches">Touches</h2>
<p><img src="./res/54_preview.png" alt=""></p>
<p><strong>Last Updated 6/11/19</strong></p>
<p>Now that we know how to load images on mobile, it&#39;s time to handle touch input events.</p>
<pre><code>//Scene textures
LTexture gTouchDownTexture;
LTexture gTouchMotionTexture;
LTexture gTouchUpTexture;
</code></pre><p>For this demo we&#39;ll have a set of textures we&#39;ll be using to indicate what type of touch event happens.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Touch variables
            SDL_Point touchLocation = { gScreenRect.w / 2, gScreenRect.h / 2 };
            LTexture* currentTexture = &amp;gTouchUpTexture;
</code></pre><p>We&#39;ll need to keep track of the touch location and the current touch texture. Here we&#39;re setting the default touch location as the center of the screen and the default touch texture to the touch up texture.</p>
<pre><code>                    //Touch down
                    else if( e.type == SDL_FINGERDOWN )
                    {
                        touchLocation.x = e.tfinger.x * gScreenRect.w;
                        touchLocation.y = e.tfinger.y * gScreenRect.h;
                        currentTexture = &amp;gTouchDownTexture;
                    }
                    //Touch motion
                    else if( e.type == SDL_FINGERMOTION )
                    {
                        touchLocation.x = e.tfinger.x * gScreenRect.w;
                        touchLocation.y = e.tfinger.y * gScreenRect.h;
                        currentTexture = &amp;gTouchMotionTexture;
                    }
                    //Touch release
                    else if( e.type == SDL_FINGERUP )
                    {
                        touchLocation.x = e.tfinger.x * gScreenRect.w;
                        touchLocation.y = e.tfinger.y * gScreenRect.h;
                        currentTexture = &amp;gTouchUpTexture;
                    }
</code></pre><p>When you interact with a touch display, you generate a <a href="https://wiki.libsdl.org/SDL_TouchFingerEvent">SDL_TouchFingerEvent</a>. When the touch starts you get a SDL_FINGERDOWN event, when you move around your finger a SDL_FINGERMOTION happens, and when you release your touch you get a SDL_FINGERUP.</p>
<p>Touch events function pretty much like mouse events with one major difference: touch coordinates are normalized. This means instead of going from 0 to 640 (or what ever the size of your mobile display), they always go from 0 to 1. To get the touch coordinates in screen coordinates simply multiply the touch coordinates by the screen resolution. If you look at the code above that&#39;s exactly what we&#39;re doing here, along with setting the corresponding texture for the given touch event.</p>
<p>One thing not covered here is handling multiple fingers. All we do here is handle the most recent touch event. If you want to handle more than one finger, just keep track of them with their touch IDs. The touch IDs aren&#39;t simple 0, 1, 2, etc but a 64bit integer version of the pointer to the touch data. This quirk has tripped people over before so keep it in mind.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render touch texture
                currentTexture-&gt;render( touchLocation.x - currentTexture-&gt;getWidth() / 2, touchLocation.y - currentTexture-&gt;getHeight() / 2 );

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>As you can see in our rendering, we just render the touch texture at the touch position.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/54_touches/54_touches.zip">here</a>.</p>
<h2 id="multi-touch">Multi Touch</h2>
<p><img src="./res/55_preview.png" alt=""></p>
<p><strong>Last Updated 6/19/19</strong></p>
<p>In this tutorial we&#39;ll be using SDL 2&#39;s built in functionality to handle multi touch gestures like pinch and rotate.</p>
<pre><code>//Scene textures
LTexture gPinchCloseTexture;
LTexture gPinchOpenTexture;
LTexture gRotateTexture;
</code></pre><p>Like in the previous tutorial, we&#39;ll be using a set of textures to show which type of input is happening.</p>
<pre><code>            //Main loop flag
            bool quit = false;

            //Event handler
            SDL_Event e;

            //Touch variables
            SDL_Point touchLocation = { gScreenRect.w / 2, gScreenRect.h / 2 };
            LTexture* currentTexture = &amp;gPinchOpenTexture;
</code></pre><p>Also like the previous tutorial, we&#39;ll need to keep track of the touch location and the current texture to render.</p>
<pre><code>                    //Multi touch gesture
                    else if( e.type == SDL_MULTIGESTURE )
                    {
                        //Rotation detected
                        if( fabs( e.mgesture.dTheta ) &gt; 3.14 / 180.0 )
                        {
                            touchLocation.x = e.mgesture.x * gScreenRect.w;
                            touchLocation.y = e.mgesture.y * gScreenRect.h;
                            currentTexture = &amp;gRotateTexture;
                        }
</code></pre><p>When a multi touch gesture happens a <a href="https://wiki.libsdl.org/SDL_MultiGestureEvent">SDL_MultiGestureEvent</a> gets generated. Here we check for rotations first by checking the angle on the gesture. The thing to remember is that the smallest rotation will get reported so if you pinch and rotate by a 1000th of a radian, it will show up in the gesture. Here we make sure the rotation is at least one degree before reporting it as a rotation.</p>
<p>If the rotation is big enough, we set the location of the gesture and set the texture.</p>
<pre><code>                        //Pinch detected
                        else if( fabs( e.mgesture.dDist ) &gt; 0.002 )
                        {
                            touchLocation.x = e.mgesture.x * gScreenRect.w;
                            touchLocation.y = e.mgesture.y * gScreenRect.h;

                            //Pinch open
                            if( e.mgesture.dDist &gt; 0 )
                            {
                                currentTexture = &amp;gPinchOpenTexture;
                            }
                            //Pinch close
                            else
                            {
                                currentTexture = &amp;gPinchCloseTexture;
                            }
                        }
                    }
</code></pre><p>If the rotation wasn&#39;t big enough, we then check the distance of the pinch. Again remember that coordinates are normalized so a 10 pixel pinch on a 1920 resolution tablet will be reported at around 0.0052.</p>
<p>If the pinch is big enough, we set the gesture position and then check if the pinch was opening or closing.</p>
<pre><code>                //Clear screen
                SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
                SDL_RenderClear( gRenderer );

                //Render touch texture
                currentTexture-&gt;render( touchLocation.x - currentTexture-&gt;getWidth() / 2, touchLocation.y - currentTexture-&gt;getHeight() / 2 );

                //Update screen
                SDL_RenderPresent( gRenderer );
</code></pre><p>Once again like the previous tutorial, in the rendering we show the current gesture texture and the gesture position.<br>Download the media and source code for this tutorial <a href="http://lazyfoo.net/tutorials/SDL/55_multitouch/55_multitouch.zip">here</a>.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
